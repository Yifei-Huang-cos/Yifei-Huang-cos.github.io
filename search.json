[{"title":"AI x game 深度体验报告","path":"/posts/2c281e1a/","content":"AI x game体验报告——是不可替代还是锦上添花？一、背景AI技术近年来发展迅猛，其迭代进程与应用成果已深深融入社会生活各领域，给大众带来了直观且深刻的感知。在此背景下，将AI技术与游戏产业相结合的创作理念逐渐成为热点，各类融合AI元素的新兴游戏产品如同雨后春笋般涌现。 不过，虽然很多游戏都使用AI，但他们的设计理念却不尽相同。有些是利用AI增添新的模块，像是在游戏里增加了接入大模型的可交互的NPC，增加UGC中的AI创作辅助；有些是基于AI构建新的玩法，比如构建一个全部由AI agent构成的社区，观察或参与他们的行为，在这个游戏里，AI是构建整个玩法的底层逻辑；或者更加简单通用一点，只是利用AI进行美术建模和文本的辅助创作……这些游戏到底怎么样，好不好玩，对AI的使用又究竟到了哪一步？我将在其中选择几种具有代表性的进行体验。 二、游玩体验1. AI-陪伴类：情绪价值的提供者现代社会中，快节奏的学习与工作节奏使得部分群体面临人际交往困境，或因社交适应障碍，或因缺乏有效倾诉对象，其情绪宣泄需求难以得到充分满足。在此背景下，在游戏场景中植入AI陪伴功能的设计理念应运而生，为解决此类群体的情绪需求提供了新的载体。 1.1 王者荣耀的灵宝系统和平精英AI战犬玩法2024年2月，王者荣耀上线了灵宝系统；25年11月，和平推出了AI战犬模式。直到今日，灵宝系统也一直在优化与迭代升级，就我个人的体验来说，我还是非常喜欢这个几个小家伙的。为什么这么说呢，我认为这种局内陪伴满足了以下几个优点： 1.1.1 游戏操作正反馈，提供情绪价值尤其在自己单排的时候，4个队友全部闭麦很常见。无论在你打出精彩操作拿到完美击杀还是在大逆风时刻出其不意抢下大龙，队友不一定会夸你，都在闭麦干自己的事。这无可厚非，但没有人为你欢呼 难免会失落。但有灵宝就不一样，他夸奖人来比谁都快比如我玩兰陵王喜欢开局反（tou）对面红buff，每每打完红之后听灵宝来一句：“拿下对面红buff，对面打野恐怕要气疯了吧” 欸嘿，心情就会非常舒坦。 1.1.2 局内提供帮助，利好休闲玩家王者荣耀与和平精英作为国民级手游，拥有庞大的玩家群体，这进一步导致了休闲玩家的比例占绝大多数。相比于硬核玩家，他们的游戏技术或意识显得会比较低。那如何更好的照顾到这类玩家的游戏体验呢？局内陪伴的另一个作用便显现出来了。这里那和平的战犬举例，给出对应的语音指令，战犬便会帮忙收集物资，牵制敌人，或者救助队友，很好的避免了轻度玩家进入游戏后的手忙脚乱。并且他的功能性设计，也不会对游戏平衡性造成很大的破坏。对我这个新手来说，算是帮大忙了 1.1.3 活跃游戏气氛，调节玩家情绪在现代社会中，比完整的游戏时间更难得的是有个和你一起打游戏的朋友，不一定两个人都有时间。所以很多时候我都是单排自己玩，难免会感到寂寞，此时局内陪伴的作用就来了，时不时来两句插科打诨，也可博君一笑。 1.2 星之低语EVE（后者目前只有二测演示视频）1.2.1 whispered from the star该产品是由蔡浩宇主导开发的AI对话类游戏，核心玩法围绕玩家与游戏内漂泊太空的女性角色展开全程对话交互，通过AI的引导与玩家的决策推进剧情。我体验了两个小时，怎么说呢，个人觉得这更像是一款实验品，验证人机交互逻辑和语音识别的先行者，而不是一个完整的游戏。从目前的技术力来看，星之低语的交互建模语音生成乃至情感叙事无疑都走在同类型赛道的前列。但是问题在于，游戏性的缺失导致这不像一个游戏，更像是一次英语口语练习（笑）。其体验的瓶颈也显而易见：后期的交互易陷入重复，缺乏真正的情感弧线与剧情张力。当然啦，它的技术力很强也是无可反驳的。我目前更倾向于认为这是一款公开的试验田，为以后的模型收集数据和反馈，期待他们的下一款游戏。 1.2.2 EVE相比于上面一款，这个游戏的理念更加贴近于传统AI陪伴的概念。该产品以构建3D虚拟伴侣为核心，规划实现对话交互、语音通话、生活服务提醒（如点奶茶、购药等）等功能。由于该产品计划于今年三月公测，且优先面向女性向用户群体，我的体验仅基于测试玩家发布的演示视频进行分析。 从行业发展视角来看，《EVE》的产品形态本身并非我们的关注核心，其背后的设计思路更具行业参考价值。该产品精准命中了AI陪伴领域的核心潜在需求——为用户提供符合个性化想象的、以用户为中心的虚拟伴侣。无论《EVE》正式上线后的市场表现如何，其开创的产品方向必然会引发行业内其他游戏工作室的跟进。社会调查数据显示，大龄单身青年群体规模持续扩大，此类群体的情感需求并未因单身状态而消失，对情感替代载体的需求日益凸显。而具备高真实度交互能力的AI虚拟伴侣，恰好能够满足这一需求。未来，该赛道有望涌现更多高技术力产品，但如何实现产品差异化竞争，将成为我们需要深入思考的核心问题。 2. AI NPC：最多的可能性，但被技术力约束曾经，NPC所说的话总是由文案策划构思好，虽然这对于游戏的推进来说是最快捷的方式，但看多了不免感到乏味。随着LLM的兴起，大家不约而同的想到那个可能性————让大模型控制NPC的交流行为甚至剧情。 2.1 逆水寒燕云十六声在我印象里，逆水寒最早大规模宣传自己的AI npc，当时我也是因为这个宣传下载体验了一番汴京的风土人情。当时也涌现了很多与AI对话的“焚诀”，和ai npc斗智斗勇也成了每天上线不得不品的一环。乐趣确实有，也能通过文字交流得到npc的物品，在当时给我感觉还是比较新奇有趣的。 比较可惜的是，这些玩法没有更进一步，你和npc的对话对游戏主体的影响微乎其微，也基本在主线剧情中得不到体现。在这两款游戏里，AI不是一个不可代替的玩法，只是一个外接的模块，可以说删了这个功能换成传统的npc对话形式也不会对游戏产生多大影响。只能说这是受限于目前的技术力，还无法做到AI影响的多剧情分支走向（也可能是不方便管理？） 2.2 AI bot，觉悟人机这就比较的传统并且成熟了，在游戏对局内补充人机有利于减少玩家匹配时间，控制对局强度，也有利于新手玩家熟悉游戏，由于在大部分游戏里已经有了较为成熟的应用，本文不再赘述 3. AI作为游戏基石：未来将至？以上是在传统的游戏中增添AI的元素，那么我们有没有可能以AI为底层逻辑创建一个游戏呢？很多影视文学作品都给出过设想，例如头号玩家，失控玩家以及前几年较火的元宇宙概念，他们都给我们提供了一种可能性。我也很高兴的看到有很多游戏在向这方面发展，例如斯坦福小镇，avilizition以及喵吉托的几款游戏demo（例如喵呜岛）。 3.1 avilizition的体验这个项目更准确地应该称为一个模拟平台。它的核心理念非常吸引人（也是我所展望追求的）：每个智能体都有独立的记忆、人际关系和日程，所有的决策都具有蝴蝶效应，npc并能根据与环境和彼此的互动来动态决策。 我的体验过程充满了新奇与困惑。一开始，我就像进入了一个上帝视角的观察者，看着这些像素小人在小镇里活动，他们会上班、购物、聊天、举办活动。最让我感到惊讶的是，他们之间的互动确实能产生一些预设脚本之外的故事。比如，我看到两个角色因为在咖啡馆的一次聊天而决定晚上一起去酒吧，或者因为之前的某次争执而在下一次见面时显得冷淡。这种基于记忆和关系链产生的行为变化，是它最核心的亮点，让你感觉这个小镇是活的，有自己的时间流。 但是，这种新鲜感褪去得也很快。首先是交互的乏力感。作为玩家，我能与这些AI角色对话，但对话内容往往流于表面，很难进行有深度的、能实质性改变他们目标或关系的交流。更多的时候，我感觉我是在试图引导对话，而不是在进行有意义的角色扮演。avilizition给我的感觉是，它是一座通往未来游戏理念的桥梁设计图，但我们脚下的建筑材料还不足以把它扎实地建造起来。它足以证明了AI作为游戏世界底层逻辑的可行性，但要把它变成一款好玩的游戏，还有很长的路要走。 三、总结经过这些体验，我认为目前AI在游戏中的应用，整体上仍然处于“锦上添花”的阶段。无论是提供陪伴的灵宝、战犬，还是能自由对话的NPC，它们确实带来了新鲜感和更好的体验，像是给原有的蛋糕裱上了更精美的花。但如果我们把花拿走，蛋糕本身并没有改变。它们更多是体验的优化与内容的补充。 然而，从《星之低语》、《EVE》这类纯粹的AI交互应用，尤其是像avilizition这样以AI为世界基石的尝试中，我们能看到一种截然不同的可能性。它们不再满足于做蛋糕上的点缀，而是试图用AI这种新材料，从头烤制一块全新的、我们从未尝过的点心。虽然目前这些可能还有些生涩，形态也不稳定，但方向已经指明。 所以，我的看法是：未来，AI完全有可能成为构建游戏里不可替代的基石。这条路很长，但起点已经在我们脚下。","categories":["游戏"]},{"title":"刚体运动的python解法","path":"/posts/48befe4f/","content":"自由转动杆与铰链固定杆倾倒时间对比研究一、问题背景​\t某p大友人中午问了我一个问题 ​ 曾经自诩“高中物理领域神棍”的我也是体会了一把修为尽失的感觉…….可恶，还是，做不到吗。。。 才怪！现在我有了新的武器，解析不了我就暴力数值解嘻嘻 二、物理模型2.1 自由杆（光滑地面） 约束条件：底端无水平约束，质心水平方向动量守恒 运动特点：质心同时有平动和转动 能量方程：$E \\frac{1}{2}mv_c^2 + \\frac{1}{2}I_c\\omega^2 + mg\\frac{L}{2}\\cos\\theta$ 2.2 铰链杆（固定底端） 约束条件：底端位置固定，绕该点纯转动 运动特点：质心作圆弧运动 能量方程：$E \\frac{1}{2}I_o\\omega^2 + mg\\frac{L}{2}\\cos\\theta$ 三、动力学方程推导3.1 自由杆的倾倒时间# 自由杆的角速度公式推导ω² = (4g/L) * (cosθ₀ - cosθ) 3.2 铰链杆的倾倒时间# 铰链杆的角速度公式推导ω² = (3g/L) * (cosθ₀ - cosθ) 四、数值计算方法4.1 时间积分公式倾倒时间通过对角速度倒数积分得到：$$ t \\int_{\\theta_0}^{\\pi2} \\frac{1}{\\omega(\\theta)} d\\theta $$ 4.2 数值实现代码自由杆计算代码import numpy as npg = 9.81L = float(input(请输入杆长 L (米): ))theta0_deg = float(input(请输入初始倾斜角度 (0–90°, 相对竖直): ))theta0 = np.deg2rad(theta0_deg)theta_end = np.pi / 2def integrand(theta): omega = np.sqrt((4 * g / L) * (np.cos(theta0) - np.cos(theta))) return 1.0 / omegathetas = np.linspace(theta0 + 1e-6, theta_end, 200000)t = np.trapezoid(integrand(thetas), thetas) 铰链杆计算代码import numpy as npg = 9.81L = float(input(请输入杆长 L (米): ))theta0_deg = float(input(请输入初始倾斜角度 (0–90°, 相对竖直): ))theta0 = np.deg2rad(theta0_deg)theta_end = np.pi / 2def integrand(theta): omega = np.sqrt((3 * g / L) * (np.cos(theta0) - np.cos(theta))) return 1.0 / omegathetas = np.linspace(theta0 + 1e-6, theta_end, 200000)t = np.trapezoid(integrand(thetas), thetas) 五、模拟结果分析5.1 不同初始角度对比（默认杆长1m） 初始角度 自由杆时间(s) 铰链杆时间(s) 时间比(自由铰链) 1° 1.1837 1.3668 想算的自己算 10° 0.6648 0.7676 30° 0.4163 0.4807 (— __ —) 45° 0.3201 0.3697 60° 0.2431 0.2807 80° 0.1338 0.1545 5.2 不同杆长对比（默认倾斜30°） 杆长(m) 自由杆时间(s) 铰链杆时间(s) 时间比 0.5 0.2944 0.3399 1.0 0.4163 0.4807 2.0 0.5888 0.6799 5.0 0.9309 1.0750 六、结论自由杆下落更快！ 但原因是什么呢 有没有能给我推导过程的QAQ 在线等~ 附录：论AI目前为什么不能取代人类请看vcr 1.《有固定点，小角度？那就是简谐运动！》————来自亲爱的deepseek 2.《什么是物理，我听不懂，倾斜的杆子就是不会掉下来，牛顿说啥我不管》 ————GPT5 plus大人！\\0 建议加入ai笑话大全~","categories":["编程"]},{"title":"python网络编程--TCP篇","path":"/posts/8d64c14e/","content":"TCP网络编程初步在学习并发编程之前，先熟悉一个客户端与一个服务端 TCP协议核心机制TCP（传输控制协议）通过三次握手建立连接，通过四次挥手终止连接，确保数据传输的可靠性。 服务端实现代码import socketserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 服务端的socket IPV4 TCP# 这个只负责接受客户端的连接请求server_socket.bind((, 8000))# 允许最大的等待个数server_socket.listen(128)# 接受客户端的连接socket2, client_addr = server_socket.accept()while True: msg = socket2.recv(1024).decode(utf8) if msg == quit: break print(f来自客户端IP：client_addr[0],端口号client_addr[1]:msg) # 给客户端发送聊天信息 send_msg = input(server) socket2.send(send_msg.encode(utf8))socket2.close()server_socket.close() 客户端实现代码import socketclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server_addr = (192.168.100.199, 8000)client_socket.connect(server_addr)while True: send_msg = input(client) if send_msg == quit: client_socket.send(send_msg.encode(utf8)) break client_socket.send(send_msg.encode(utf8)) msg = client_socket.recv(1024).decode(utf8) print(f来自服务端IP：server_addr[0],端口号server_addr[1]:msg)client_socket.close() TCP三次握手详解三次握手是TCP建立连接的过程，确保双方都有发送和接收能力。 第一次握手：SYN客户端 → SYN=1, seq=x → 服务端 客户端发送SYN包，seq为随机数x，进入SYN_SENT状态。 第二次握手：SYN+ACK客户端 ← SYN=1, ACK=1, seq=y, ack=x+1 ← 服务端 服务端收到SYN，发送SYN+ACK包： seq为随机数y ack为x+1（确认收到客户端的x）服务端进入SYN_RCVD状态。 第三次握手：ACK客户端 → ACK=1, seq=x+1, ack=y+1 → 服务端 客户端发送ACK包： seq为x+1 ack为y+1（确认收到服务端的y）双方进入ESTABLISHED状态，连接建立。 代码中的三次握手# 客户端发起连接（第一次握手）client_socket.connect(server_addr)# 服务端接受连接（完成三次握手）socket2, client_addr = server_socket.accept() TCP四次挥手详解四次挥手是TCP断开连接的过程，确保双方数据都传输完毕。 第一次挥手：FIN客户端 → FIN=1, seq=u → 服务端 客户端发送FIN包，seq为u，进入FIN_WAIT_1状态。 第二次挥手：ACK客户端 ← ACK=1, seq=v, ack=u+1 ← 服务端 服务端发送ACK包： ack为u+1（确认收到客户端的FIN）服务端进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态。 第三次挥手：FIN客户端 ← FIN=1, ACK=1, seq=w, ack=u+1 ← 服务端 服务端发送FIN+ACK包，进入LAST_ACK状态。 第四次挥手：ACK客户端 → ACK=1, seq=u+1, ack=w+1 → 服务端 客户端发送ACK包，进入TIME_WAIT状态（等待2MSL），服务端关闭连接。 代码中的四次挥手# 客户端发送quit（发起第一次挥手）client_socket.send(quit.encode(utf8))# 服务端收到quit（第二次挥手）msg = socket2.recv(1024).decode(utf8)if msg == quit: break# 关闭套接字（完成挥手过程）socket2.close()server_socket.close()client_socket.close() TCP状态转换建立连接状态 CLOSED：初始状态 SYN_SENT：客户端发送SYN后 LISTEN：服务端调用listen()后 SYN_RCVD：服务端收到SYN后 ESTABLISHED：连接建立完成 断开连接状态 FIN_WAIT_1：客户端第一次挥手 CLOSE_WAIT：服务端第一次收到FIN FIN_WAIT_2：客户端收到ACK LAST_ACK：服务端发送FIN TIME_WAIT：客户端最后等待 CLOSED：连接完全关闭 为什么需要三次握手？防止旧的重复连接初始化 避免网络延迟导致的旧连接干扰新连接 确保双方都知道对方准备好了 同步序列号 交换初始序列号（ISN） 确保数据按序传输 确认双方能力 确认双方都有发送和接收能力 协商窗口大小等参数 为什么需要四次挥手？半关闭状态 TCP是全双工的，可以单向关闭 服务端可能还有数据要发送 确保数据完整性 等待所有数据都传输完毕 确保没有数据丢失 可靠终止 双方都知道连接要关闭了 防止数据包在网络中”迷路” TIME_WAIT状态的作用等待2MSL的原因 确保最后一个ACK到达：如果服务端没收到ACK会重发FIN 让旧连接的数据包消失：防止影响新连接 MSL（Maximum Segment Lifetime）：报文最大生存时间 实际编程中的影响连接建立失败try: client_socket.connect(server_addr)except ConnectionRefusedError: print(连接被拒绝：服务端未启动或端口错误) 端口复用问题# 避免Address already in use错误server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) 关闭# 半关闭：关闭发送，仍可接收client_socket.shutdown(socket.SHUT_WR)# 等待对方关闭while True: data = client_socket.recv(1024) if not data: break 总结三次握手建立可靠连接，四次挥手优雅终止连接，这是TCP协议的核心机制。理解这些过程对于调试网络问题和编写稳定的网络程序非常重要。 在代码中，connect()触发三次握手，close()触发四次挥手，这些细节都由操作系统自动处理。","categories":["编程"]},{"title":"UDP的简易实现","path":"/posts/35e240ca/","content":"PYTHON网络编程——UDP篇一、UDP简介什么是UDP？UDP（用户数据报协议）是一种无连接的传输层协议，具有以下特点： 无需建立连接 不可靠传输（可能丢包） 传输速度快 适合实时性要求高的场景 基本流程对比TCP编程流程：创建socket → 绑定 → 监听 → 接受连接 → 收发数据 → 关闭UDP编程流程：创建socket → 绑定（服务端）→ 直接收发数据 → 关闭 二、服务端代码详解import socket# 创建了一个UDP的socket对象server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# socket.AF_INET: 使用IPv4地址族# socket.SOCK_DGRAM: 使用UDP协议（数据报套接字）# 前一个是我的ipv4地址，如果用127.0.0.1则是在本地# 如果是空字符，服务端绑定到所有的ip地址server_socket.bind((192.168.100.199, 6666))# bind()方法将套接字绑定到指定地址和端口# 192.168.100.199: 绑定到特定局域网IP# 其他选择：# 127.0.0.1: 本地回环，只能本机访问# 0.0.0.0: 绑定所有网络接口# : 同0.0.0.0# 6666: 端口号，范围0-65535（0-1023为系统保留）while True: # msg是收到的数据，addr是源地址和端口号 msg, addr = server_socket.recvfrom(1024) # recvfrom()是阻塞方法，会一直等待直到收到数据 # 1024: 缓冲区大小，单位字节 # msg: 接收到的字节数据 # addr: 元组 (客户端IP, 客户端端口) if msg.decode(utf8) == quit: break # 如果客户端发送quit，则退出循环 print(f来自IP：addr[0],端口号：addr[1]的消息：msg) # 显示消息来源和内容 send_msg = input(服务端) # 等待用户输入回复内容 # 不能发送字符串，应该是字节数据 server_socket.sendto(send_msg.encode(utf8), addr) # sendto()发送数据到指定地址 # encode(utf8): 将字符串转为字节数据 # addr: 目标地址（这里发回给原客户端）# closeserver_socket.close()# 关闭套接字，释放资源 三、客户端代码详解import socket# 创建了一个UDP的socket对象client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 客户端socket不用bind# 客户端通常由系统自动分配端口号# 如果需要绑定特定端口，也可以使用bind()while True: # send msg send_msg = input(客户端) if send_msg == quit: break # 输入quit退出 client_socket.sendto(send_msg.encode(utf8), (192.168.100.199, 6666)) # 发送数据到服务器 # (192.168.100.199, 6666): 服务器地址和端口 # 必须与服务器绑定的地址一致 # receive msg msg, addr = client_socket.recvfrom(1024) # 等待服务器回复 # 注意：这里会阻塞，直到收到服务器响应 print(f来自服务端IP：addr[0],端口号：addr[1]的消息：msg) # 显示服务器回复client_socket.close()# 关闭客户端套接字 四、关键知识点1. UDP套接字创建socket.socket(socket.AF_INET, socket.SOCK_DGRAM) AF_INET: IPv4地址族 SOCK_DGRAM: UDP数据报类型 2. 地址绑定# 服务端必须绑定，客户端可选server_socket.bind((IP地址, 端口号)) 3. 数据收发# 接收数据（返回数据和来源地址）data, addr = socket.recvfrom(缓冲区大小)# 发送数据到指定地址socket.sendto(字节数据, (目标IP, 目标端口)) 4. 编码转换# 发送：字符串 → 字节send_msg.encode(utf8)# 接收：字节 → 字符串msg.decode(utf8) 五、注意事项 UDP是无连接的 每次发送都要指定目标地址 不保证数据顺序和可靠性 地址和端口 服务端需要固定端口 客户端端口通常由系统分配 数据大小 UDP数据包不宜过大（通常1500字节） 避免IP分片，提高传输效率 阻塞问题 recvfrom()是阻塞调用 程序会等待直到收到数据 多客户端处理 UDP服务端可以同时处理多个客户端 通过addr区分不同客户端 六、常见问题Q1: 为什么客户端不需要bind？A: 客户端第一次调用sendto()时，系统会自动分配一个可用端口。 Q2: 如果服务器没启动，客户端会怎样？A: 客户端发送的数据会丢失，recvfrom()会一直等待（阻塞）。 Q3: 如何测试本机通信？A: 服务端绑定127.0.0.1，客户端连接127.0.0.1。 Q4: 如何让其他电脑连接？A: 服务端绑定0.0.0.0或局域网IP 关闭防火墙或开放对应端口 客户端使用服务器实际IP地址 七、完整的UDP还需要 异常处理：添加try-except处理网络错误 超时设置：使用settimeout()避免永久阻塞 多线程：同时处理多个客户端请求 数据验证：添加简单的协议头验证数据完整性 八、总结​ UDP编程的核心模式： 服务端：创建→绑定→循环收发→关闭 客户端：创建→循环收发→关闭 这种简单的请求-响应模式是UDP编程的基础，理解了这种模式后，可以在此基础上构建更复杂的UDP应用。 注：实际使用时，请确保服务端和客户端的IP地址和端口号配置正确，防火墙已开放相应端口。","categories":["编程"]},{"title":"如何用hexo搭建个人博客","path":"/posts/cd1cb590/","content":"Hexo 博客搭建与配置指南📖 简介Hexo 是一个快速、简洁且高效的静态博客框架。它使用 Markdown解析文章，在几秒内即可生成静态网页。本指南将帮助您快速搭建并配置一个 Hexo 博客。 🚀 快速开始环境准备 安装 Node.js 版本要求：Node.js 14.0 或以上版本 下载地址：Node.js 官网 安装 Git 下载地址：Git 官网 安装 Hexo打开终端（命令提示符）并执行： npm install -g hexo-cli 初始化博客hexo init my-blogcd my-blognpm install 本地预览hexo clean# 生成：hexo g# 预览： （浏览器访问 `http://localhost:4000` 查看效果）hexo s# 部署：hexo d ⚙️ 基本配置配置文件博客的主要配置文件为 _config.yml，位于博客根目录下。 常用配置项# 网站信息title: 我的博客 # 网站标题subtitle: # 网站副标题description: # 网站描述keywords: # 网站关键词author: 作者名 # 作者名称language: zh-CN # 语言timezone: # 时区# URL 设置url: http://yoursite.com # 网站地址root: / # 网站根目录permalink: :year/:month/:day/:title/ # 文章永久链接格式# 目录设置source_dir: source # 资源文件夹public_dir: public # 静态文件生成目录# 写作设置new_post_name: :title.md # 新文章文件名格式default_layout: post # 默认布局 🎨 主题安装与配置安装主题以我所使用的stellar 主题为例： cd my-bloggit clone https://github.com/stellar-theme/hexo-theme-syellar themes/stellar 启用主题修改 _config.yml： theme: stellar 主题配置主题有自己的配置文件 themes/stellar/_config.yml，可进行个性化设置。 📝 写作与发布创建新文章hexo new 文章标题 文章文件位于 source/_posts/文章标题.md 文章 Front-matter---title: 文章标题date: 2024-05-20 10:00:00tags: [标签1, 标签2]categories: 分类名--- 常用命令 hexo new [layout] title - 新建文章 hexo clean - 清除缓存 hexo generate 或 hexo g - 生成静态文件 hexo server 或 hexo s - 启动本地服务器 hexo deploy 或 hexo d - 部署到远程仓库 🌐 部署到 GitHub Pages准备工作 创建 GitHub 仓库，命名为 用户名.github.io 安装部署插件： npm install hexo-deployer-git --save 配置部署修改 _config.yml： deploy: type: git repo: https://github.com/用户名/用户名.github.io.git branch: main 部署命令hexo cleanhexo generatehexo deploy 🔧 常用插件# RSS 订阅npm install hexo-generator-feed --save# 站点地图npm install hexo-generator-sitemap --save# 文章搜索npm install hexo-generator-searchdb --save# 文章字数统计npm install hexo-wordcount --save 💡 实用技巧自定义页面hexo new page about 草稿功能hexo new draft 草稿标题hexo publish 草稿标题 图片引用 将图片放入 source/images/ 目录 在文章中引用： ![图片描述](/images/图片文件名.jpg) 🛠️ 故障排除常见问题 部署失败 检查 Git 配置 确认仓库地址正确 检查网络连接 页面无法加载 运行 hexo clean 重新生成和启动服务器 主题不生效 确认主题文件夹名称正确 检查 _config.yml 中 theme 配置 📚 学习资源 Hexo 官方文档 Hexo GitHub Next 主题文档 提示：配置时建议备份原配置文件，每次只修改少量配置并测试效果。"},{"title":"关于我 | 黄逸飞的个人小站","path":"/about/index.html","content":"👋 关于我大家好，我是黄逸飞，目前就读于中国科学技术大学本科人工智能专业。很荣幸能和你在这里相遇。中科大严谨的学术氛围与自由的探索环境，让我在求知的道路上持续成长，也让我养成了对新鲜事物保持好奇、对热爱之事全力以赴的性格。 💻 我想分享的事 编程：无需多言，发际线就是最好的见证。我会在这里梳理我的学习路径，既是复盘，也希望能给同路的你一点参考。 阅读：这是我逃离喧嚣的秘密基地。无论是计算机领域的专业书籍，还是文学、历史类读物，我都愿意静下心来慢慢品读。阅读不仅能补充知识，更能拓宽视野，让我在快节奏的生活里守住一份沉稳。 游戏：AI与游戏的结合（AI x GAME）是我一直感兴趣的方向，未来也会持续探索这个领域的未知可能。 📌 小站的意义这个博客是我记录生活、分享思考的自留地，后续会不定期更新这些内容： 编程学习中的踩坑笔记、技术总结； 阅读后的感悟与书单推荐； 游戏体验、攻略分享； 偶尔的生活碎碎念。 如果你也对这些话题感兴趣，欢迎常来逛逛、留言交流～愿我们都能在热爱的领域里闪闪发光，也能在平凡的日子里收获属于自己的小确幸！ ✨ 感谢相遇，期待成为朋友！"}]