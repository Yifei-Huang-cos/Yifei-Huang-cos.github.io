[{"title":"python网络编程--TCP篇","path":"/2026/01/26/","content":"TCP网络编程初步在学习并发编程之前，先熟悉一个客户端与一个服务端 TCP协议核心机制TCP（传输控制协议）通过三次握手建立连接，通过四次挥手终止连接，确保数据传输的可靠性。 服务端实现代码import socketserver_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# 服务端的socket IPV4 TCP# 这个只负责接受客户端的连接请求server_socket.bind((, 8000))# 允许最大的等待个数server_socket.listen(128)# 接受客户端的连接socket2, client_addr = server_socket.accept()while True: msg = socket2.recv(1024).decode(utf8) if msg == quit: break print(f来自客户端IP：client_addr[0],端口号client_addr[1]:msg) # 给客户端发送聊天信息 send_msg = input(server) socket2.send(send_msg.encode(utf8))socket2.close()server_socket.close() 客户端实现代码import socketclient_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server_addr = (192.168.100.199, 8000)client_socket.connect(server_addr)while True: send_msg = input(client) if send_msg == quit: client_socket.send(send_msg.encode(utf8)) break client_socket.send(send_msg.encode(utf8)) msg = client_socket.recv(1024).decode(utf8) print(f来自服务端IP：server_addr[0],端口号server_addr[1]:msg)client_socket.close() TCP三次握手详解三次握手是TCP建立连接的过程，确保双方都有发送和接收能力。 第一次握手：SYN客户端 → SYN=1, seq=x → 服务端 客户端发送SYN包，seq为随机数x，进入SYN_SENT状态。 第二次握手：SYN+ACK客户端 ← SYN=1, ACK=1, seq=y, ack=x+1 ← 服务端 服务端收到SYN，发送SYN+ACK包： seq为随机数y ack为x+1（确认收到客户端的x）服务端进入SYN_RCVD状态。 第三次握手：ACK客户端 → ACK=1, seq=x+1, ack=y+1 → 服务端 客户端发送ACK包： seq为x+1 ack为y+1（确认收到服务端的y）双方进入ESTABLISHED状态，连接建立。 代码中的三次握手# 客户端发起连接（第一次握手）client_socket.connect(server_addr)# 服务端接受连接（完成三次握手）socket2, client_addr = server_socket.accept() TCP四次挥手详解四次挥手是TCP断开连接的过程，确保双方数据都传输完毕。 第一次挥手：FIN客户端 → FIN=1, seq=u → 服务端 客户端发送FIN包，seq为u，进入FIN_WAIT_1状态。 第二次挥手：ACK客户端 ← ACK=1, seq=v, ack=u+1 ← 服务端 服务端发送ACK包： ack为u+1（确认收到客户端的FIN）服务端进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态。 第三次挥手：FIN客户端 ← FIN=1, ACK=1, seq=w, ack=u+1 ← 服务端 服务端发送FIN+ACK包，进入LAST_ACK状态。 第四次挥手：ACK客户端 → ACK=1, seq=u+1, ack=w+1 → 服务端 客户端发送ACK包，进入TIME_WAIT状态（等待2MSL），服务端关闭连接。 代码中的四次挥手# 客户端发送quit（发起第一次挥手）client_socket.send(quit.encode(utf8))# 服务端收到quit（第二次挥手）msg = socket2.recv(1024).decode(utf8)if msg == quit: break# 关闭套接字（完成挥手过程）socket2.close()server_socket.close()client_socket.close() TCP状态转换建立连接状态 CLOSED：初始状态 SYN_SENT：客户端发送SYN后 LISTEN：服务端调用listen()后 SYN_RCVD：服务端收到SYN后 ESTABLISHED：连接建立完成 断开连接状态 FIN_WAIT_1：客户端第一次挥手 CLOSE_WAIT：服务端第一次收到FIN FIN_WAIT_2：客户端收到ACK LAST_ACK：服务端发送FIN TIME_WAIT：客户端最后等待 CLOSED：连接完全关闭 为什么需要三次握手？防止旧的重复连接初始化 避免网络延迟导致的旧连接干扰新连接 确保双方都知道对方准备好了 同步序列号 交换初始序列号（ISN） 确保数据按序传输 确认双方能力 确认双方都有发送和接收能力 协商窗口大小等参数 为什么需要四次挥手？半关闭状态 TCP是全双工的，可以单向关闭 服务端可能还有数据要发送 确保数据完整性 等待所有数据都传输完毕 确保没有数据丢失 可靠终止 双方都知道连接要关闭了 防止数据包在网络中”迷路” TIME_WAIT状态的作用等待2MSL的原因 确保最后一个ACK到达：如果服务端没收到ACK会重发FIN 让旧连接的数据包消失：防止影响新连接 MSL（Maximum Segment Lifetime）：报文最大生存时间 实际编程中的影响连接建立失败try: client_socket.connect(server_addr)except ConnectionRefusedError: print(连接被拒绝：服务端未启动或端口错误) 端口复用问题# 避免Address already in use错误server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) 关闭# 半关闭：关闭发送，仍可接收client_socket.shutdown(socket.SHUT_WR)# 等待对方关闭while True: data = client_socket.recv(1024) if not data: break 总结三次握手建立可靠连接，四次挥手优雅终止连接，这是TCP协议的核心机制。理解这些过程对于调试网络问题和编写稳定的网络程序非常重要。 在代码中，connect()触发三次握手，close()触发四次挥手，这些细节都由操作系统自动处理。"},{"title":"UDP的简易实现","path":"/2026/01/26/","content":"PYTHON网络编程——UDP篇一、UDP简介什么是UDP？UDP（用户数据报协议）是一种无连接的传输层协议，具有以下特点： 无需建立连接 不可靠传输（可能丢包） 传输速度快 适合实时性要求高的场景 基本流程对比TCP编程流程：创建socket → 绑定 → 监听 → 接受连接 → 收发数据 → 关闭UDP编程流程：创建socket → 绑定（服务端）→ 直接收发数据 → 关闭 二、服务端代码详解import socket# 创建了一个UDP的socket对象server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# socket.AF_INET: 使用IPv4地址族# socket.SOCK_DGRAM: 使用UDP协议（数据报套接字）# 前一个是我的ipv4地址，如果用127.0.0.1则是在本地# 如果是空字符，服务端绑定到所有的ip地址server_socket.bind((192.168.100.199, 6666))# bind()方法将套接字绑定到指定地址和端口# 192.168.100.199: 绑定到特定局域网IP# 其他选择：# 127.0.0.1: 本地回环，只能本机访问# 0.0.0.0: 绑定所有网络接口# : 同0.0.0.0# 6666: 端口号，范围0-65535（0-1023为系统保留）while True: # msg是收到的数据，addr是源地址和端口号 msg, addr = server_socket.recvfrom(1024) # recvfrom()是阻塞方法，会一直等待直到收到数据 # 1024: 缓冲区大小，单位字节 # msg: 接收到的字节数据 # addr: 元组 (客户端IP, 客户端端口) if msg.decode(utf8) == quit: break # 如果客户端发送quit，则退出循环 print(f来自IP：addr[0],端口号：addr[1]的消息：msg) # 显示消息来源和内容 send_msg = input(服务端) # 等待用户输入回复内容 # 不能发送字符串，应该是字节数据 server_socket.sendto(send_msg.encode(utf8), addr) # sendto()发送数据到指定地址 # encode(utf8): 将字符串转为字节数据 # addr: 目标地址（这里发回给原客户端）# closeserver_socket.close()# 关闭套接字，释放资源 三、客户端代码详解import socket# 创建了一个UDP的socket对象client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# 客户端socket不用bind# 客户端通常由系统自动分配端口号# 如果需要绑定特定端口，也可以使用bind()while True: # send msg send_msg = input(客户端) if send_msg == quit: break # 输入quit退出 client_socket.sendto(send_msg.encode(utf8), (192.168.100.199, 6666)) # 发送数据到服务器 # (192.168.100.199, 6666): 服务器地址和端口 # 必须与服务器绑定的地址一致 # receive msg msg, addr = client_socket.recvfrom(1024) # 等待服务器回复 # 注意：这里会阻塞，直到收到服务器响应 print(f来自服务端IP：addr[0],端口号：addr[1]的消息：msg) # 显示服务器回复client_socket.close()# 关闭客户端套接字 四、关键知识点1. UDP套接字创建socket.socket(socket.AF_INET, socket.SOCK_DGRAM) AF_INET: IPv4地址族 SOCK_DGRAM: UDP数据报类型 2. 地址绑定# 服务端必须绑定，客户端可选server_socket.bind((IP地址, 端口号)) 3. 数据收发# 接收数据（返回数据和来源地址）data, addr = socket.recvfrom(缓冲区大小)# 发送数据到指定地址socket.sendto(字节数据, (目标IP, 目标端口)) 4. 编码转换# 发送：字符串 → 字节send_msg.encode(utf8)# 接收：字节 → 字符串msg.decode(utf8) 五、注意事项 UDP是无连接的 每次发送都要指定目标地址 不保证数据顺序和可靠性 地址和端口 服务端需要固定端口 客户端端口通常由系统分配 数据大小 UDP数据包不宜过大（通常1500字节） 避免IP分片，提高传输效率 阻塞问题 recvfrom()是阻塞调用 程序会等待直到收到数据 多客户端处理 UDP服务端可以同时处理多个客户端 通过addr区分不同客户端 六、常见问题Q1: 为什么客户端不需要bind？A: 客户端第一次调用sendto()时，系统会自动分配一个可用端口。 Q2: 如果服务器没启动，客户端会怎样？A: 客户端发送的数据会丢失，recvfrom()会一直等待（阻塞）。 Q3: 如何测试本机通信？A: 服务端绑定127.0.0.1，客户端连接127.0.0.1。 Q4: 如何让其他电脑连接？A: 服务端绑定0.0.0.0或局域网IP 关闭防火墙或开放对应端口 客户端使用服务器实际IP地址 七、完整的UDP还需要 异常处理：添加try-except处理网络错误 超时设置：使用settimeout()避免永久阻塞 多线程：同时处理多个客户端请求 数据验证：添加简单的协议头验证数据完整性 八、总结​ UDP编程的核心模式： 服务端：创建→绑定→循环收发→关闭 客户端：创建→循环收发→关闭 这种简单的请求-响应模式是UDP编程的基础，理解了这种模式后，可以在此基础上构建更复杂的UDP应用。 注：实际使用时，请确保服务端和客户端的IP地址和端口号配置正确，防火墙已开放相应端口。"},{"title":"如何用hexo搭建个人博客","path":"/2026/01/25/","content":"Hexo 博客搭建与配置指南📖 简介Hexo 是一个快速、简洁且高效的静态博客框架。它使用 Markdown解析文章，在几秒内即可生成静态网页。本指南将帮助您快速搭建并配置一个 Hexo 博客。 🚀 快速开始环境准备 安装 Node.js 版本要求：Node.js 14.0 或以上版本 下载地址：Node.js 官网 安装 Git 下载地址：Git 官网 安装 Hexo打开终端（命令提示符）并执行： npm install -g hexo-cli 初始化博客hexo init my-blogcd my-blognpm install 本地预览hexo clean# 生成：hexo g# 预览： （浏览器访问 `http://localhost:4000` 查看效果）hexo s# 部署：hexo d ⚙️ 基本配置配置文件博客的主要配置文件为 _config.yml，位于博客根目录下。 常用配置项# 网站信息title: 我的博客 # 网站标题subtitle: # 网站副标题description: # 网站描述keywords: # 网站关键词author: 作者名 # 作者名称language: zh-CN # 语言timezone: # 时区# URL 设置url: http://yoursite.com # 网站地址root: / # 网站根目录permalink: :year/:month/:day/:title/ # 文章永久链接格式# 目录设置source_dir: source # 资源文件夹public_dir: public # 静态文件生成目录# 写作设置new_post_name: :title.md # 新文章文件名格式default_layout: post # 默认布局 🎨 主题安装与配置安装主题以我所使用的stellar 主题为例： cd my-bloggit clone https://github.com/stellar-theme/hexo-theme-syellar themes/stellar 启用主题修改 _config.yml： theme: stellar 主题配置主题有自己的配置文件 themes/stellar/_config.yml，可进行个性化设置。 📝 写作与发布创建新文章hexo new 文章标题 文章文件位于 source/_posts/文章标题.md 文章 Front-matter---title: 文章标题date: 2024-05-20 10:00:00tags: [标签1, 标签2]categories: 分类名--- 常用命令 hexo new [layout] title - 新建文章 hexo clean - 清除缓存 hexo generate 或 hexo g - 生成静态文件 hexo server 或 hexo s - 启动本地服务器 hexo deploy 或 hexo d - 部署到远程仓库 🌐 部署到 GitHub Pages准备工作 创建 GitHub 仓库，命名为 用户名.github.io 安装部署插件： npm install hexo-deployer-git --save 配置部署修改 _config.yml： deploy: type: git repo: https://github.com/用户名/用户名.github.io.git branch: main 部署命令hexo cleanhexo generatehexo deploy 🔧 常用插件# RSS 订阅npm install hexo-generator-feed --save# 站点地图npm install hexo-generator-sitemap --save# 文章搜索npm install hexo-generator-searchdb --save# 文章字数统计npm install hexo-wordcount --save 💡 实用技巧自定义页面hexo new page about 草稿功能hexo new draft 草稿标题hexo publish 草稿标题 图片引用 将图片放入 source/images/ 目录 在文章中引用： ![图片描述](/images/图片文件名.jpg) 🛠️ 故障排除常见问题 部署失败 检查 Git 配置 确认仓库地址正确 检查网络连接 页面无法加载 运行 hexo clean 重新生成和启动服务器 主题不生效 确认主题文件夹名称正确 检查 _config.yml 中 theme 配置 📚 学习资源 Hexo 官方文档 Hexo GitHub Next 主题文档 提示：配置时建议备份原配置文件，每次只修改少量配置并测试效果。"},{"title":"关于我 | 黄逸飞的个人小站","path":"/about/index.html","content":"👋 关于我大家好，我是黄逸飞，目前就读于中国科学技术大学本科人工智能专业。很荣幸能和你在这里相遇。中科大严谨的学术氛围与自由的探索环境，让我在求知的道路上持续成长，也让我养成了对新鲜事物保持好奇、对热爱之事全力以赴的性格。 💻 我想分享的事 编程：无需多言，发际线就是最好的见证。我会在这里梳理我的学习路径，既是复盘，也希望能给同路的你一点参考。 阅读：这是我逃离喧嚣的秘密基地。无论是计算机领域的专业书籍，还是文学、历史类读物，我都愿意静下心来慢慢品读。阅读不仅能补充知识，更能拓宽视野，让我在快节奏的生活里守住一份沉稳。 游戏：AI与游戏的结合（AI x GAME）是我一直感兴趣的方向，未来也会持续探索这个领域的未知可能。 📌 小站的意义这个博客是我记录生活、分享思考的自留地，后续会不定期更新这些内容： 编程学习中的踩坑笔记、技术总结； 阅读后的感悟与书单推荐； 游戏体验、攻略分享； 偶尔的生活碎碎念。 如果你也对这些话题感兴趣，欢迎常来逛逛、留言交流～愿我们都能在热爱的领域里闪闪发光，也能在平凡的日子里收获属于自己的小确幸！ ✨ 感谢相遇，期待成为朋友！"}]