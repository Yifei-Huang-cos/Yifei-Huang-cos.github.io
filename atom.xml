<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黄逸飞的个人博客</title>
  
  
  <link href="https://yifei-huang-cos.github.io/atom.xml" rel="self"/>
  
  <link href="https://yifei-huang-cos.github.io/"/>
  <updated>2026-02-01T08:52:43.955Z</updated>
  <id>https://yifei-huang-cos.github.io/</id>
  
  <author>
    <name>黄逸飞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>提示词工程初步（一）</title>
    <link href="https://yifei-huang-cos.github.io/posts/f57bf148/"/>
    <id>https://yifei-huang-cos.github.io/posts/f57bf148/</id>
    <published>2026-02-01T07:40:30.000Z</published>
    <updated>2026-02-01T08:52:43.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="提示词工程初步（一）"><a href="#提示词工程初步（一）" class="headerlink" title="提示词工程初步（一）"></a>提示词工程初步（一）</h1><p>部署好大模型之后，我们可以用其做一些简单的问答，但如何让回答更接近我们想要的方式，这就需要用到提示词（Prompt）与提示词工程（Prompt Engineering）。通过合理设计、组织提示词，可以显著提升大模型输出的准确性、结构化程度与业务贴合度。本文基于 LangChain 框架，从基础模板到少样本学习，逐步介绍提示词工程的入门实践。</p><h2 id="一、最简单的提示词模板：PromptTemplate"><a href="#一、最简单的提示词模板：PromptTemplate" class="headerlink" title="一、最简单的提示词模板：PromptTemplate"></a>一、最简单的提示词模板：PromptTemplate</h2><h3 id="1-核心意义"><a href="#1-核心意义" class="headerlink" title="1. 核心意义"></a>1. 核心意义</h3><ul><li>实现<strong>固定句式与动态变量分离</strong>，避免重复手写相似提示词，提升代码复用性与可维护性。</li><li>统一输入格式，降低因提示词写法随意导致的模型输出不稳定问题。</li><li>配合 LangChain 的链（Chain）机制，将「模板填充 + 模型调用」封装为一步调用，简化业务代码。</li></ul><h3 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> PromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain_demo.my_llm <span class="keyword">import</span> llm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义带变量的模板</span></span><br><span class="line"></span><br><span class="line">prompt_template = PromptTemplate.from_template(<span class="string">&quot;帮我生成一个简短的，关于&#123;topic&#125;的报幕词。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独渲染模板（不调用模型，用于调试）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># res = prompt_template.invoke(&#123;&quot;topic&quot;: &quot;相声&quot;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(res)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建链：模板 → 大模型</span></span><br><span class="line"></span><br><span class="line">chain = prompt_template | llm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传入变量执行并获取结果</span></span><br><span class="line"></span><br><span class="line">resp = chain.invoke(&#123;<span class="string">&#x27;topic&#x27;</span>: <span class="string">&quot;相声&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(resp)</span><br></pre></td></tr></table></figure><h3 id="3-代码说明"><a href="#3-代码说明" class="headerlink" title="3. 代码说明"></a>3. 代码说明</h3><ul><li><code>PromptTemplate.from_template</code>：通过字符串快速创建模板，<code>&#123;变量名&#125;</code> 为动态填充位置。</li><li><code>invoke</code> 方法用于传入参数并渲染完整提示文本。</li><li>使用管道符 <code>|</code> 串联模板与模型，是 LangChain 推荐的简洁链式写法。</li><li>适用于零样本、结构简单、仅需少量变量替换的常规生成场景。</li></ul><hr><h2 id="二、ICL-技术：上下文少样本学习（In-Context-Learning）"><a href="#二、ICL-技术：上下文少样本学习（In-Context-Learning）" class="headerlink" title="二、ICL 技术：上下文少样本学习（In-Context Learning）"></a>二、ICL 技术：上下文少样本学习（In-Context Learning）</h2><h3 id="1-概念与作用"><a href="#1-概念与作用" class="headerlink" title="1. 概念与作用"></a>1. 概念与作用</h3><p>ICL 即<strong>上下文内学习</strong>，也常被称作少样本学习（Few-Shot Learning）。核心思路是：</p><ul><li>在提示词中加入若干高质量的「问题 - 答案」示例。</li><li>让模型从示例中学习<strong>推理逻辑、输出格式、回答风格</strong>。</li><li>无需微调模型，即可显著提升复杂推理、结构化输出的效果。</li><li>适合多跳推理、格式严格约束、领域特定话术规范等零样本难以满足的场景。</li></ul><p>在 LangChain 中，通过 <code>FewShotPromptTemplate</code> 实现标准化少样本提示管理。</p><h3 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> PromptTemplate, FewShotPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain_demo.my_llm <span class="keyword">import</span> llm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤一：提供示例</span></span><br><span class="line"></span><br><span class="line">examples = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;question&quot;</span>: <span class="string">&quot;穆罕默德·阿里和艾伦·图灵谁活得更久？&quot;</span>,</span><br><span class="line">        <span class="string">&quot;answer&quot;</span>: <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">是否需要后续问题：是。</span></span><br><span class="line"><span class="string">后续问题：穆罕默德·阿里去世时多大？</span></span><br><span class="line"><span class="string">中间答案：穆罕默德·阿里去世时74岁。</span></span><br><span class="line"><span class="string">后续问题：艾伦·图灵去世时多大？</span></span><br><span class="line"><span class="string">中间答案：艾伦·图灵去世时41岁。</span></span><br><span class="line"><span class="string">所以最终答案是：穆罕默德·阿里</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;question&quot;</span>: <span class="string">&quot;乔治·华盛顿的外祖父是谁？&quot;</span>,</span><br><span class="line">        <span class="string">&quot;answer&quot;</span>: <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">是否需要后续问题：是。</span></span><br><span class="line"><span class="string">后续问题：乔治·华盛顿的母亲是谁？</span></span><br><span class="line"><span class="string">中间答案：乔治·华盛顿的母亲是玛丽·鲍尔·华盛顿。</span></span><br><span class="line"><span class="string">后续问题：玛丽·鲍尔·华盛顿的父亲是谁？</span></span><br><span class="line"><span class="string">中间答案：玛丽·鲍尔·华盛顿的父亲是约瑟夫·鲍尔。</span></span><br><span class="line"><span class="string">所以最终答案是：约瑟夫·鲍尔</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;question&quot;</span>: <span class="string">&quot;《大白鲨》和《007：大战皇家赌场》的导演是否来自同一个国家？&quot;</span>,</span><br><span class="line">        <span class="string">&quot;answer&quot;</span>: <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">是否需要后续问题：是。</span></span><br><span class="line"><span class="string">后续问题：《大白鲨》的导演是谁？</span></span><br><span class="line"><span class="string">中间答案：《大白鲨》的导演是史蒂文·斯皮尔伯格。</span></span><br><span class="line"><span class="string">后续问题：史蒂文·斯皮尔伯格来自哪里？</span></span><br><span class="line"><span class="string">中间答案：美国。</span></span><br><span class="line"><span class="string">后续问题：《007：大战皇家赌场》的导演是谁？</span></span><br><span class="line"><span class="string">中间答案：《007：大战皇家赌场》的导演是马丁·坎贝尔。</span></span><br><span class="line"><span class="string">后续问题：马丁·坎贝尔来自哪里？</span></span><br><span class="line"><span class="string">中间答案：新西兰。</span></span><br><span class="line"><span class="string">所以最终答案是：否</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二：定义单个示例的渲染模板</span></span><br><span class="line"></span><br><span class="line">base_prompt_template = PromptTemplate.from_template(<span class="string">&#x27;问题:&#123;question&#125;\n&#123;answer&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤三：创建少样本总模板</span></span><br><span class="line"></span><br><span class="line">final_template = FewShotPromptTemplate(</span><br><span class="line">    examples=examples,                 <span class="comment"># 示例列表</span></span><br><span class="line">    example_prompt=base_prompt_template,  <span class="comment"># 单条示例格式</span></span><br><span class="line">    suffix=<span class="string">&quot;问题:&#123;input&#125;&quot;</span>,             <span class="comment"># 真实问题拼接在最后</span></span><br><span class="line">    input_variables=[<span class="string">&#x27;input&#x27;</span>]          <span class="comment"># 输入变量名</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤四：构建链并调用</span></span><br><span class="line"></span><br><span class="line">chain = final_template | llm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试不同问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># resp = chain.invoke(&#123;&#x27;input&#x27;: &quot;巴伦特朗普的父亲是谁&quot;&#125;)</span></span><br><span class="line"></span><br><span class="line">resp = chain.invoke(&#123;<span class="string">&#x27;input&#x27;</span>: <span class="string">&quot;中国古代历史上唐朝和宋朝哪个朝代延续时间更长&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(resp）</span><br></pre></td></tr></table></figure><p>)</p><h3 id="3-关键参数与使用要点"><a href="#3-关键参数与使用要点" class="headerlink" title="3. 关键参数与使用要点"></a>3. 关键参数与使用要点</h3><ul><li><code>examples</code>：示例数组，每条为 <code>question</code>&#x2F;<code>answer</code> 结构，内容、格式、逻辑必须统一。</li><li><code>example_prompt</code>：控制每一条示例如何渲染成文本，保证所有示例格式一致。</li><li><code>suffix</code>：所有示例之后追加的真实用户问题，模型会参照前面示例的范式回答。</li><li><code>input_variables</code>：声明 suffix 中用到的变量，与模板占位符对应。</li><li>示例数量建议 3～5 条为宜，过少学习效果差，过多易超出上下文窗口或引入噪声。</li></ul><hr><p>好的，这是为您续写的<strong>「三、进阶：聊天场景中使用 ICL（FewShotChatMessagePromptTemplate）」</strong> 部分的完整内容，已根据您提供的实际运行结果进行了补充和润色：</p><hr><h2 id="三、进阶：聊天场景中使用-ICL（FewShotChatMessagePromptTemplate）"><a href="#三、进阶：聊天场景中使用-ICL（FewShotChatMessagePromptTemplate）" class="headerlink" title="三、进阶：聊天场景中使用 ICL（FewShotChatMessagePromptTemplate）"></a>三、进阶：聊天场景中使用 ICL（FewShotChatMessagePromptTemplate）</h2><p>前面介绍的是「文本格式」的提示词 ICL，而在实际的大模型应用中，更多是<strong>聊天场景</strong>（多轮对话、区分用户&#x2F;AI 角色），此时需要使用 LangChain 专为聊天场景设计的 <code>FewShotChatMessagePromptTemplate</code>，它能更好地贴合聊天模型的消息格式（区分 Human&#x2F;Ai&#x2F;System 角色），提升对话场景下的 ICL 效果。</p><h3 id="1-核心概念说明"><a href="#1-核心概念说明" class="headerlink" title="1. 核心概念说明"></a>1. 核心概念说明</h3><ul><li><strong>聊天场景的提示词核心是「消息列表」</strong>，每条消息都有明确的「角色」（human&#x2F;ai&#x2F;system）。</li><li><code>FewShotChatMessagePromptTemplate</code>：专门用于在聊天消息列表中嵌入 ICL 示例，保持示例的角色格式与真实对话一致。</li><li><code>MessagesPlaceholder</code>：消息占位符，用于动态填充后续的真实对话消息（支持多轮对话扩展）。</li><li><code>ChatPromptTemplate</code>：聊天场景的提示词模板，与普通 <code>PromptTemplate</code> 的区别是基于「消息角色」构建。</li></ul><h3 id="2-代码实现-2"><a href="#2-代码实现-2" class="headerlink" title="2. 代码实现"></a>2. 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> HumanMessage</span><br><span class="line"><span class="keyword">from</span> langchain_core.output_parsers <span class="keyword">import</span> StrOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> MessagesPlaceholder, FewShotChatMessagePromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain_demo.my_llm <span class="keyword">import</span> llm</span><br><span class="line"><span class="keyword">from</span> langchain_core.prompts <span class="keyword">import</span> ChatPromptTemplate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤一：准备聊天场景的 ICL 示例（键值对格式，对应后续单条消息模板的变量）</span></span><br><span class="line">examples = [</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;2 ？ 3 = 5&quot;</span>,<span class="string">&quot;output&quot;</span>: <span class="string">&quot;5&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;input&quot;</span>: <span class="string">&quot;3 ？ 4 = 7&quot;</span>,<span class="string">&quot;output&quot;</span>: <span class="string">&quot;7&quot;</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤二：定义单个示例的聊天消息模板（区分 Human/Ai 角色，对应示例的 input/output）</span></span><br><span class="line">base_prompt = ChatPromptTemplate.from_messages(</span><br><span class="line">    [</span><br><span class="line">        <span class="comment"># 每条示例中，用户输入（human 角色）对应 input 变量</span></span><br><span class="line">        (<span class="string">&#x27;human&#x27;</span>, <span class="string">&#x27;&#123;input&#125;&#x27;</span>),</span><br><span class="line">        <span class="comment"># 每条示例中，AI 回复（ai 角色）对应 output 变量</span></span><br><span class="line">        (<span class="string">&#x27;ai&#x27;</span>, <span class="string">&#x27;&#123;output&#125;&#x27;</span>),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤三：创建聊天场景的少样本提示词模板（整合所有示例）</span></span><br><span class="line">few_shot_prompt = FewShotChatMessagePromptTemplate(</span><br><span class="line">    examples=examples,          <span class="comment"># 传入聊天场景的示例列表</span></span><br><span class="line">    example_prompt=base_prompt, <span class="comment"># 传入单条示例的聊天消息模板</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤四：构建完整的聊天提示词模板（包含系统消息、ICL 示例、真实消息占位符）</span></span><br><span class="line">final_template = ChatPromptTemplate.from_messages([</span><br><span class="line">    <span class="comment"># 系统消息：定义 AI 的角色和行为准则</span></span><br><span class="line">    (<span class="string">&quot;system&quot;</span>, <span class="string">&quot;你是一个AI助手！&quot;</span>),</span><br><span class="line">    <span class="comment"># 嵌入 ICL 少样本示例（会自动按 base_prompt 的格式渲染所有示例）</span></span><br><span class="line">    few_shot_prompt,</span><br><span class="line">    <span class="comment"># 消息占位符：用于动态接收真实的用户对话消息（支持多轮消息传入）</span></span><br><span class="line">    MessagesPlaceholder(<span class="string">&quot;msgs&quot;</span>)</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤五：构建执行链</span></span><br><span class="line">chain = final_template | llm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 步骤六：传入真实用户消息，调用执行链</span></span><br><span class="line">resp = chain.invoke(&#123;<span class="string">&quot;msgs&quot;</span>: [HumanMessage(content=<span class="string">&quot;2？9结果是多少&quot;</span>)]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(resp)</span><br></pre></td></tr></table></figure><h3 id="3-代码关键解析"><a href="#3-代码关键解析" class="headerlink" title="3. 代码关键解析"></a>3. 代码关键解析</h3><ol><li><code>ChatPromptTemplate.from_messages()</code>：接收消息列表构建聊天模板，每条消息是 <code>(角色类型， 消息内容)</code> 元组，核心角色包括 <code>system</code>（定义AI行为）、<code>human</code>（用户输入）、<code>ai</code>（AI回复）。</li><li><code>FewShotChatMessagePromptTemplate</code>：聊天场景专属ICL工具，将示例列表按 <code>example_prompt</code> 定义的「Human→Ai」格式渲染，形成完整示例对话链。</li><li><code>MessagesPlaceholder(&quot;msgs&quot;)</code>：动态消息容器，调用时可传入单个&#x2F;多个 <code>HumanMessage</code>&#x2F;<code>AIMessage</code>，支持多轮对话扩展，无需重构模板。</li><li>示例中的 <code>input</code> 是用户提问格式，<code>output</code> 是对应标准答案，模型会从示例中学习隐藏规律（此例中是「数字相加」）。</li></ol><h3 id="4-实际运行结果"><a href="#4-实际运行结果" class="headerlink" title="4. 实际运行结果"></a>4. 实际运行结果</h3><h4 id="运行命令输出"><a href="#运行命令输出" class="headerlink" title="运行命令输出"></a>运行命令输出</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;D:\my project\new_ai_model_env\.venv\Scripts\python.exe&quot;</span> <span class="string">&quot;D:\my project\LangchainProject\langchain_demo\提示词模板-4.py&quot;</span> </span><br><span class="line">D:\my project\new_ai_model_env\.venv\Lib\site<span class="literal">-packages</span>\langchain_core\_api\deprecation.py:<span class="number">26</span>: UserWarning: Core Pydantic V1 functionality isn<span class="string">&#x27;t compatible with Python 3.14 or greater.</span></span><br><span class="line"><span class="string">  from pydantic.v1.fields import FieldInfo as FieldInfoV1</span></span><br><span class="line"><span class="string">content=&#x27;</span>对于 <span class="number">2</span> ？ <span class="number">9</span>，根据前面的例子，我观察到<span class="string">&quot;？&quot;</span>操作似乎是将两个数字相加。</span><br><span class="line"><span class="number">2</span> ？ <span class="number">3</span> = <span class="number">5</span> (即 <span class="number">2</span> + <span class="number">3</span> = <span class="number">5</span>)</span><br><span class="line"><span class="number">3</span> ？ <span class="number">4</span> = <span class="number">7</span> (即 <span class="number">3</span> + <span class="number">4</span> = <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">按照这个规律，<span class="number">2</span> ？ <span class="number">9</span> 的结果应该是:</span><br><span class="line"><span class="number">2</span> + <span class="number">9</span> = <span class="number">11</span></span><br><span class="line"></span><br><span class="line">所以，<span class="number">2</span> ？ <span class="number">9</span> = <span class="number">11</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">additional_kwargs=&#123;&#x27;</span>refusal<span class="string">&#x27;: None&#125;</span></span><br><span class="line"><span class="string">response_metadata=&#123;&#x27;</span>token_usage<span class="string">&#x27;: &#123;&#x27;</span>completion_tokens<span class="string">&#x27;: 144, &#x27;</span>prompt_tokens<span class="string">&#x27;: 84, &#x27;</span>total_tokens<span class="string">&#x27;: 228, &#x27;</span>completion_tokens_details<span class="string">&#x27;: &#123;&#x27;</span>accepted_prediction_tokens<span class="string">&#x27;: None, &#x27;</span>audio_tokens<span class="string">&#x27;: 0, &#x27;</span>reasoning_tokens<span class="string">&#x27;: 0, &#x27;</span>rejected_prediction_tokens<span class="string">&#x27;: None, &#x27;</span>text_tokens<span class="string">&#x27;: 0&#125;, &#x27;</span>prompt_tokens_details<span class="string">&#x27;: &#123;&#x27;</span>audio_tokens<span class="string">&#x27;: 0, &#x27;</span>cached_tokens<span class="string">&#x27;: 0, &#x27;</span>text_tokens<span class="string">&#x27;: 0, &#x27;</span>image_tokens<span class="string">&#x27;: 0&#125;, &#x27;</span>input_tokens<span class="string">&#x27;: 0, &#x27;</span>output_tokens<span class="string">&#x27;: 0, &#x27;</span>input_tokens_details<span class="string">&#x27;: None, &#x27;</span>claude_cache_creation_5_m_tokens<span class="string">&#x27;: 0, &#x27;</span>claude_cache_creation_1_h_tokens<span class="string">&#x27;: 0&#125;, &#x27;</span>model_provider<span class="string">&#x27;: &#x27;</span>openai<span class="string">&#x27;, &#x27;</span>model_name<span class="string">&#x27;: &#x27;</span>claude<span class="literal">-3-7-sonnet-20250219</span><span class="string">&#x27;, &#x27;</span>system_fingerprint<span class="string">&#x27;: None, &#x27;</span>id<span class="string">&#x27;: &#x27;</span>msg_bdrk_013v2a4K1AkZZUY4hnLbh2Nk<span class="string">&#x27;, &#x27;</span>finish_reason<span class="string">&#x27;: &#x27;</span>stop<span class="string">&#x27;, &#x27;</span>logprobs<span class="string">&#x27;: None&#125;</span></span><br><span class="line"><span class="string">id=&#x27;</span>lc_run<span class="literal">--019c185a-cca9-7581-a0c3-77edef4787db-0</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">tool_calls=[]</span></span><br><span class="line"><span class="string">invalid_tool_calls=[]</span></span><br><span class="line"><span class="string">usage_metadata=&#123;&#x27;</span>input_tokens<span class="string">&#x27;: 84, &#x27;</span>output_tokens<span class="string">&#x27;: 144, &#x27;</span>total_tokens<span class="string">&#x27;: 228, &#x27;</span>input_token_details<span class="string">&#x27;: &#123;&#x27;</span>audio<span class="string">&#x27;: 0, &#x27;</span>cache_read<span class="string">&#x27;: 0&#125;, &#x27;</span>output_token_details<span class="string">&#x27;: &#123;&#x27;</span>audio<span class="string">&#x27;: 0, &#x27;</span>reasoning<span class="string">&#x27;: 0&#125;&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">进程已结束，退出代码为 0</span></span><br></pre></td></tr></table></figure><h4 id="结果解读"><a href="#结果解读" class="headerlink" title="结果解读"></a>结果解读</h4><ul><li><p><strong>忽略弃用警告</strong>：开头的 <code>Pydantic V1</code> 弃用警告是 LangChain 框架的版本兼容性提示，<strong>不影响程序功能运行</strong>，可以暂时忽略。</p></li><li><p><strong>ICL 学习成功</strong>：模型成功从两条示例 <code>&#123;2 ？ 3 = 5&#125;</code> 和 <code>&#123;3 ？ 4 = 7&#125;</code> 中，学习到了「<code>？</code> 代表将两个数字相加」的隐藏规律，并正确推导出 <code>2？9</code> 的结果是 <code>11</code>。</p></li><li><p><strong>输出格式说明</strong>：打印的 <code>resp</code> 对象是 LangChain 聊天模型返回的原生 <code>AIMessage</code> 对象，它包含多个属性：</p><ul><li><code>content</code>：核心回复内容，即模型推理出的纯文本答案。</li><li><code>additional_kwargs</code>、<code>response_metadata</code>、<code>usage_metadata</code>：这些是请求的元数据，包含了本次调用的令牌消耗详情、使用的模型信息（Claude 3.7 Sonnet）、请求ID等。</li></ul></li><li><p><strong>优化输出（可选）</strong>：如果您仅需要模型回复的纯文本内容（即 <code>content</code>），可以在执行链末尾添加 <code>StrOutputParser()</code> 解析器：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chain = final_template | llm | StrOutputParser()</span><br></pre></td></tr></table></figure><p>  返回的结果变为</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">如果我们观察前面的例子：</span><br><span class="line"><span class="number">2</span> ？ <span class="number">3</span> = <span class="number">5</span></span><br><span class="line"><span class="number">3</span> ？ <span class="number">4</span> = <span class="number">7</span></span><br><span class="line"></span><br><span class="line">我可以推断出这个<span class="string">&quot;？&quot;</span>操作是将两个数字相加。所以：</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> ？ <span class="number">9</span> = <span class="number">2</span> + <span class="number">9</span> = <span class="number">11</span></span><br><span class="line"></span><br><span class="line">答案是<span class="number">11</span>。</span><br></pre></td></tr></table></figure><p>  通义千问等主流聊天模型的原生交互格式（System&#x2F;Human&#x2F;Assistant 消息流），能有效提升指令遵循和回复的准确性。</p></li></ul><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;提示词工程初步（一）&quot;&gt;&lt;a href=&quot;#提示词工程初步（一）&quot; class=&quot;headerlink&quot; title=&quot;提示词工程初步（一）&quot;&gt;&lt;/a&gt;提示词工程初步（一）&lt;/h1&gt;&lt;p&gt;部署好大模型之后，我们可以用其做一些简单的问答，但如何让回答更接近我们想要的</summary>
      
    
    
    
    <category term="编程" scheme="https://yifei-huang-cos.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>大模型的私有化部署（一）</title>
    <link href="https://yifei-huang-cos.github.io/posts/fa00b5a1/"/>
    <id>https://yifei-huang-cos.github.io/posts/fa00b5a1/</id>
    <published>2026-01-31T11:00:07.000Z</published>
    <updated>2026-01-31T11:33:07.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="大模型的私有化部署（一）"><a href="#大模型的私有化部署（一）" class="headerlink" title="大模型的私有化部署（一）"></a>大模型的私有化部署（一）</h1><h2 id="一、部署前期准备"><a href="#一、部署前期准备" class="headerlink" title="一、部署前期准备"></a>一、部署前期准备</h2><h3 id="1-1-服务器租赁（核心前提）"><a href="#1-1-服务器租赁（核心前提）" class="headerlink" title="1.1 服务器租赁（核心前提）"></a>1.1 服务器租赁（核心前提）</h3><p>由于个人电脑的算力、显存等硬件条件受限，<strong>不推荐本地部署大模型</strong>，优先选择云服务器提供的GPU租赁服务，主流平台可选择阿里云、AutoDL等。</p><h4 id="选择建议（按场景划分）"><a href="#选择建议（按场景划分）" class="headerlink" title="选择建议（按场景划分）"></a>选择建议（按场景划分）</h4><ul><li><strong>测试&#x2F;学习用途</strong>：首推 <strong>AutoDL</strong><ul><li>优势：价格低廉，按小时计费，预装完整深度学习环境（无需手动配置Python、Torch等），开箱即用，对新手友好。</li></ul></li><li><strong>生产&#x2F;长期运行用途</strong>：优先选择 <strong>阿里云</strong>、<strong>腾讯云</strong><ul><li>优势：稳定性更强，服务保障更完善，支持弹性扩容，适合企业级落地场景。</li></ul></li></ul><h3 id="1-2-服务器实例创建与信息留存"><a href="#1-2-服务器实例创建与信息留存" class="headerlink" title="1.2 服务器实例创建与信息留存"></a>1.2 服务器实例创建与信息留存</h3><ol><li>配置选择：推荐显卡型号 RTX 3090&#x2F;4090 或 A100，<strong>显存≥16GB</strong>（保障8B模型正常运行），按需选择CPU与硬盘容量（建议硬盘≥50GB，用于存储模型文件）。</li><li>实例创建完成后，<strong>务必妥善记录以下连接信息</strong>（丢失后难以找回）：<ul><li><strong>SSH 地址</strong>（格式示例：<code>123.456.78.90:12345</code>）</li><li><strong>登录密码</strong>（或密钥文件，若选择密钥登录）</li></ul></li></ol><h3 id="1-3-PyCharm-Pro-远程SSH连接（高效开发必备）"><a href="#1-3-PyCharm-Pro-远程SSH连接（高效开发必备）" class="headerlink" title="1.3 PyCharm Pro 远程SSH连接（高效开发必备）"></a>1.3 PyCharm Pro 远程SSH连接（高效开发必备）</h3><p>为了简化后续的代码编写、文件管理与命令执行，推荐使用PyCharm专业版的远程开发功能，直接连接云服务器进行操作。</p><h4 id="详细操作步骤"><a href="#详细操作步骤" class="headerlink" title="详细操作步骤"></a>详细操作步骤</h4><ol><li>打开 PyCharm Professional，创建或打开你的项目。</li><li>进入路径：<code>File</code> → <code>Settings</code> → <code>Project: [你的项目名]</code> → <code>Python Interpreter</code>。</li><li>点击解释器右侧的 <strong><code>Add Interpreter</code></strong> 按钮，选择 **<code>On SSH...</code>**（远程SSH解释器）。</li><li>在弹出的配置窗口中，填写服务器信息：<ul><li><code>Host</code>：服务器公网IP地址（无需带端口）</li><li><code>Port</code>：SSH端口号（默认22，AutoDL等平台为随机分配端口，需对应记录的信息）</li><li><code>Username</code>：默认通常为 <code>root</code></li><li><code>Password</code>：填写记录的服务器登录密码</li></ul></li><li>后续步骤一路点击 <code>Next</code>，默认选择服务器上的Python解释器即可，完成配置。</li><li>验证：配置成功后，PyCharm的终端（Terminal）执行命令会直接在远程服务器上运行，文件操作也会同步到服务器对应目录。</li></ol><h2 id="二、模型下载与环境配置"><a href="#二、模型下载与环境配置" class="headerlink" title="二、模型下载与环境配置"></a>二、模型下载与环境配置</h2><h3 id="2-1-大模型下载（以Qwen3-8B-Instruct为例）"><a href="#2-1-大模型下载（以Qwen3-8B-Instruct为例）" class="headerlink" title="2.1 大模型下载（以Qwen3-8B-Instruct为例）"></a>2.1 大模型下载（以Qwen3-8B-Instruct为例）</h3><p>我们选择从<strong>ModelScope（魔搭社区）</strong>下载字节跳动开源的Qwen3-8B-Instruct模型，该模型性能均衡，适合新手入门私有化部署。</p><h4 id="步骤1：找到模型官方页面"><a href="#步骤1：找到模型官方页面" class="headerlink" title="步骤1：找到模型官方页面"></a>步骤1：找到模型官方页面</h4><p><a href="https://www.modelscope.cn/models/qwen/Qwen3-8B-Instruct/summary">https://www.modelscope.cn/models/qwen/Qwen3-8B-Instruct/summary</a></p><h4 id="步骤2：Python-SDK-下载（推荐，自动处理依赖与文件整合）"><a href="#步骤2：Python-SDK-下载（推荐，自动处理依赖与文件整合）" class="headerlink" title="步骤2：Python SDK 下载（推荐，自动处理依赖与文件整合）"></a>步骤2：Python SDK 下载（推荐，自动处理依赖与文件整合）</h4><ol><li>若未安装ModelScope库，先在PyCharm远程终端执行安装命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install modelscope</span><br></pre></td></tr></table></figure></li><li>创建Python脚本（或直接在终端运行），执行以下下载代码：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> modelscope <span class="keyword">import</span> snapshot_download</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置模型名称与下载目录</span></span><br><span class="line"><span class="comment"># 注意：AutoDL平台大容量数据盘默认路径为 /root/autodl-tmp，优先选择该目录节省系统盘空间</span></span><br><span class="line">model_name = <span class="string">&#x27;Qwen/Qwen3-8B-Instruct&#x27;</span></span><br><span class="line">save_dir = <span class="string">&#x27;/root/autodl-tmp/models&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始下载模型（首次下载约15GB，耗时取决于网络速度）</span></span><br><span class="line">model_dir = snapshot_download(model_name, cache_dir=save_dir)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印模型最终存储路径（后续启动服务需用到，建议复制留存）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;模型下载完成，存储路径：<span class="subst">&#123;model_dir&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-2-安装-vLLM-推理引擎（高速推理核心）"><a href="#2-2-安装-vLLM-推理引擎（高速推理核心）" class="headerlink" title="2.2 安装 vLLM 推理引擎（高速推理核心）"></a>2.2 安装 vLLM 推理引擎（高速推理核心）</h3><p>vLLM 是一款高性能的大模型推理与服务库，相比原生推理框架，具有<strong>显存利用率高、生成速度快、支持高并发</strong>的优势，是私有化部署的首选推理引擎。</p><p>在PyCharm远程终端中执行以下安装命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install vllm</span><br></pre></td></tr></table></figure><h4 id="验证安装成功"><a href="#验证安装成功" class="headerlink" title="验证安装成功"></a>验证安装成功</h4><p>安装完成后，执行以下命令检查是否安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip list | grep vllm</span><br></pre></td></tr></table></figure><p>若终端返回 vllm 对应的版本号，说明安装完成。</p><h2 id="三、启动-OpenAI-兼容-API-服务"><a href="#三、启动-OpenAI-兼容-API-服务" class="headerlink" title="三、启动 OpenAI 兼容 API 服务"></a>三、启动 OpenAI 兼容 API 服务</h2><h3 id="3-1-启动命令（复制即可使用，需修改模型路径）"><a href="#3-1-启动命令（复制即可使用，需修改模型路径）" class="headerlink" title="3.1 启动命令（复制即可使用，需修改模型路径）"></a>3.1 启动命令（复制即可使用，需修改模型路径）</h3><p>在PyCharm远程终端中，执行以下命令启动OpenAI兼容的API服务（命令行换行用 <code>\</code> 分隔，确保完整复制）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">python -m vllm.entrypoints.openai.api_server \</span><br><span class="line">    --model /root/autodl-tmp/models/Qwen/Qwen3-8B-Instruct \</span><br><span class="line">    --served-model-name qwen3-8b \</span><br><span class="line">    --max-model-len 8k \</span><br><span class="line">    --host 0.0.0.0 \</span><br><span class="line">    --port 6006 \</span><br><span class="line">    --dtype bfloat16 \</span><br><span class="line">    --gpu-memory-utilization 0.8 \</span><br><span class="line">    --enable-auto-tool-choice \</span><br><span class="line">    --tool-call-parser hermes</span><br></pre></td></tr></table></figure><h4 id="核心参数说明（必看，方便后续自定义配置）"><a href="#核心参数说明（必看，方便后续自定义配置）" class="headerlink" title="核心参数说明（必看，方便后续自定义配置）"></a>核心参数说明（必看，方便后续自定义配置）</h4><table><thead><tr><th align="left">参数</th><th align="left">作用说明</th></tr></thead><tbody><tr><td align="left"><code>--model</code></td><td align="left"><strong>模型本地绝对路径</strong>（需与下载完成后的实际路径一致，关键！）</td></tr><tr><td align="left"><code>--served-model-name</code></td><td align="left">对外暴露的模型名称，API调用时需指定该名称</td></tr><tr><td align="left"><code>--max-model-len 8k</code></td><td align="left">模型支持的最大上下文长度，Qwen3-8B-Instruct支持最高8k</td></tr><tr><td align="left"><code>--host 0.0.0.0</code></td><td align="left">允许外部设备访问该服务（本地电脑、其他服务器），不可修改为127.0.0.1</td></tr><tr><td align="left"><code>--port 6006</code></td><td align="left">服务端口，可自定义（如8080、9090），需确保端口未被占用且已放行</td></tr><tr><td align="left"><code>--dtype bfloat16</code></td><td align="left">采用bfloat16精度运行，平衡推理速度与模型效果，同时节省大量显存</td></tr><tr><td align="left"><code>--gpu-memory-utilization 0.8</code></td><td align="left">GPU内存利用率上限（80%），可根据显存大小调整（如显存不足可改为0.7）</td></tr></tbody></table><h4 id="启动成功标识"><a href="#启动成功标识" class="headerlink" title="启动成功标识"></a>启动成功标识</h4><p>若终端输出 <code>INFO: Uvicorn running on http://0.0.0.0:6006</code>，说明服务已成功启动，保持终端窗口开启（关闭终端会终止服务）。</p><h3 id="3-2-API-服务测试（验证部署效果）"><a href="#3-2-API-服务测试（验证部署效果）" class="headerlink" title="3.2 API 服务测试（验证部署效果）"></a>3.2 API 服务测试（验证部署效果）</h3><p>服务启动后，通过以下两种测试方式验证是否可正常调用。</p><h4 id="测试1：基础模型列表查询"><a href="#测试1：基础模型列表查询" class="headerlink" title="测试1：基础模型列表查询"></a>测试1：基础模型列表查询</h4><p>在本地电脑终端（或服务器新终端窗口）执行以下 <code>curl</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://&lt;你的服务器IP&gt;:6006/v1/models</span><br></pre></td></tr></table></figure><p><strong>替换 <code>&lt;你的服务器IP&gt;</code> 为实际公网IP</strong>，若返回包含 <code>&quot;id&quot;: &quot;qwen3-8b&quot;</code> 的JSON格式数据，说明服务运行正常。</p><h4 id="测试2：对话功能测试（实际调用模型生成回复）"><a href="#测试2：对话功能测试（实际调用模型生成回复）" class="headerlink" title="测试2：对话功能测试（实际调用模型生成回复）"></a>测试2：对话功能测试（实际调用模型生成回复）</h4><p>在本地电脑终端执行以下 <code>curl</code> 命令，发送对话请求：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl http://&lt;你的服务器IP&gt;:6006/v1/chat/completions \</span><br><span class="line">  -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">  -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;model&quot;: &quot;qwen3-8b&quot;,</span></span><br><span class="line"><span class="string">    &quot;messages&quot;: [</span></span><br><span class="line"><span class="string">      &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;你好，请用一句话介绍你自己。&quot;&#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">  &#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>若返回包含模型回复内容的JSON数据，说明对话功能正常，私有化部署API服务搭建完成。</p><h2 id="四、常见问题与避坑指南"><a href="#四、常见问题与避坑指南" class="headerlink" title="四、常见问题与避坑指南"></a>四、常见问题与避坑指南</h2><ol><li><strong>端口不通，无法访问服务</strong><ul><li><strong>排查步骤</strong>：① 确认服务器安全组&#x2F;防火墙已放行 <code>6006</code> 端口（AutoDL在实例控制台「端口映射」中配置）；② 确认启动命令中 <code>--host</code> 为 <code>0.0.0.0</code>；③ 确认服务器IP填写正确，无端口号输入错误。</li></ul></li><li><strong>显存不足（OOM错误），启动失败</strong><ul><li><strong>解决方案</strong>：① 降低 <code>--gpu-memory-utilization</code> 参数（如改为0.7或0.6）；② 将 <code>--dtype bfloat16</code> 改为 <code>--dtype float16</code>（进一步节省显存，少量损失效果）；③ 租用显存更大的GPU实例（如A100 40GB）。</li></ul></li><li><strong>关闭终端后，服务停止运行</strong><ul><li><strong>解决方案</strong>：① 使用 <code>nohup</code> 命令后台运行（命令前加 <code>nohup</code>，结尾加 <code>&amp;</code>，日志保存至 <code>nohup.out</code>）；② 安装 <code>tmux</code>&#x2F;<code>screen</code> 工具，创建会话保持服务运行（适合长期部署）。</li></ul></li><li><strong>本地代码调用私有模型</strong><ul><li><strong>核心配置</strong>：将OpenAI SDK的 <code>api_base</code> 改为 <code>http://&lt;你的服务器IP&gt;:6006/v1</code>，<code>model</code> 改为 <code>qwen3-8b</code>，即可像调用OpenAI官方API一样使用私有模型。</li></ul></li></ol><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;大模型的私有化部署（一）&quot;&gt;&lt;a href=&quot;#大模型的私有化部署（一）&quot; class=&quot;headerlink&quot; title=&quot;大模型的私有化部署（一）&quot;&gt;&lt;/a&gt;大模型的私有化部署（一）&lt;/h1&gt;&lt;h2 id=&quot;一、部署前期准备&quot;&gt;&lt;a href=&quot;#一、部署前</summary>
      
    
    
    
    <category term="编程" scheme="https://yifei-huang-cos.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>杀戮尖塔设计拆解——世界观篇</title>
    <link href="https://yifei-huang-cos.github.io/posts/de29066e/"/>
    <id>https://yifei-huang-cos.github.io/posts/de29066e/</id>
    <published>2026-01-29T08:00:00.000Z</published>
    <updated>2026-01-29T09:16:07.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《杀戮尖塔》设计拆解——世界观篇"><a href="#《杀戮尖塔》设计拆解——世界观篇" class="headerlink" title="《杀戮尖塔》设计拆解——世界观篇"></a>《杀戮尖塔》设计拆解——世界观篇</h1><blockquote><h6 id="特别鸣谢："><a href="#特别鸣谢：" class="headerlink" title="特别鸣谢："></a>特别鸣谢：</h6><p>​贴吧大佬“奇怪的哔哩”的世界观分析贴，本文的分析基于笔者自己的游玩体验和大佬对细节的解析。有兴趣的小伙伴可以在B站观看视频版：</p><p>​【【万字解析】《杀戮尖塔》铁甲战士背景故事分析】</p><p> <a href="https://www.bilibili.com/video/BV18cFreWE2S/?share_source=copy_web&vd_source=507b3c58ff11ec91bc194db7b0cf2b55">https://www.bilibili.com/video/BV18cFreWE2S/?share_source=copy_web&amp;vd_source=507b3c58ff11ec91bc194db7b0cf2b55</a></p><p>​【还在迷信故障机器人？其实观者早就登神！：【观者】背景故事分析】</p><p><a href="https://www.bilibili.com/video/BV1FcPdexE1N/?share_source=copy_web&vd_source=507b3c58ff11ec91bc194db7b0cf2b55">https://www.bilibili.com/video/BV1FcPdexE1N/?share_source=copy_web&amp;vd_source=507b3c58ff11ec91bc194db7b0cf2b55</a></p><p>​【以凡人之姿狩猎不朽之物：【静默猎手】背景故事分析】</p><p> <a href="https://www.bilibili.com/video/BV13cP1eyEcG/?share_source=copy_web&vd_source=507b3c58ff11ec91bc194db7b0cf2b55">https://www.bilibili.com/video/BV13cP1eyEcG/?share_source=copy_web&amp;vd_source=507b3c58ff11ec91bc194db7b0cf2b55</a></p><p>​【超越所有人工制品的无上至尊：【故障机器人】背景故事分析】</p><p> <a href="https://www.bilibili.com/video/BV1FgN1eaED2/?share_source=copy_web&vd_source=507b3c58ff11ec91bc194db7b0cf2b55">https://www.bilibili.com/video/BV1FgN1eaED2/?share_source=copy_web&amp;vd_source=507b3c58ff11ec91bc194db7b0cf2b55</a></p></blockquote><h2 id="一、核心设计目标：用世界观构建“意义感”"><a href="#一、核心设计目标：用世界观构建“意义感”" class="headerlink" title="一、核心设计目标：用世界观构建“意义感”"></a>一、核心设计目标：用世界观构建“意义感”</h2><p>​一个优秀的游戏往往精心构建一套完整且逻辑自洽的世界观，它不仅为游戏提供了可信的叙事根基与行动动机，更在无形中引导玩家自然地沉浸于虚拟情境，深刻强化角色代入感与情感联结，最终使游戏体验超越单纯的玩法交互，成为一段富有意义、令人信服且回味悠长的沉浸式叙事旅程。</p><h3 id="1-1-为什么需要有一个世界观"><a href="#1-1-为什么需要有一个世界观" class="headerlink" title="1.1 为什么需要有一个世界观"></a>1.1 为什么需要有一个世界观</h3><p>​《杀戮尖塔》在设计之初就面临Roguelike品类的固有痛点：重复体验容易疲劳、多职业容易同质化、数值成长缺乏情感支撑、玩家决策缺乏意义感。传统的解决方案往往是增加更多随机内容或调整数值平衡，但《杀戮尖塔》选择了更根本的解法——<strong>将叙事深度嵌入核心系统</strong>。</p><pre class="mermaid">flowchart TD       B{杀戮尖塔解决方案}    B --> D[叙事系统化设计]    D --> E[每次爬塔都是角色个人史诗]    D --> F[每个职业都是完整叙事原型]    D --> G[构筑过程就是角色命运塑造]    D --> H[每次选择都是角色性格体现]</pre><h3 id="1-2-世界观带来了什么？"><a href="#1-2-世界观带来了什么？" class="headerlink" title="1.2 世界观带来了什么？"></a>1.2 世界观带来了什么？</h3><p>在《杀戮尖塔》中，玩家的每一个游戏决策都被赋予了双重意义。例如选择战士职业时，当玩家选择一张“腐化”卡牌时，这不仅是选择了“牺牲防御换取爆发”的游戏策略，更是选择了让角色“向恶魔力量屈服”的叙事路径。这种设计创造了独特的决策循环：</p><p><strong>选择卡牌&#x2F;遗物 → 理解叙事意义 → 增强沉浸体验 → 影响后续选择</strong></p><h2 id="二、世界观系统化设计框架"><a href="#二、世界观系统化设计框架" class="headerlink" title="二、世界观系统化设计框架"></a>二、世界观系统化设计框架</h2><h3 id="2-1-角色设计：叙事作为差异化骨架"><a href="#2-1-角色设计：叙事作为差异化骨架" class="headerlink" title="2.1 角色设计：叙事作为差异化骨架"></a>2.1 角色设计：叙事作为差异化骨架</h3><h4 id="2-1-1-战士：从堕落走向超越的复仇者"><a href="#2-1-1-战士：从堕落走向超越的复仇者" class="headerlink" title="2.1.1 战士：从堕落走向超越的复仇者"></a><strong>2.1.1 战士：从堕落走向超越的复仇者</strong></h4><p>​战士的的核心矛盾在于力量与代价的永恒博弈，是向恶魔低头，还是超越自我？</p><p><strong>力量进化四阶段：</strong></p><ol><li><p><strong>凡人之力阶段</strong>：</p><p>白卡武装、完美打击、旋风斩，效果扎实且朴实无华，展现战士一开始作为一个普通的军人，他所拥有的扎实的战斗素养；</p></li><li><p><strong>恶魔之力阶段</strong>：</p><p>战士向恶魔献祭灵魂，获取更加强大的力量。祭品是战士开始献祭自己（在游戏里具体表现为支付生命值为代价，回能与抽牌）黑暗之拥表现了战士开始拥抱黑暗的一面（给战士强大的过牌能力），腐化代表战士抛弃自己的过往，将灵魂献与恶魔以获得强大的力量（所有技能牌变0费且消耗），恶魔形态更是直接展示战士恶堕成魔的可能性；</p></li><li><p><strong>灵魂之力阶段</strong>：</p><p>重振精神，岿然不动，断魂斩等牌，表现战士对光明与自我的发现，抛弃与恶魔的交易，而是去寻求自我救赎与自我超越的可能；</p></li><li><p><strong>融合之力阶段</strong>：</p><p>通关尖塔后，结局的紫色火焰象征对恶魔之力的最终掌控，不再受恶魔影响，完成了新生与超越</p></li></ol><pre class="mermaid">graph LR    A[凡人之力<br>红色，军事武艺] --> B[恶魔之力<br>红→黑，契约堕落]    B --> C[灵魂之力<br>蓝色，自我觉醒]    C --> D[融合之力<br>紫色，新生超越]        style A fill:#ffcccc    style B fill:#333333,color:#ffffff    style C fill:#ccccff    style D fill:#cc99ff</pre><h4 id="2-1-2-静默猎手：以技艺对抗超凡的智者"><a href="#2-1-2-静默猎手：以技艺对抗超凡的智者" class="headerlink" title="2.1.2 静默猎手：以技艺对抗超凡的智者"></a><strong>2.1.2 静默猎手：以技艺对抗超凡的智者</strong></h4><p>猎手的设计抛出了一个核心命题：<strong>凡人能否凭借智慧与技艺对抗超凡存在？</strong> 这个角色的所有机制都服务于这一叙事主题。</p><p><strong>机制与叙事的精准对应：</strong></p><ul><li><p><strong>丢弃机制</strong>：“专注要害，摒弃杂念”的猎手思维 → 游戏中的过滤牌库策略</p><ul><li>杂技、本能反应等牌，作为抽牌卡，卡面的描述与插画无一不展现猎手的灵敏，在游戏里体现的是超越其他职业的大过牌；而丢弃这一概念表现猎人对于战斗的专注，摒弃杂念，而在游戏中则体现在“本能反应（弃置此牌抽3张）”和“战术大师（弃置此牌回2费）”这两张弃牌体系的核心卡。</li></ul></li><li><p><strong>小刀流</strong>：“高频低伤，技巧至上”的战斗哲学     → 频率乘区的构筑思路</p><ul><li><p>和其余职业的强大设定不同，猎人是部族中的佼佼者，但毕竟只是凡人之躯，为了对抗敌人，猎人需要极致的战斗技巧。刀刃之舞（获得四把0费的小刀）配合能力牌精准（小刀伤害增加）和遗物袖箭（0费攻击牌伤害增加），正是展现了猎人这一特点——</p><p>尽管没有特别的力量（小刀的初始伤害不高），但长期的训练让猎人的准度增加（表现为精准），搭配武器袖箭，也能打出爆炸的伤害。</p></li></ul></li><li><p><strong>毒药系统</strong>：“智慧弥补力量不足”的生存策略     → 层数积累的伤害方式</p><ul><li>毒贼则展示猎手的另一面：缜密的头脑与精密如化学实验般的战术思维，擅长以巧取胜、以智克力。例如“涂毒”（每次攻击附带一点毒）这张能力卡，使毒素般在敌人体内缓慢累积、持续生效。而待到毒至临界时，“催化剂”（毒层数翻至三倍）卡牌的加入，更让毒性如连锁反应般骤然爆发，这正是猎手在实战中精于计算、耐心布局，最终一击制敌的思维体现——她不靠蛮力碾压，而是在最恰当的时机引爆最剧烈的反应。这种战斗风格，既是对“猎人”之名的真正诠释，也是对“智慧胜于力量”这一核心叙事的完美续写。</li></ul></li><li><p><strong>幽魂形态</strong>：“向猎物学习超凡”的成长路径         → 获得无敌防御的能力</p><ul><li>这是猎人最可怕之处，她会从对手那里学到对方最引以为傲的优点。四大形态中也属猎手学会的幽魂形态最为强大和泛用。</li></ul></li></ul><h4 id="2-1-3-故障机器人：文明遗产的继承者"><a href="#2-1-3-故障机器人：文明遗产的继承者" class="headerlink" title="2.1.3 故障机器人：文明遗产的继承者"></a><strong>2.1.3 故障机器人：文明遗产的继承者</strong></h4><p>在杀戮尖塔的世界观里，故障机器人代表了先古之民科技与魔法结合的巅峰成就，其设计围绕“指数成长”和“文明继承”两个核心主题展开。由于笔者对机器人的理解不甚精通，文本也未仔细研究，因此只做简要概述：</p><pre class="mermaid">journey    title 机器人的三阶段成长体验    section 启动期      古代造物苏醒: 5      能力牌延迟收益: 3      “需要耐心布局”: 2    section 成长期      系统权限获取: 5      集中力乘法效应: 4      “开始产生质变”: 4    section 巅峰期      继承文明遗产: 5      无限球/递归循环: 5      “我是天灾”: 5</pre><h4 id="2-1-4-观者：从凡躯到神域的通神者"><a href="#2-1-4-观者：从凡躯到神域的通神者" class="headerlink" title="2.1.4 观者：从凡躯到神域的通神者"></a><strong>2.1.4 观者：从凡躯到神域的通神者</strong></h4><p>观者的设计展现了游戏中最完整的成长阶梯，从凡人的战斗技巧到触及神域的通神能力，每一步都有清晰的叙事支撑。</p><p><strong>力量成长的四个阶梯：</strong></p><ol><li><p><strong>凡人之躯</strong>：</p><p>​疾风连击、粉碎关节、洞见等牌，是观者作为一位战斗者所拥有的基本素质，它们在游戏中也大多表现为白卡；</p></li><li><p><strong>心灵之力</strong>：</p><p>​姿态切换、情绪化为力量。愤怒让观者的输出能力翻倍，平静则给观者提供能量。其实后者有点符合东方的禅修哲学；</p></li><li><p><strong>规则操控</strong>：</p><p>​保留机制、现实批准。观者是4位中最接近所谓“神”的存在，她能够保留力量（在游戏里体现为卡牌），等到合适的时机崽使用；她在游戏中有操纵现实（给新加入的卡升级）和确立基础（所有保留的卡减费）这两张卡，体现了她自己超脱于现实的力量。</p></li><li><p><strong>神域触及</strong>：</p><p>​真言积累、神格形态。神格体系从文本设计上倒是有趣，敬拜、祈祷、五体投地这几张卡积累一定真言后进入神格，象征观者的虔诚，在一步步朝圣中获得神力；而渎神这张卡设计的很有趣，立即进入神格，但下回合会死亡，这展现观者对在高塔中逐渐发现真相，对所谓’‘神“失去信仰。结局里观者睁开紫金色的眼，暗示观者可能依然登神。</p></li></ol><h3 id="2-2-进程设计：三层结构的叙事节奏"><a href="#2-2-进程设计：三层结构的叙事节奏" class="headerlink" title="2.2 进程设计：三层结构的叙事节奏"></a>2.2 进程设计：三层结构的叙事节奏</h3><h4 id="2-2-1-精心编排的三层结构"><a href="#2-2-1-精心编排的三层结构" class="headerlink" title="2.2.1 精心编排的三层结构"></a><strong>2.2.1 精心编排的三层结构</strong></h4><p>《杀戮尖塔》的高塔三层不仅是难度递进，更是<strong>叙事节奏的精心编排</strong>。让难度逐层递进的逻辑更加合理，也更易于玩家接受</p><p><strong>第一层：废墟与奠基</strong></p><ul><li><strong>叙事氛围</strong>：初探遗迹，相对安全，遇到的只有咔咔、毛毛虫，小地精之类的小怪</li><li><strong>设计目标</strong>：教学与构筑奠基</li><li><strong>精英引导</strong>：小红（要求攻击浓度）、三柱（要求AOE能力）</li></ul><p><strong>第二层：城市与压力</strong></p><ul><li><strong>叙事氛围</strong>：深入文明腹地，危险加剧，你将会遇到古文明留下的机器造物，仍在塔内居住的盗贼，奴隶贩子等危险人群</li><li><strong>设计目标</strong>：多维压力测试</li><li><strong>压力来源</strong>：血量压力、状态压力、牌库污染、经济压力</li></ul><p><strong>第三层：时空与检验</strong></p><ul><li><strong>叙事氛围</strong>：规则崩坏，接近核心，你会遇到巨大的倒下的头颅，信仰蛇这一图腾的蛇女，以及各种奇形怪状的怪物</li><li><strong>设计目标</strong>：构筑完整性检验</li><li><strong>BOSS考官</strong>：每个BOSS检验牌组的不同方面</li></ul><h4 id="2-2-2-心脏战：终极叙事高潮"><a href="#2-2-2-心脏战：终极叙事高潮" class="headerlink" title="2.2.2 心脏战：终极叙事高潮"></a><strong>2.2.2 心脏战：终极叙事高潮</strong></h4><p>心脏作为最终BOSS，不仅是难度顶峰，更是<strong>叙事主题的集大成者</strong>。其四项机制各自对应不同的检验维度和叙事隐喻：</p><pre class="mermaid">graph TD    subgraph A[心脏机制设计]        B[律动机制] --> C[强制要求防御浓度<br>隐喻：力量的反噬]        D[坚不可摧] --> E[杜绝速杀可能<br>隐喻：真正的耐力考验]        F[状态污染] --> G[检验牌库纯净度<br>隐喻：混乱中的清醒]        H[高成长] --> I[设置软回合限制<br>隐喻：时间的压力]    end        subgraph J[设计目的]        K[全面验收牌组<br>攻防运转清状态全面达标]    end        A --> J</pre><h3 id="2-3-随机系统：碎片叙事的引导力"><a href="#2-3-随机系统：碎片叙事的引导力" class="headerlink" title="2.3 随机系统：碎片叙事的引导力"></a>2.3 随机系统：碎片叙事的引导力</h3><p>杀戮尖塔的叙事从来不是连贯的，它往往在遗物文本，卡面插画和问号事件中，让玩家一步一步拼凑事件的真相</p><h4 id="2-3-1-事件系统的叙事化重构"><a href="#2-3-1-事件系统的叙事化重构" class="headerlink" title="2.3.1 事件系统的叙事化重构"></a><strong>2.3.1 事件系统的叙事化重构</strong></h4><p>传统Roguelike的事件往往是“收益vs损失”的简单博弈。《杀戮尖塔》将这种博弈升级为 <strong>“碎片化叙事探索”与“即时资源安全”的复合式抉择</strong>。</p><p>其设计精髓在于：游戏从不直接讲述完整故事，而是将世界观的线索与角色的过去，拆解为 <strong>“可交互的叙事碎片”</strong>，散落在玩家必经的决策之中。以“感知石”事件为例：</p><ul><li><strong>表层博弈</strong>：选项A（损失生命，获得一张随机无色牌） vs 选项B（无事发生，保留血量）</li><li><strong>叙事层博弈</strong>：选项A（触摸石头，被迫直面一段痛苦或关键的过往记忆，并以一张“卡牌”的形式将这份记忆固化为己用） vs 选项B（拒绝回忆，保持现状，但可能永远错过理解“我是谁”与“我为何在此”的机会）</li></ul><p>这种设计将一次普通的资源交换，转化为一次 <strong>“角色身份建构”</strong> 的主动选择。玩家在衡量生命值与一张未知卡牌的价值时，潜意识里也在回答：“我的角色是否渴望面对真相？他&#x2F;她是一个勇于揭开伤疤的探寻者，还是一个回避过去的生存者？”</p><h4 id="2-3-2-碎片化叙事的载体：遗物、卡牌与事件的文本密语"><a href="#2-3-2-碎片化叙事的载体：遗物、卡牌与事件的文本密语" class="headerlink" title="2.3.2 碎片化叙事的载体：遗物、卡牌与事件的文本密语"></a><strong>2.3.2 碎片化叙事的载体：遗物、卡牌与事件的文本密语</strong></h4><ol><li><p><strong>遗物的描述文本</strong>：短短一两句话，既是功能说明，也是微型故事。例如“痛楚印记”（战士专属遗物）的描述：“北方部族的战士们用这个来将痛楚转化为力量。”这句话未展开任何背景，却直接点明了战士的出身（北方部族）及其核心战斗哲学（转化痛楚），并与其“伤口”机制形成互文。</p></li><li><p><strong>卡牌的图像与名称</strong>：卡面美术与名称是未被言说的叙事。观者的“诸神之黄昏”卡面描绘雷霆与洪水袭击高塔，其名称直接借用北欧神话中的末日之战，两者结合，强烈暗示了高塔世界曾遭逢一场神罚级的灾难。玩家无需阅读任何文本，便能感受到画面中蕴含的宏大悲剧与毁灭意象。</p></li><li><p><strong>事件中的对话与选项</strong>：随机事件是动态的叙事碎片。在“幽灵议会”事件中，幽灵们会称玩家为“奥涅的玩偶”，并邀请你“尝试我们的力量”。这短短几句对话，至少抛出了三个叙事钩子：奥涅是谁？我们与奥涅是何关系？幽灵的力量本质是什么？玩家通过选择是否接受力量，不仅获得了游戏性的“灵体”卡牌，也亲自介入了这段模糊的亡灵往事，其选择本身就成了对角色与幽灵关系的一种诠释。</p></li></ol><table><thead><tr><th align="left">载体</th><th align="left">叙事内容举例</th><th align="left">叙事特点</th><th align="left">玩家行为</th></tr></thead><tbody><tr><td align="left"><strong>遗物描述</strong></td><td align="left">“捕梦网：北方部族的猎手用它来滤除噩梦，只留下预兆。”</td><td align="left">冰山一角，暗示文化、习俗与信仰。</td><td align="left">阅读、联想、拼凑族群背景。</td></tr><tr><td align="left"><strong>卡牌图像&#x2F;名</strong></td><td align="left">卡牌“恶魔形态”上战士狰狞的样貌与手中的火焰；“死亡收割”中汲取的蓝色灵魂能量。</td><td align="left">视觉叙事，展现角色状态、力量来源或世界片影。</td><td align="left">观察、解读图像背后的故事与变化。</td></tr><tr><td align="left"><strong>事件文本</strong></td><td align="left">“女鬼”事件中，那个不断询问你是否认识她的哀伤灵魂。</td><td align="left">沉浸式片段，提供情感冲击与未解之谜。</td><td align="left">做出选择，参与并定义这段小型叙事。</td></tr></tbody></table><p>这种 <strong>“碎片化-载体化”</strong> 的叙事策略，创造了独特的玩家体验：追求剧情的玩家会像考古学家一样，仔细审视每一件遗物的说明，端详每一张卡牌的画作，品味每一段事件的对话，从中剥离信息，在脑海中构建属于自己的世界观图景。而不关注剧情的玩家，则可以完全无视这些文本与暗示，毫不影响他们享受构筑与爬塔的核心乐趣。叙事由此成为一种 <strong>“可选的深度”</strong> ，而非强制的灌输，这正是《杀戮尖塔》在叙事系统化设计上的高明之处。</p><h3 id="2-4-核心循环：从玩法到意义的升华"><a href="#2-4-核心循环：从玩法到意义的升华" class="headerlink" title="2.4 核心循环：从玩法到意义的升华"></a>2.4 核心循环：从玩法到意义的升华</h3><p>《杀戮尖塔》的核心循环设计实现了从表层玩法到深层意义的自然过渡：</p><p><strong>表层循环（玩家直观感受）</strong>：<br>战斗 → 获取奖励 → 选择路线 → 继续战斗</p><p><strong>深层循环（叙事赋予意义）</strong>：<br>发掘记忆（获取卡牌&#x2F;遗物） → 理解过去（阅读背景文本） → 塑造自我（确定构筑方向） → 面对真相（挑战关键首领） → 改变世界（达成角色结局）</p><h2 id="三、设计哲学提炼"><a href="#三、设计哲学提炼" class="headerlink" title="三、设计哲学提炼"></a>三、设计哲学提炼</h2><h3 id="3-1-四大核心理念"><a href="#3-1-四大核心理念" class="headerlink" title="3.1 四大核心理念"></a>3.1 四大核心理念</h3><p><strong>理念一：玩法即叙事</strong><br>《杀戮尖塔》彻底摒弃了独立的剧情动画和过场CG。角色的每一个能力、敌人的每一个行为、玩家的每一个抉择，这些<strong>本身就是故事的讲述</strong>。当战士打出“黑暗之拥”时，这不只是在获得过牌能力，更是在经历被恶魔侵蚀的过程；当猎手使用“丢弃”时，这不只是在过滤牌库，更是在战斗中摒除杂念、专注要害。</p><p><strong>理念二：系统作为隐喻</strong><br>游戏中的抽象机制都通过叙事获得了具体的隐喻意义：</p><ul><li>弃牌 &#x3D; 专注（猎手的战斗哲学）</li><li>烧牌 &#x3D; 牺牲（战士的力量代价）</li><li>姿态切换 &#x3D; 心绪流转（观者的心灵控制）</li><li>充能球 &#x3D; 古代能源（机器人的文明遗产）</li></ul><p><strong>理念三：碎片引导想象</strong><br>游戏不提供完整的世界观编年史，而是提供“先古之民”、“荒疫”、“神罚”等<strong>关键词和散落线索</strong>。这种设计激发了玩家的推理欲和社区讨论，玩家在论坛中拼凑线索、分享理论，极大延长了游戏的生命周期。</p><p><strong>理念四：一致性创造沉浸</strong><br>从职业机制到卡牌美术，从遗物效果到敌人设计，从地图氛围到音乐音效，《杀戮尖塔》的所有元素都服务于同一套<strong>黑暗、神秘、略带克苏鲁气息的叙事调性</strong>。这种高度的一致性创造了强烈的沉浸感。</p><h2 id="四、对同类项目的启示"><a href="#四、对同类项目的启示" class="headerlink" title="四、对同类项目的启示"></a>四、对同类项目的启示</h2><h3 id="4-1-完整的设计路径"><a href="#4-1-完整的设计路径" class="headerlink" title="4.1 完整的设计路径"></a>4.1 完整的设计路径</h3><p>对于希望借鉴《杀戮尖塔》叙事系统化设计的项目，可以参考以下完整路径：</p><p><strong>阶段一：立项阶段的主题选择</strong><br>在为游戏核心玩法寻找叙事主题时，要选择<strong>可以深度系统化的主题</strong>。例如：</p><ul><li>卡牌构筑玩法 → 考古主题（卡牌&#x3D;文物，构筑&#x3D;修复）</li><li>资源管理玩法 → 生态主题（资源&#x3D;物种，管理&#x3D;平衡）</li><li>角色成长玩法 → 教育主题（升级&#x3D;学习，技能&#x3D;知识）</li></ul><p><strong>阶段二：角色设计的叙事整合</strong><br>职业的叙事背景必须是其核心机制的<strong>合理解释与情感包装</strong>。机制应该是叙事背景的自然延伸，叙事应该是机制的情感化包装。</p><p><strong>阶段三：进程设计的主题匹配</strong><br>游戏进程的每个阶段都应有明确的叙事主题，并且这个主题应该体现在该阶段的机制挑战中。如果某一章的主题是“背叛”，那么机制可以围绕“资源逆转”、“盟友变敌人”等设计。</p><p><strong>阶段四：内容投放的策略性</strong><br>将剧情信息拆解为可被玩法系统承载的“道具”——卡牌描述、遗物文本、事件选项、敌人台词等。让追求剧情的玩家可以主动挖掘，让不感兴趣的玩家可以完全忽略，实现叙事的<strong>可选择消费</strong>。</p><h2 id="总结：叙事作为系统设计的范式价值"><a href="#总结：叙事作为系统设计的范式价值" class="headerlink" title="总结：叙事作为系统设计的范式价值"></a>总结：叙事作为系统设计的范式价值</h2><p>《杀戮尖塔》的世界观设计证明，叙事可以不只是游戏的“装饰”或“背景板”，而是可以成为游戏的<strong>结构性框架</strong>。这套“叙事系统化”的设计方法，创造了几个关键价值：</p><h3 id="1-解决了Roguelike的重复性问题"><a href="#1-解决了Roguelike的重复性问题" class="headerlink" title="1. 解决了Roguelike的重复性问题"></a>1. 解决了Roguelike的重复性问题</h3><p>通过让每次爬塔都成为独特的角色史诗，玩家感受到的不是“又一遍相同的流程”，而是“一个新角色的新故事”。</p><h3 id="2-提升了决策的情感重量"><a href="#2-提升了决策的情感重量" class="headerlink" title="2. 提升了决策的情感重量"></a>2. 提升了决策的情感重量</h3><p>玩家的每一个游戏决策都同时是叙事决策，这让简单的资源权衡变成了具有情感重量的性格定义。</p><h3 id="3-创造了深度的沉浸感"><a href="#3-创造了深度的沉浸感" class="headerlink" title="3. 创造了深度的沉浸感"></a>3. 创造了深度的沉浸感</h3><p>当游戏的所有元素——机制、美术、音效、文本——都服务于同一套叙事调性时，玩家会自然地进入游戏世界。</p><h3 id="4-延长了游戏生命周期"><a href="#4-延长了游戏生命周期" class="headerlink" title="4. 延长了游戏生命周期"></a>4. 延长了游戏生命周期</h3><p>碎片化叙事激发了社区的讨论和理论构建，玩家在游戏之外继续探索世界观，形成了良性的生态循环。</p><pre class="mermaid">graph TD    A[传统设计<br>玩法与叙事分离] --> B[玩家体验割裂<br>沉浸感有限]        C[杀戮尖塔设计<br>叙事成为系统框架] --> D{四大价值}    D --> E[解决重复性问题]    D --> F[提升决策重量]    D --> G[创造深度沉浸]    D --> H[延长生命周期]        style C fill:#ccffcc    style D fill:#ffffcc</pre><p>《杀戮尖塔》的成功不仅仅是玩法设计的成功，更是<strong>叙事系统化设计范式</strong>的成功。它展示了一条将世界观深度融入核心系统的新路径，为整个游戏设计领域提供了宝贵的启示：<strong>当叙事不再只是被“讲出来”，而是被“玩出来”时，游戏就能创造出真正独特而深刻的情感体验。</strong></p><hr><p>到这里我对杀戮尖塔的拆解工作便告一段落啦，大家如果有什么想法可以在评论区交流哦</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;《杀戮尖塔》设计拆解——世界观篇&quot;&gt;&lt;a href=&quot;#《杀戮尖塔》设计拆解——世界观篇&quot; class=&quot;headerlink&quot; title=&quot;《杀戮尖塔》设计拆解——世界观篇&quot;&gt;&lt;/a&gt;《杀戮尖塔》设计拆解——世界观篇&lt;/h1&gt;&lt;blockquote&gt;
&lt;h6 </summary>
      
    
    
    
    <category term="游戏" scheme="https://yifei-huang-cos.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>杀戮尖塔设计拆解——内容篇</title>
    <link href="https://yifei-huang-cos.github.io/posts/98ac3117/"/>
    <id>https://yifei-huang-cos.github.io/posts/98ac3117/</id>
    <published>2026-01-28T09:00:00.000Z</published>
    <updated>2026-01-29T09:17:20.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《杀戮尖塔》设计内容深度拆解"><a href="#《杀戮尖塔》设计内容深度拆解" class="headerlink" title="《杀戮尖塔》设计内容深度拆解"></a>《杀戮尖塔》设计内容深度拆解</h1><h6 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h6><p>《杀戮尖塔》以其精妙的规则融合，定义了Roguelike卡牌。其成功远非简单的玩法叠加。本文将以 “内容拆解 → 平衡性分析 → 设计哲学提炼” 的三步框架，由表及里地剖析其设计精髓，揭示这款游戏如何将简单的规则编织成近乎无限的可能，并提供持久的策略乐趣。</p><h2 id="第一步：内容拆解——游戏的建筑逻辑"><a href="#第一步：内容拆解——游戏的建筑逻辑" class="headerlink" title="第一步：内容拆解——游戏的建筑逻辑"></a>第一步：内容拆解——游戏的建筑逻辑</h2><p>任何深度分析都始于对构成要素的系统性理解。</p><h3 id="1-核心驱动循环"><a href="#1-核心驱动循环" class="headerlink" title="1. 核心驱动循环"></a>1. 核心驱动循环</h3><p>每一局游戏都由一个简洁有力的引擎驱动，其核心循环如下图所示，它构成了单局游戏最基本的行为骨架：</p><pre class="mermaid">flowchart TD    A[战斗<br>消耗生命，检验牌组] --> B[获取奖励<br>三选一卡牌/金币/遗物]    B --> C{地图路径决策<br>风险评估与资源规划}    C -->|选择路线| A</pre><p>这个循环持续进行，玩家的每一次选择都在动态塑造着独一无二的牌组与资源状况。</p><p>生命值在此循环中扮演着双重角色：它既是需要保障的生存需求，也是可以谨慎花费以换取更高奖励的货币。</p><p>（特定事件可以用血量换取收益——遗物或者卡牌）</p><h3 id="2-核心构建维度"><a href="#2-核心构建维度" class="headerlink" title="2. 核心构建维度"></a>2. 核心构建维度</h3><p>玩家力量的成长围绕三个可累积的系统展开：</p><ul><li><p><strong>卡牌</strong>：主动的操作单元，分为</p><ul><li>攻击牌：直接伤害；</li><li>技能牌：格挡、施加状态等；</li><li>能力牌：整场持续的被动效果；</li></ul></li><li><p><strong>遗物</strong>：提供从数值加成到机制颠覆的各类效果，是构筑产生质变的关键。</p><ul><li>数值加成：金刚杵加1力量，光滑的石头加1敏捷。这类遗物提供简单粗暴的加数值；</li><li>机制改变：冰淇淋让回合结束后能量不清空，金字塔让回合结束时的手牌不丢弃。这类遗物改变构筑思路和出牌逻辑；</li><li>局外成长：古钱币直接给300块，烟斗让火堆额外多了删牌事件。这些遗物让玩家在战斗之外改变构筑提升战力；</li></ul></li><li><p><strong>药水</strong>：一次性的战术储备，用于应急或弥补构筑短板。</p><ul><li>提供抽牌，回血，格挡，换牌等效果；</li><li>小怪概率掉落，商店稳定购买，事件可能获取；</li><li>通过减少药水栏位限制高进阶玩家；</li></ul></li></ul><h3 id="3-核心博弈资源"><a href="#3-核心博弈资源" class="headerlink" title="3. 核心博弈资源"></a>3. 核心博弈资源</h3><p>除了牌组，玩家还需持续管理两种抽象资源：</p><ul><li><strong>生命值</strong>：如上所述，是驱动核心循环的关键资源，对血量的判断是否足以打精英怪换取遗物；</li><li><strong>金币</strong>：集中于商店系统的经济资源。用于购买关键卡牌、遗物，以及萌新可能忽视的删卡；</li></ul><h3 id="4-庞大的内容池"><a href="#4-庞大的内容池" class="headerlink" title="4. 庞大的内容池"></a>4. 庞大的内容池</h3><p>游戏提供了丰富的交互可能性，确保每次冒险的独特性，每个职业拥有完全独立的卡池与核心机制，玩法迥异。</p><ul><li><h4 id="四大职业："><a href="#四大职业：" class="headerlink" title="四大职业："></a>四大职业：</h4><ul><li><h6 id="战士：我认为，战士的最核心机制是消耗："><a href="#战士：我认为，战士的最核心机制是消耗：" class="headerlink" title="战士：我认为，战士的最核心机制是消耗："></a>战士：我认为，战士的最核心机制是消耗：</h6><ul><li>通过点烧（坚毅+，燃烧契约）和大烧（重振精神，恶魔之焰）完成对局内卡组的精简，进一步打出小循环或无限循环。</li><li>常见cambo有剑耸无限（有日晷真无限，带放血伪无限），亮剑妙计，撑振肚皮，进化无谋契约…</li><li>除此之外，战士还有以壁垒巩固为核心的防战体系和以力量组件为核心的力量战体系（偏门的有强依赖单卡和火堆的灼热战体系）</li></ul></li><li><h6 id="猎人：猎人核心是运转，通过摸弃完成过牌回费和零费输出："><a href="#猎人：猎人核心是运转，通过摸弃完成过牌回费和零费输出：" class="headerlink" title="猎人：猎人核心是运转，通过摸弃完成过牌回费和零费输出："></a>猎人：猎人核心是运转，通过摸弃完成过牌回费和零费输出：</h6><ul><li>弃牌体系对猎人来说是最成熟的体系，组件也最常见，例如最强白卡过牌杂技1费抽4弃1，因为对猎人来说，弃牌往往带来的是正面收益（本能反应被弃后抽牌，战术大师被弃后回费）强大的运转能力使得猎人几乎适配所有0费输出，尤其是金卡华丽收场，0费AOE高伤害，即使打出需要严苛的条件，也值得猎人为此特化构筑</li><li>猎人第二分支是毒猎，由于高进阶慢启动吃战损、怕人工等缺点，在没有关键卡催化剂的情况下，往往作为过渡的选择</li><li>小刀猎：萌新最爱玩的流派之一，但是最好祈祷不要遇到小刀猎最严厉的父亲哦（会遇到时间吞噬者！）</li></ul></li><li><h6 id="故障机器人（球-x2F-重编程）："><a href="#故障机器人（球-x2F-重编程）：" class="headerlink" title="故障机器人（球&#x2F;重编程）："></a>故障机器人（球&#x2F;重编程）：</h6><p>​由于本人的机器人水平并不高，遂邀请友人对其评价，由于内容较长，放至附录1。</p></li><li><h6 id="观者：观者核心是姿态转换："><a href="#观者：观者核心是姿态转换：" class="headerlink" title="观者：观者核心是姿态转换："></a>观者：观者核心是姿态转换：</h6><ul><li>愤怒：双倍伤害，但受伤也双倍，观者的最核心机制没有之一。所有观者的输出卡设计时候都要考虑到双倍伤害这一条件。哪怕是初始的打击+1费打9，到观者手上就是一费18，产生质变。在前两层里，愤怒加两个打击足以秒杀许多小怪了。愤怒的机制让观者有了速杀的能力。</li><li>平静：退出平静姿态时候回两费。如果说单看愤怒机制，还可以说是风险与机遇并存——高伤害的同时防御压力也翻倍，无法斩杀的怪物就要考虑防守。但是如果加上平静则完全不同，观者完全可以进入暴怒输出打完后在进入平静，不仅不用承受双倍防御压力，还能为下一轮的输出积攒费用。1费平静卡的存在导致观者完全可以在红蓝之间切换的费用不会损失，只要抽牌量足够，观者就能把所有的牌打出去。我相信很多小伙伴打出的第一个无限就是猛虎下山加暴怒不惧妖邪（鸡煲：我要学猛虎下山！）然后释怀的笑</li><li>神格：存在感很低的体系，被红蓝遮掩了锋芒，其本身底子不错，有过牌有保留有0费卡，但是组件过于绑定，拿一张意味着就要拿一个体系，观者又是一个对卡组大小很敏感的职业，导致实战很多人不愿意拿第一张神格卡（完全是累赘），进而不碰整个神格体系。就像我在数值篇分析的那样，观者的卡牌数值结构就是存在明显的问题，无用卡占比比其余三个职业加起来都多，这是设计里比较可惜的点。</li><li>预见：最意义不明的体系，设计的像一个半成品，不予评价</li></ul></li></ul></li><li><h4 id="渐进式挑战："><a href="#渐进式挑战：" class="headerlink" title="渐进式挑战："></a>渐进式挑战：</h4><p>​三层逐级攀升的冒险，每层结尾设有机制独特的强力首领，对牌组的完成度提出硬性考验。</p><ul><li><p><strong>一层</strong>：发育为主，高难挑战较少，提前准备对策卡即可。如精英小红要求卡组的攻击牌浓度，精英三柱要求卡组中有对群特攻或者快速的点杀能力。总体来说危险程度不大，以引导玩家合理选卡为主。</p></li><li><p><strong>二层</strong>：危险度高，考验卡组抗压能力。高进阶的二层是玩家失败最多的层数。一方面是二层小怪的高攻击欲望带来的血线压力，且常会给玩家加debuff；另一方面玩家卡组大多数在二层尚未成型，如果一层boss遗物掉落的不好的话在二层刚进门遇到双小偷或者3鸟都会比较吃力。且二层精英怪三奴隶和小手攻击欲望很高每回合都有高额攻击，会往卡组里塞伤口，较为克制吃启动和运转的卡组。在二层，玩家得精细把控血量和发育的平衡，既不能横死道中，也不可火堆全睡亏了发育。</p></li><li><p><strong>三层</strong>：卡组成型的检验，引导玩家补强或找到短板。有趣的是，虽然三层小怪的强度高于二层，但玩家压力缺普遍低于二层，三层的实际压力是塔顶的双重boss（进阶20才有）。能过二层，说明玩家卡组已经初步成型，在三层的的主要目的变成了寻找关键key牌补强，或者敲牌删牌发育。而三层boss才是三层的灵魂：</p><ul><li>1.觉醒者：特殊机制：2条命，玩家每开一个能力牌觉醒者加两点力量。克制能力多的职业。（在启动了！）</li><li>2.时间吞噬者（老头）：特殊机制：玩家每出12牌强制结束回合。特别克制以来运转的体系和低质量无限</li><li>3.八体和甜甜圈：特殊机制：高成长，塞眩晕，还有三层人工不好上debuff。</li></ul></li><li><p><strong>最终boss</strong>：心脏。最难的boss。特殊机制如下：</p><ul><li>1.律动：每出1张牌受到伤害，伤害量随回合数逐渐递增。这个机制强制要求卡组必须有起防能力，不能打没有防御的无限：例如双剑柄日晷，必须搭配起防卡或者遗物。</li><li>2.坚不可摧：每受到200点伤害后，将免疫一切伤害。杜绝了一切速杀的可能，再强大的攻杀卡组，也得至少四回合，变相提高了对卡组中防御浓度的需求。</li><li>3.第一回合塞状态牌和挂debuff。作为集大成者，心脏第一回合不会攻击，而是转为向你的抽牌堆里加入五张状态牌，并且给你挂易伤（受到伤害增加），虚弱（造成伤害减少），脆弱（获得格挡减少）等debuff。这对卡组的请状态牌能力提出高要求，并且也干扰很多脆弱的无限和循环手段。</li><li>4.高成长：心脏每三回合进行一次强化，提高力量并重置自身负面状态。基本八到九回合之后，心脏的攻击九很难用一般起防手段防御住了。这个机制要求玩家的卡组有在上述负面条件影响下依旧能快速解决战斗的能力。</li></ul></li></ul></li><li><h4 id="随机事件："><a href="#随机事件：" class="headerlink" title="随机事件："></a>随机事件：</h4><ul><li>提供高风险高回报的特殊抉择，持续增加游戏进程的变数。部分事件具有一锤定音的效果，例如二层的灵体事件可以解决绝大多数卡组的启动压力，三层的敲全部牌事件是缺敲位猎人的救命稻草（即使代价是无法回复血量）。由于诸多随机事件的设计，给杀戮尖塔的路线选择带来更加丰富的可能性，也提供了未知的乐趣和博弈性。</li></ul></li></ul><h2 id="第二步：平衡性分析——精密的调控艺术"><a href="#第二步：平衡性分析——精密的调控艺术" class="headerlink" title="第二步：平衡性分析——精密的调控艺术"></a>第二步：平衡性分析——精密的调控艺术</h2><p>真正让这些模块焕发生机的，是使其相互咬合、充满权衡的精妙平衡设计。下图概括了游戏在几个关键维度上如何设置平衡点：</p><pre class="mermaid">flowchart LR    subgraph A [风险与回报的量化]        direction LR        A1[生命值] -- 作为决策货币 --> A2[计算精英战收益<br>评估事件代价]    end    subgraph B [资源与污染的博弈]        direction LR        B1[添加新卡牌] -- 可能 --> B2[稀释牌库浓度]        B2 -- 提升 --> B3[删除基础牌的战略价值]    end    subgraph C [遗物的催化效应]        direction LR        C1[特定遗物] -- 与卡牌协同 --> C2[引发质变<br>如：蛇眼+高费攻击]        C2 -- 引导 --> C3[整局游戏构筑方向]    end    A --> D[终极目标：<br>在动态约束中规划最优解]    B --> D    C --> D</pre><h3 id="1-风险与回报的量化体系"><a href="#1-风险与回报的量化体系" class="headerlink" title="1. 风险与回报的量化体系"></a>1. 风险与回报的量化体系</h3><p>游戏将绝大多数决策转化为可评估的风险与回报。</p><ul><li><strong>生命值的隐形标价</strong>：一场普通战斗的预期损耗、一个事件选项的潜在代价、挑战精英所需的“入场费”，都经过了精确计算。精英战斗虽然危险，但其掉落的核心遗物价值被设定为“通常值得且经常必要”，尤其是在高层进阶中，回避精英往往意味着后期强度不足。</li><li><strong>路线选择的数学博弈</strong>：地图设计保证了高收益节点（精英、商店）往往伴随更高的战斗密度或路径成本。玩家需要根据实时状态（血量、金币、牌组关键需求）进行动态规划，计算最优的数学期望。</li></ul><h3 id="2-卡牌强度与“卡组污染”的对抗"><a href="#2-卡牌强度与“卡组污染”的对抗" class="headerlink" title="2. 卡牌强度与“卡组污染”的对抗"></a>2. 卡牌强度与“卡组污染”的对抗</h3><p>单卡强度必须置于牌组整体循环效率的全局中考量。</p><ul><li><strong>稀释惩罚</strong>：盲目添加低质量或不合流的卡牌，会显著降低抽到核心组件的概率。这迫使玩家在“拿牌解决当下问题”与“保持牌组精简专注”之间持续权衡。</li><li><strong>删除机制的战略价值</strong>：因此，商店中的“删牌”服务成为核心战略环节。移除初始的打击防御以提升卡组中关键牌的浓度，是构筑从粗糙走向精炼的关键一步，这赋予了经济资源（金币）深远的战略意义。</li></ul><h3 id="3-职业核心机制的数值边界"><a href="#3-职业核心机制的数值边界" class="headerlink" title="3. 职业核心机制的数值边界"></a>3. 职业核心机制的数值边界</h3><p>​具体分析见上文杀戮尖塔的数值分析篇，这里仅作简单介绍。</p><ul><li>战士的格挡与力量：格挡值每回合清空，使得壁垒这类保留格挡的卡牌价值凸显。力量成长虽线性，但与多段攻击配合能产生指数级伤害，其潜力被严格限制在高费用或稀有卡中。</li><li>猎手的弃牌运转：其核心在于通过大量抽牌、弃牌触发效果（如“本能反应”、“杂技”）和0费卡牌来实现每回合的高额操作量。平衡的关键在于，减少卡组内非关键牌的浓度（初始的打击防御，仅用于过渡的攻击卡），和需要配合的资源卡（战术大师，弃置此牌获得能量）。</li><li>故障机器人的集中：作为提升所有充能球效率的全局乘数，获取集中力的手段（如“碎片整理”、“偏差认知”）</li><li>观者的姿态切换：“愤怒”姿态下造成与承受伤害均翻倍，这一简洁设计创造了极高的操作风险与爆发潜力，迫使玩家精确规划姿态切换的节奏，实现高效的攻防循环。</li></ul><h3 id="4-遗物的催化剂效应"><a href="#4-遗物的催化剂效应" class="headerlink" title="4. 遗物的催化剂效应"></a>4. 遗物的催化剂效应</h3><p>遗物设计的高明之处在于，它们常常是能促使卡组产生化学反的催化剂。</p><ul><li>协同引爆点：如死灵之书（每回合第一张二费及以上攻击牌打出两次）与高费攻击牌的配合，能将单次爆发伤害倍增。这类遗物与特定卡牌结合后，便能引发构筑的质变。</li><li>构筑导向性：早期获得一个核心遗物（如“异蛇之眼”：每回合多抽二，你卡牌的能力消耗将会随机改变），往往会直接定义整局游戏的构筑方向（多抓高费牌，少抓0费）。这种因势利导的动态规划，正是游戏策略深度的核心体现。</li></ul><h2 id="第三步：设计哲学提炼——成功的底层逻辑"><a href="#第三步：设计哲学提炼——成功的底层逻辑" class="headerlink" title="第三步：设计哲学提炼——成功的底层逻辑"></a><strong>第三步：设计哲学提炼——成功的底层逻辑</strong></h2><p>在具体的平衡性之上，是支撑整个游戏体验的、更为普适的设计理念。这些理念之间的支撑关系，构成了游戏稳固的设计三角：</p><pre class="mermaid">graph TD    subgraph 表层体验        D[动态构建的乐趣<br>“现在我能走哪条路？”]    end    subgraph 底层支柱        A[“限制”创造深度<br>能量/手牌/生命值] --> D        B[信息透明下的风险计算<br>将运气转化为策略] --> D        C[可控的随机性<br>用选择引导随机结果] --> D    end    D --> E[核心体验：<br>在约束中感受掌控感与成长的权力]</pre><h3 id="1-限制是深度策略的源泉"><a href="#1-限制是深度策略的源泉" class="headerlink" title="1. 限制是深度策略的源泉"></a>1. 限制是深度策略的源泉</h3><p>游戏中最引人入胜的决策，几乎都源于与各种限制的对抗。</p><ul><li><p>能量限制（每回合3点）：要求权衡每张卡牌的费用与效果。</p></li><li><p>手牌与抽牌限制：需要管理牌序并构建过牌引擎。</p></li><li><p>药水槽位限制：让每个药水选择都意义重大。</p></li><li><p>生命值限制：将生存压力转化为贯穿全局的决策维度。</p><p>正是这些限制的存在，使得那些能够突破限制的效果（获得额外能量、额外抽牌、复制卡牌、无视消耗等）成为玩家构建的终极追求，创造了强烈的成长感与构筑成就感。</p></li></ul><h3 id="2-信息透明下的风险计算"><a href="#2-信息透明下的风险计算" class="headerlink" title="2. 信息透明下的风险计算"></a>2. 信息透明下的风险计算</h3><p>游戏摒弃了战斗中的隐藏骰子，并清晰预告敌人的下回合行动。这巧妙地将运气问题转化为了风险计算问题。<br>玩家思考的不再是会不会出暴击？，而是以我当前的血量和牌库，接下这招后存活并反制的概率有多大？决策基于已知信息与概率估算，成功带来的成就感源于精妙的规划与计算，而非单纯的随机恩赐。</p><h3 id="3-动态适应，而非静态搭配"><a href="#3-动态适应，而非静态搭配" class="headerlink" title="3. 动态适应，而非静态搭配"></a>3. 动态适应，而非静态搭配</h3><p>与预先组好固定套牌的传统卡牌游戏不同，《杀戮尖塔》的核心乐趣在于<strong>根据已获得的资源，即时规划最优的胜利路径</strong>。每一局，玩家都在回答一个动态问题：“基于我当前的卡牌和遗物，我最有可能通往胜利的构筑方向是什么？”<br>这就要求设计必须提供大量中等强度、具备多种协同潜力的卡牌与遗物，确保无论随机获得何种奖励，玩家总能找到一个有发展潜力的方向，而非依赖少数几个固定的通关公式。</p><h3 id="4-可控的随机与正向的雪球效应"><a href="#4-可控的随机与正向的雪球效应" class="headerlink" title="4. 可控的随机与正向的雪球效应"></a>4. 可控的随机与正向的雪球效应</h3><p>游戏的随机性被高度结构化的“玩家选择”所包裹与引导。</p><ul><li><p>三选一奖励：允许玩家在随机选项中挑选最符合当前策略的拼图。</p></li><li><p>地图路线选择：允许玩家根据自己的状态主动趋利避害。</p></li><li><p>商店购买：允许玩家用通用资源（金币）精确填补短板。</p><p>这种设计让玩家感觉自己是在不断将随机性引导向利于自己的方向。一旦关键协同形成，构筑开始正向循环（产生雪球效应），玩家能清晰感受到自己对局面的控制力从弱到强的增长过程。这种不断增强的掌控感，是游戏提供持久正反馈和成瘾性的关键。</p></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h2><p>通过对《杀戮尖塔》“内容-平衡-设计”三层结构的剖析，我们可以看到，其伟大之处在于构建了一个规则简洁但交互深奥的决策模拟器。<br>它以限制创造张力，以透明保障公平，以动态构建鼓励智慧适应，再以可控的随机性提供无穷的探索空间。它将所有游戏元素编织进一张精密的网中，让每一次抽牌、每一次路线选择都充满意义。<br>最终，它提供了一种纯粹而迷人的策略乐趣：在规则与随机的双重约束下，运用智慧，从无到有地构建出一个能够克服万难、独特而强大的系统。这或许就是《杀戮尖塔》能够超越类型，成为设计典范的根本原因。</p><hr><h2 id="附录1"><a href="#附录1" class="headerlink" title="附录1"></a>附录1</h2><h6 id="特别鸣谢："><a href="#特别鸣谢：" class="headerlink" title="特别鸣谢："></a>特别鸣谢：</h6><p><strong>Songhan Cai先生对故障机器人理论提出的大力支持。他是出色鸡煲高手（），让我们看看他对故障机器人的理解</strong>：</p><blockquote><p>​故障机器人是杀戮尖塔中的最强的角色<strong>（括号均为黄逸飞插话：并非）</strong>，它拥有其他职业难以望其项背的数值和令所有怪物闻风丧胆的机制（<strong>数值在哪？</strong>）。</p><p>​机器人的大部分体系围绕充能球来展开，四种充能球各司其职，在各个端口为机器人构建了全面并且强大（<strong>？</strong>）的体系支架。</p><p>​1.电球是机器人最容易获取的球，他每回合能提供基础稳定的伤害，产球成本低使得能更好在循环中把其他球推出去，在电动力学的加持下还能转变为高贵的aoe，更为可贵的是电球随机选择目标攻击，这让机器人这个职业天生比其他人多了很多很多随机数，能在无数次sl中找到唯一获胜的世界线。</p><p>​2.黑球有着更高的爆发伤害，其蓄力机制能很好和循环递归，双放这种牌配合，利用好瞄准生命值最低目标的机制，找到合适的时机选择推出去还是攒球。</p><p>​3.等离子白球的获取成本更高，但是其收益十分之恐怖，大多数boss遗物每回合加一费都要让你付出高昂的代价，而这仅仅需要我们鸡煲挂一个白球，同时白球的激发能让机器人马上获得两费，简直是无与伦比的爆发能力。</p><p>​4.而最强最强最强的则是冰球，其提供的护甲看似很少，但是在集中，循环和更多球位的多重杠杆之下，冰球会为机器人筑起固若金汤的防御端，而且是每回合自动的。有了集中冰甚至攻击端能仅仅凭一个沙漏就能腐乳时间吞噬者，你只需要每回合按e，然后拿起手机刷十分钟视频。</p><p>​现在通过球和集中来分析机器人的攻击和防御端，电球黑球提供伤害，冰球提供防御，那么怎么让他们的数值达到合格水平以应对怪物呢。第一个想到的就是生成更多的球，把原来的球推出去以获得更多数值，这点通过打出电击，冷头，漆黑等优质产球牌就可以做到。第二是通过增加球位，或者通过循环来提升我们每回合球的挂机收益。最重要的第三点，则是提升我们的集中，集中能够同时提升球的被动收益和推球的收益，作为一个独立的乘区增幅机器人的战斗力，能提供集中的牌和遗物都是受机器人所喜爱（<strong>尽孝</strong>）。无论在局外抓卡还是局内操作，牢记这三点的均衡对机器人来说都是基本且必要的。</p><p>​接下来说一下物理攻防，球的数值不受力量，敏捷，易伤，虚弱等等多重常见状态影响，导致其思路有所不同，和某些遗物的配合也较差。但这不意味鸡煲不需要传统攻防牌，在卡组没有成型前，我们需要适当抓取一些物理攻防过渡牌，如眼部，光束射线，自动护盾，这是职业特性和怪物环境双重决定的（严父小红），有些牌同时兼顾物理和产球，如球闪，冰川，愁云，这让他们前中后期都有不俗的发挥。</p><p>​而物理机则是机器人一种完全不同的思路，以重编程为绝对核心，用掉集中这个对于机器人来说能废掉一半牌的代价换取配合比起其他职业少的多的力敏，是比灼热战和点穴观更垃圾的存在，所以绝大时候机器人还是以物理为辅助，充能球为核心。<strong>（在这里我插一嘴，其他职业的棱镜玩法中，重编程是一张非常强力的卡牌，可惜跟了机器人）</strong></p><p>​来到运转端，机器人在运转方面的优劣势都十分明显，他不像战士能烧干所有牌打小循环，不能学猎人娴熟通过猴戏弃牌打出复杂操作，更不是某个凭借着崩坏的数值就无法无天洁癖抓牌嗯凑唐氏红蓝无限的最弱角色（<strong>别逗你观姐笑了</strong>）能碰瓷的。大部分鸡煲都是均卡思路，好牌多抓，通过打出能力牌逐步建立优势，但是打能力牌也需要抽牌位和费用且收益延迟，故而启动稍稍慢那么一点点也就是鸡煲稍有瑕疵的小缺点了（<strong>偏差认知了，偏差认知，偏差认，偏差，偏…<strong>）。而优点是，在费用方面鸡煲手握着最多的优质加费，如四职业唯一白卡费用牌内核，简单粗暴的双倍能量，一边烧牌一边赚费的回收。过牌方面，无论是没数值的快检还是有数值的编冲，都在一个可用的中庸水平，能够定向检索和复用的全息搜寻万物也都是十分适配均卡体系的。但缺少一锤定音的过牌核心如黑拥猛虎一直是鸡煲的一个痛点，定位相似的散热片并不是那么好用（</strong>我要学猛虎下山！</strong>）。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;《杀戮尖塔》设计内容深度拆解&quot;&gt;&lt;a href=&quot;#《杀戮尖塔》设计内容深度拆解&quot; class=&quot;headerlink&quot; title=&quot;《杀戮尖塔》设计内容深度拆解&quot;&gt;&lt;/a&gt;《杀戮尖塔》设计内容深度拆解&lt;/h1&gt;&lt;h6 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写</summary>
      
    
    
    
    <category term="游戏" scheme="https://yifei-huang-cos.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>杀戮尖塔设计拆解——数值篇</title>
    <link href="https://yifei-huang-cos.github.io/posts/eff9c8a5/"/>
    <id>https://yifei-huang-cos.github.io/posts/eff9c8a5/</id>
    <published>2026-01-28T02:00:00.000Z</published>
    <updated>2026-01-29T09:17:45.618Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《杀戮尖塔》数值设计深度拆解"><a href="#《杀戮尖塔》数值设计深度拆解" class="headerlink" title="《杀戮尖塔》数值设计深度拆解"></a>《杀戮尖塔》数值设计深度拆解</h1><p>​在卡牌与Roguelike融合的游戏品类中，《杀戮尖塔》的成功离不开其精妙且恰到好处的数值设计。作为一款策略类，以决策为核心乐趣的游戏，它不依靠华丽的特效或复杂的剧情，而是通过能量、卡牌、遗物、难度等多维度的数值平衡，构建了“战斗-奖励-提升”的数值循环与“费用-收益”匹配的价值曲线，最终形成既充满随机性又具备可控策略空间的体验闭环。</p><p>​我累计500余小时的攀登历程中，深刻感受到每一处数值细节都暗藏策划巧思，下文将结合参考文章的权威数值体系，从核心资源价值、卡牌数值架构、遗物联动逻辑、难度平衡设计四个核心维度，拆解其数值设计的精髓。</p><hr><h2 id="⚡-一、核心资源数值（能量）：作为抉择基石"><a href="#⚡-一、核心资源数值（能量）：作为抉择基石" class="headerlink" title="⚡ 一、核心资源数值（能量）：作为抉择基石"></a>⚡ 一、核心资源数值（能量）：作为抉择基石</h2><p>​《杀戮尖塔》的战斗数值体系中，每回合的能量是贯穿始终的核心约束变量，其数值设定直接决定了策略决策的深度，且存在明确的价值量化标准。游戏初始默认单回合能量上限为3点（部分职遗物可提升），能量存在固定价值曲线：0点能量基础价值为3，之后每增加1点能量额外提供2点价值，这一量化标准构成了卡牌设计的核心基准，而非简单的“3点约束”。这一数值体系实则构建了“攻击-防御-能量-运转”的四维策略平衡，迫使玩家在每回合进行精准的资源分配与机会成本权衡。</p><h4 id="🔹-1-1-从设计意图来看"><a href="#🔹-1-1-从设计意图来看" class="headerlink" title="🔹 1.1 从设计意图来看"></a>🔹 1.1 从设计意图来看</h4><p>​初始3点能量的数值设定是价值曲线与策略深度的最优解：若能量过多，玩家可同时触发多个高价值连携效果，策略抉择的价值会大幅降低；若能量过少，则无法支撑基础连携的触发，破坏卡组运转流畅度。3点能量恰好让玩家每回合需在基础输入+单一乘区或者多乘区组合但基础输入弱化等策略中抉择。</p><p>​面对一层精英敌人乐嘉（额这是外号，具体名字不记得了QAQ）即将到来的高额攻击，玩家需在1费防御（5格挡，价值匹配）+2费攻击（打击1费打6）与2费防御（初始防御1费5格挡）+1费运转（抽牌调整手牌）之间权衡，而这种抉择直接关联生命值资源的消耗与留存，正是数值驱动策略乐趣的核心来源。</p><p>​值得注意的是，即使是0费卡牌也存在隐性成本，其占用的抽牌位会导致错过其他关键卡牌，这一机会成本同样被纳入能量价值体系的考量范畴。</p><h4 id="🔹-1-2-能量数值的弹性设计进一步丰富了策略维度"><a href="#🔹-1-2-能量数值的弹性设计进一步丰富了策略维度" class="headerlink" title="🔹 1.2 能量数值的弹性设计进一步丰富了策略维度"></a>🔹 1.2 能量数值的弹性设计进一步丰富了策略维度</h4><p>​游戏通过融合之锤（boss遗物）孙子兵法（普通遗物）等遗物提供能量加成，例如孙子兵法的设定是：如果不使用攻击卡下回合+1能量，本质是通过策略选择换取能量价值的提升（额外获得2点基础价值）；而许多boss遗物通过支付某些特定代价（例如锤子：火堆无法升级牌；绿帽：无法获得金币）换取每回合稳定多一费。这种代价支付加稳定收益的数值设计，既保证了体系的稳定性，又为流派构建提供了多样化可能。</p><hr><h2 id="🃏-二、卡牌数值体系（费效比）：精准定位与价值平衡"><a href="#🃏-二、卡牌数值体系（费效比）：精准定位与价值平衡" class="headerlink" title="🃏 二、卡牌数值体系（费效比）：精准定位与价值平衡"></a>🃏 二、卡牌数值体系（费效比）：精准定位与价值平衡</h2><p>​卡牌是玩家实现策略意图的核心载体，《杀戮尖塔》的卡牌数值设计遵循：卡组定位、费效比、联动组件三大原则，核心逻辑是以能量价值为基准，构建‘基础输入-乘区放大-导出转化’的强度公式，确保不同类型、不同费用的卡牌在性价比上保持平衡，同时尽可能避免策略单一化，掩盖其他玩法的问题。单张卡牌效果普遍简洁，仅提供基础输入或单一乘区，需通过组合形成强大连携，这既降低了玩家记忆成本，又提升了策略深度。</p><h4 id="⚠️-2-1-插一句设计缺陷"><a href="#⚠️-2-1-插一句设计缺陷" class="headerlink" title="⚠️ 2.1 插一句设计缺陷"></a>⚠️ 2.1 插一句设计缺陷</h4><p>​（上一段所说的避免策略单一化只在前两个职业，即战士和猎人上完成的较为完美，而我们鸡煲，呃呃，懂得都懂，问就是还在启动，在启动。观者的设计则是严重不平衡，暴怒带来的双倍伤害让其很多职业卡的费效比不尽人意，红蓝无限的玩法带来的收益又过于超模，掩盖了观者的神格预见点穴等体系。虽说这几个体系本来也有数值不足的问题。只能说观者的出现，对玩家来说可能是玩起来比较容易爽的角色，但从数值设计的角度看，无疑是失败的）</p><h4 id="🔹-2-2-在攻击卡牌设计中"><a href="#🔹-2-2-在攻击卡牌设计中" class="headerlink" title="🔹 2.2 在攻击卡牌设计中"></a>🔹 2.2 在攻击卡牌设计中</h4><p>​数值严格匹配能量价值曲线，且通过“基础输入+乘区”的组合形成差异化定位。</p><p>​1费的打击基础伤害为6点（价值2，匹配1费能量价值5中的基础部分），2费的重击伤害为14点且附带3倍力量加成（价值5+2，2费能量价值7完全匹配），而非简单的倍数关系；0费的愤怒可造成6点伤害并在弃牌堆放入一张自身，收益为2+1（额外留存卡牌资源），精准匹配0费能量3点的基础价值。</p><p>​不同卡牌的乘区特性适配不同流派：战士的重击依赖力量乘区实现爆发输出，静默猎手的0费小刀则通过多次攻击乘区触发精准，袖箭等被动效果，成为小刀流的核心输入组件。这种设计让低费卡并非弱卡，而是适配高频连击流派，高费卡则需放弃当回合其他资源，形成明确的机会成本权衡。</p><h4 id="🔹-2-3-防御卡牌的数值设计同样遵循价值曲线，且聚焦临时防护"><a href="#🔹-2-3-防御卡牌的数值设计同样遵循价值曲线，且聚焦临时防护" class="headerlink" title="🔹 2.3 防御卡牌的数值设计同样遵循价值曲线，且聚焦临时防护"></a>🔹 2.3 防御卡牌的数值设计同样遵循价值曲线，且聚焦临时防护</h4><p>​游戏将格挡设定为临时性防御资源，没有特殊卡牌和遗物的情况下防御不会保留，1点格挡等价于1点生命值。</p><p>​1费的初始卡防御提供5点格挡（价值匹配1费能量），2费的稀有卡岿然不动提供30点格挡，但是是消耗卡，不能够反复利用。玩家可根据敌方伤害数值选择合适的防御卡牌：面对小额持续伤害，优先使用低费防御卡节省能量；面对大额单次伤害，则需投入高费防御卡或组合多张防御卡。</p><p>​更关键的是，防御维度可通过特定卡牌转化为攻击强度，例如战士的肚皮（全身撞击，未升级是1费，升级后变成0费）可造成当前格挡值的攻击伤害，将防御资源转化为输出输入，这一设计打破了维度壁垒，让“高防御+高输出”的防战流派成为可能。而能力卡壁垒可以保留格挡值的设定，更是强化了防御乘区的效果，让格挡资源可跨回合累积，催生格挡转伤害的防御流派。</p><h4 id="🔹-2-4-卡牌升级的数值提升也严格匹配价值均衡原则"><a href="#🔹-2-4-卡牌升级的数值提升也严格匹配价值均衡原则" class="headerlink" title="🔹 2.4 卡牌升级的数值提升也严格匹配价值均衡原则"></a>🔹 2.4 卡牌升级的数值提升也严格匹配价值均衡原则</h4><p>​打击升级后伤害从6提升至9（提升幅度50%），防御升级后格挡从5提升至8（提升幅度60%），升级后的价值仍与能量费用精准匹配，既让升级后的卡牌具备明显优势，又不会让未升级卡牌完全失效。这一设计确保玩家在升级卡牌与回复生命的火堆处选择中产生策略博弈——是提升长期战力以减少后续生命值消耗，还是保证当前生存以规避即时风险？这种博弈让每一次火堆选择都成为影响数值循环的关键决策。</p><hr><h2 id="🧩-三、遗物数值联动：打破基础规则的策略裂变引擎"><a href="#🧩-三、遗物数值联动：打破基础规则的策略裂变引擎" class="headerlink" title="🧩 三、遗物数值联动：打破基础规则的策略裂变引擎"></a>🧩 三、遗物数值联动：打破基础规则的策略裂变引擎</h2><p>​遗物系统是《杀戮尖塔》数值设计的点睛之笔，其核心价值在于通过“数值加成+机制改变”的组合，优化卡组的体系，催生多样化的流派构建。遗物的数值设计并非简单的数值堆砌，而是精准匹配卡牌的连携逻辑，同时服务于“战斗-奖励-提升”的数值循环（因为遗物通常由精英怪掉落，而打精英怪可能面临生存危险，你说是吧鸡煲TvT（还在启动，在启动，启动，启…）），与卡牌体系形成约束和强化的联动闭环——没有合适的卡牌组合，遗物的数值优势无法发挥；缺少遗物的数值加持，卡牌组合也难以形成质变。</p><h4 id="🔹-3-1-普通遗物：补充短板和优化体验为主"><a href="#🔹-3-1-普通遗物：补充短板和优化体验为主" class="headerlink" title="🔹 3.1 普通遗物：补充短板和优化体验为主"></a>🔹 3.1 普通遗物：补充短板和优化体验为主</h4><p>​战士的初始遗物“燃烧之血”效果是战斗后回血6点，解决了前期回血资源稀缺的问题，让玩家可更激进地挑战战斗；普通遗物背包的效果是第一轮多抽2张牌，提升关键牌上手率，降低第一轮的鬼抽概率；还有商店遗物工具箱，棱镜，前者可以每场战斗3选1一张无色牌，就冲着能选到神话和打钱手这也是必买遗物，而棱镜则打破职业卡限制，让选择里多出其他职业的职业卡，可能会选出梦寐以求的配合（鸡煲：我要学猛虎下山！）。这些数值设计虽看似微小，但能显著优化特定职业的前期体验，引导玩家向职业核心流派靠拢。</p><h4 id="🔹-3-2-罕见遗物与Boss遗物则通过数值质变和机制突破催生全新策略，同时兼顾对单一策略的抑制"><a href="#🔹-3-2-罕见遗物与Boss遗物则通过数值质变和机制突破催生全新策略，同时兼顾对单一策略的抑制" class="headerlink" title="🔹 3.2 罕见遗物与Boss遗物则通过数值质变和机制突破催生全新策略，同时兼顾对单一策略的抑制"></a>🔹 3.2 罕见遗物与Boss遗物则通过数值质变和机制突破催生全新策略，同时兼顾对单一策略的抑制</h4><p>​钢笔尖设定“每第十张攻击造成双倍伤害，将“低费复用输出的运转转化为攻击乘区，引导玩家调整高费攻击卡排序；蛇眼作为boss遗物，效果是每回合多抽2张，但所有卡牌的费用会从0到3费随机，解决了过牌问题，也让玩家多抓高费卡少带低费卡。</p><p>​而针对飞身踢无限等可能导致策略退化的玩法，游戏通过数值限制进行平衡——飞身踢基础伤害仅5点（低于初始打击的6点），且需目标有易伤效果才能打出，提升了连携成本；同时Boss“时间吞噬者”设定玩家每打出12张牌后强制结束回合，从机制上限制低数值无限的强度（比如亮剑【0费打3抽1】妙计【0费防2抽1】相互抽的低数值无限），确保各流派的平衡。</p><hr><h2 id="📊-四、难度梯度数值：动态平衡的“学习型”挑战曲线"><a href="#📊-四、难度梯度数值：动态平衡的“学习型”挑战曲线" class="headerlink" title="📊 四、难度梯度数值：动态平衡的“学习型”挑战曲线"></a>📊 四、难度梯度数值：动态平衡的“学习型”挑战曲线</h2><p>​《杀戮尖塔》的进阶等级系统是其数值难度设计的核心，最高20级的进阶梯度并非简单提升敌人血量与伤害，而是通过“精准数值微调+规则约束增加”的方式，扰动核心数值循环，构建平滑且富有深度的学习型挑战曲线。其设计逻辑与玩家策略成长相匹配，低进阶等级调整普通敌人数值，引导玩家熟悉卡牌与遗物的基础连携；高进阶等级则通过规则约束强化数值压力，迫使玩家优化卡组构建策略。</p><h4 id="🔹-4-1-进阶难度的数值设计"><a href="#🔹-4-1-进阶难度的数值设计" class="headerlink" title="🔹 4.1 进阶难度的数值设计"></a>🔹 4.1 进阶难度的数值设计</h4><p>​遵循蝴蝶效应原则，通过微小的数值调整引发策略连锁反应。例如进阶17后，二层普通敌人三鸟的坠机条件从受击3次变为受击4次，看似仅增加1次受击需求，却直接提升了对运转维度与攻击频率的要求（经典是观者的发泄，不敲三段伤害，敲了4段伤害，在低进阶一个发泄就可以把三鸟肘下来，在高进阶则刚需升级）——低费高频攻击卡组需多花费1回合才能击落，可能导致暴露在敌方多轮攻击下，增加生命值消耗。</p><p>​而进阶20中，普通敌人壳爹＋蘑菇（开幕21和他的易伤药，已经畏惧了 …）第一回合伤害从18点提升至21点并附加脆弱Debuff），这一调整直接放大了防御维度的价值缺口，迫使玩家必须在前期就构建足够的防御体系，否则极易血量崩盘。这种差一点就通关的数值设计，既不会让玩家产生挫败感，又能推动玩家深化对数值体系的理解，优化策略决策以适配更严苛的数值循环。</p><h4 id="🔹-4-2-高进阶等级的规则约束"><a href="#🔹-4-2-高进阶等级的规则约束" class="headerlink" title="🔹 4.2 高进阶等级的规则约束"></a>🔹 4.2 高进阶等级的规则约束</h4><p>​进阶10后，玩家初始生命上限减少，这一数值调整直接提升了前期生命值资源的稀缺性，让血量管理成为核心决策点，同时放大了燃烧血、羽毛、梨子、华夫饼等回血与生命上限提升类遗物的价值（当然丢人枕头除外）；进阶15后“商店卡牌价格提升”，则扰动了经济数值循环，迫使玩家更谨慎地分配金币资源，优先选择移除低价值初始卡牌（指打击）而非盲目购买新卡。</p><p>这些设计形成了难度约束与策略适配的动态平衡，确保玩家在提升技巧的同时，始终能获得匹配的挑战体验。</p><hr><h2 id="🎯-结语：数值驱动的策略乐趣闭环"><a href="#🎯-结语：数值驱动的策略乐趣闭环" class="headerlink" title="🎯 结语：数值驱动的策略乐趣闭环"></a>🎯 结语：数值驱动的策略乐趣闭环</h2><p>​《杀戮尖塔》的数值设计之所以精妙，在于其构建了一个“价值基准-连携放大-循环闭环-难度适配”的完整体系：以能量价值曲线为基础基准，通过卡牌的“基础输入-乘区-导出”架构实现策略落地，借助遗物优化或打破基础规则以丰富流派，再通过难度调整扰动数值循环，推动玩家深化策略理解。</p><p>​整个体系的核心是生命值等价原则，所有资源最终都可转化为生命值的留存能力，而每一处数值细节都服务于策略决策的核心乐趣——让玩家在随机生成的尖塔中，通过解读数值关系、组合连携模块、适配数值循环，不断探索全新的构筑可能性。这种以数值为骨架，以策略为血肉的设计思路，不仅避免了策略退化，保证了多流派的平衡共存，更成就了《杀戮尖塔》的经典地位，为后续卡牌Roguelike游戏的数值设计提供了可借鉴的核心框架。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;《杀戮尖塔》数值设计深度拆解&quot;&gt;&lt;a href=&quot;#《杀戮尖塔》数值设计深度拆解&quot; class=&quot;headerlink&quot; title=&quot;《杀戮尖塔》数值设计深度拆解&quot;&gt;&lt;/a&gt;《杀戮尖塔》数值设计深度拆解&lt;/h1&gt;&lt;p&gt;​		在卡牌与Roguelike融合的游戏品</summary>
      
    
    
    
    <category term="游戏" scheme="https://yifei-huang-cos.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>AI x game 深度体验报告</title>
    <link href="https://yifei-huang-cos.github.io/posts/2c281e1a/"/>
    <id>https://yifei-huang-cos.github.io/posts/2c281e1a/</id>
    <published>2026-01-27T03:28:30.000Z</published>
    <updated>2026-01-27T03:52:18.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AI-x-game体验报告——是不可替代还是锦上添花？"><a href="#AI-x-game体验报告——是不可替代还是锦上添花？" class="headerlink" title="AI x game体验报告——是不可替代还是锦上添花？"></a>AI x game体验报告——是不可替代还是锦上添花？</h1><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>AI技术近年来发展迅猛，其迭代进程与应用成果已深深融入社会生活各领域，给大众带来了直观且深刻的感知。在此背景下，将AI技术与游戏产业相结合的创作理念逐渐成为热点，各类融合AI元素的新兴游戏产品如同雨后春笋般涌现。</p><p>不过，虽然很多游戏都使用AI，但他们的设计理念却不尽相同。有些是利用AI增添新的模块，像是在游戏里增加了接入大模型的可交互的NPC，增加UGC中的AI创作辅助；有些是基于AI构建新的玩法，比如构建一个全部由AI agent构成的社区，观察或参与他们的行为，在这个游戏里，AI是构建整个玩法的底层逻辑；或者更加简单通用一点，只是利用AI进行美术建模和文本的辅助创作……这些游戏到底怎么样，好不好玩，对AI的使用又究竟到了哪一步？我将在其中选择几种具有代表性的进行体验。</p><h1 id="二、游玩体验"><a href="#二、游玩体验" class="headerlink" title="二、游玩体验"></a>二、游玩体验</h1><h2 id="1-AI-陪伴类：情绪价值的提供者"><a href="#1-AI-陪伴类：情绪价值的提供者" class="headerlink" title="1. AI-陪伴类：情绪价值的提供者"></a>1. AI-陪伴类：情绪价值的提供者</h2><p>现代社会中，快节奏的学习与工作节奏使得部分群体面临人际交往困境，或因社交适应障碍，或因缺乏有效倾诉对象，其情绪宣泄需求难以得到充分满足。在此背景下，在游戏场景中植入AI陪伴功能的设计理念应运而生，为解决此类群体的情绪需求提供了新的载体。</p><h3 id="1-1-王者荣耀的灵宝系统-x2F-和平精英AI战犬玩法"><a href="#1-1-王者荣耀的灵宝系统-x2F-和平精英AI战犬玩法" class="headerlink" title="1.1 王者荣耀的灵宝系统&#x2F;和平精英AI战犬玩法"></a>1.1 王者荣耀的灵宝系统&#x2F;和平精英AI战犬玩法</h3><p>2024年2月，王者荣耀上线了灵宝系统；25年11月，和平推出了AI战犬模式。直到今日，灵宝系统也一直在优化与迭代升级，就我个人的体验来说，我还是非常喜欢这个几个小家伙的。为什么这么说呢，我认为这种局内陪伴满足了以下几个优点：</p><h4 id="1-1-1-游戏操作正反馈，提供情绪价值"><a href="#1-1-1-游戏操作正反馈，提供情绪价值" class="headerlink" title="1.1.1 游戏操作正反馈，提供情绪价值"></a>1.1.1 游戏操作正反馈，提供情绪价值</h4><p>尤其在自己单排的时候，4个队友全部闭麦很常见。无论在你打出精彩操作拿到完美击杀还是在大逆风时刻出其不意抢下大龙，队友不一定会夸你，都在闭麦干自己的事。这无可厚非，但没有人为你欢呼 难免会失落。但有灵宝就不一样，他夸奖人来比谁都快<del>比如我玩兰陵王喜欢开局反（tou）对面红buff，每每打完红之后听灵宝来一句：“拿下对面红buff，对面打野恐怕要气疯了吧</del>” 欸嘿，心情就会非常舒坦。</p><h4 id="1-1-2-局内提供帮助，利好休闲玩家"><a href="#1-1-2-局内提供帮助，利好休闲玩家" class="headerlink" title="1.1.2 局内提供帮助，利好休闲玩家"></a>1.1.2 局内提供帮助，利好休闲玩家</h4><p>王者荣耀与和平精英作为国民级手游，拥有庞大的玩家群体，这进一步导致了休闲玩家的比例占绝大多数。相比于硬核玩家，他们的游戏技术或意识显得会比较低。那如何更好的照顾到这类玩家的游戏体验呢？局内陪伴的另一个作用便显现出来了。这里那和平的战犬举例，给出对应的语音指令，战犬便会帮忙收集物资，牵制敌人，或者救助队友，很好的避免了轻度玩家进入游戏后的手忙脚乱。并且他的功能性设计，也不会对游戏平衡性造成很大的破坏。对我这个新手来说，算是帮大忙了</p><h4 id="1-1-3-活跃游戏气氛，调节玩家情绪"><a href="#1-1-3-活跃游戏气氛，调节玩家情绪" class="headerlink" title="1.1.3 活跃游戏气氛，调节玩家情绪"></a>1.1.3 活跃游戏气氛，调节玩家情绪</h4><p>在现代社会中，比完整的游戏时间更难得的是有个和你一起打游戏的朋友，不一定两个人都有时间。所以很多时候我都是单排自己玩，难免会感到寂寞，此时局内陪伴的作用就来了，时不时来两句插科打诨，也可博君一笑。</p><h3 id="1-2-星之低语-x2F-EVE（后者目前只有二测演示视频）"><a href="#1-2-星之低语-x2F-EVE（后者目前只有二测演示视频）" class="headerlink" title="1.2 星之低语&#x2F;EVE（后者目前只有二测演示视频）"></a>1.2 星之低语&#x2F;EVE（后者目前只有二测演示视频）</h3><h4 id="1-2-1-whispered-from-the-star"><a href="#1-2-1-whispered-from-the-star" class="headerlink" title="1.2.1 whispered from the star"></a>1.2.1 whispered from the star</h4><p>该产品是由蔡浩宇主导开发的AI对话类游戏，核心玩法围绕玩家与游戏内漂泊太空的女性角色展开全程对话交互，通过AI的引导与玩家的决策推进剧情。我体验了两个小时，怎么说呢，个人觉得这更像是一款实验品，验证人机交互逻辑和语音识别的先行者，而不是一个完整的游戏。从目前的技术力来看，星之低语的交互建模语音生成乃至情感叙事无疑都走在同类型赛道的前列。但是问题在于，游戏性的缺失导致这不像一个游戏，更像是一次英语口语练习（笑）。其体验的瓶颈也显而易见：后期的交互易陷入重复，缺乏真正的情感弧线与剧情张力。当然啦，它的技术力很强也是无可反驳的。我目前更倾向于认为这是一款公开的试验田，为以后的模型收集数据和反馈，期待他们的下一款游戏。</p><h4 id="1-2-2-EVE"><a href="#1-2-2-EVE" class="headerlink" title="1.2.2 EVE"></a>1.2.2 EVE</h4><p>相比于上面一款，这个游戏的理念更加贴近于传统AI陪伴的概念。该产品以构建3D虚拟伴侣为核心，规划实现对话交互、语音通话、生活服务提醒（如点奶茶、购药等）等功能。由于该产品计划于今年三月公测，且优先面向女性向用户群体，我的体验仅基于测试玩家发布的演示视频进行分析。</p><p>从行业发展视角来看，《EVE》的产品形态本身并非我们的关注核心，其背后的设计思路更具行业参考价值。该产品精准命中了AI陪伴领域的核心潜在需求——为用户提供符合个性化想象的、以用户为中心的虚拟伴侣。无论《EVE》正式上线后的市场表现如何，其开创的产品方向必然会引发行业内其他游戏工作室的跟进。社会调查数据显示，大龄单身青年群体规模持续扩大，此类群体的情感需求并未因单身状态而消失，对情感替代载体的需求日益凸显。而具备高真实度交互能力的AI虚拟伴侣，恰好能够满足这一需求。未来，该赛道有望涌现更多高技术力产品，但如何实现产品差异化竞争，将成为我们需要深入思考的核心问题。</p><h2 id="2-AI-NPC：最多的可能性，但被技术力约束"><a href="#2-AI-NPC：最多的可能性，但被技术力约束" class="headerlink" title="2. AI NPC：最多的可能性，但被技术力约束"></a>2. AI NPC：最多的可能性，但被技术力约束</h2><p>曾经，NPC所说的话总是由文案策划构思好，虽然这对于游戏的推进来说是最快捷的方式，但看多了不免感到乏味。随着LLM的兴起，大家不约而同的想到那个可能性————让大模型控制NPC的交流行为甚至剧情。</p><h3 id="2-1-逆水寒-x2F-燕云十六声"><a href="#2-1-逆水寒-x2F-燕云十六声" class="headerlink" title="2.1 逆水寒&#x2F;燕云十六声"></a>2.1 逆水寒&#x2F;燕云十六声</h3><p>在我印象里，逆水寒最早大规模宣传自己的AI npc，当时我也是因为这个宣传下载体验了一番汴京的风土人情。当时也涌现了很多与AI对话的“焚诀”，和ai npc斗智斗勇也成了每天上线不得不品的一环。乐趣确实有，也能通过文字交流得到npc的物品，在当时给我感觉还是比较新奇有趣的。</p><p>比较可惜的是，这些玩法没有更进一步，你和npc的对话对游戏主体的影响微乎其微，也基本在主线剧情中得不到体现。在这两款游戏里，AI不是一个不可代替的玩法，只是一个外接的模块，可以说删了这个功能换成传统的npc对话形式也不会对游戏产生多大影响。只能说这是受限于目前的技术力，还无法做到AI影响的多剧情分支走向（也可能是不方便管理？）</p><h3 id="2-2-AI-bot，觉悟人机"><a href="#2-2-AI-bot，觉悟人机" class="headerlink" title="2.2 AI bot，觉悟人机"></a>2.2 AI bot，觉悟人机</h3><p>这就比较的传统并且成熟了，在游戏对局内补充人机有利于减少玩家匹配时间，控制对局强度，也有利于新手玩家熟悉游戏，由于在大部分游戏里已经有了较为成熟的应用，本文不再赘述</p><h2 id="3-AI作为游戏基石：未来将至？"><a href="#3-AI作为游戏基石：未来将至？" class="headerlink" title="3. AI作为游戏基石：未来将至？"></a>3. AI作为游戏基石：未来将至？</h2><p>以上是在传统的游戏中增添AI的元素，那么我们有没有可能以AI为底层逻辑创建一个游戏呢？很多影视文学作品都给出过设想，例如头号玩家，失控玩家以及前几年较火的元宇宙概念，他们都给我们提供了一种可能性。我也很高兴的看到有很多游戏在向这方面发展，例如斯坦福小镇，avilizition以及喵吉托的几款游戏demo（例如喵呜岛）。</p><h3 id="3-1-avilizition的体验"><a href="#3-1-avilizition的体验" class="headerlink" title="3.1 avilizition的体验"></a>3.1 avilizition的体验</h3><p>这个项目更准确地应该称为一个模拟平台。它的核心理念非常吸引人（也是我所展望追求的）：每个智能体都有独立的记忆、人际关系和日程，所有的决策都具有蝴蝶效应，npc并能根据与环境和彼此的互动来动态决策。</p><p>我的体验过程充满了新奇与困惑。一开始，我就像进入了一个上帝视角的观察者，看着这些像素小人在小镇里活动，他们会上班、购物、聊天、举办活动。最让我感到惊讶的是，他们之间的互动确实能产生一些预设脚本之外的故事。比如，我看到两个角色因为在咖啡馆的一次聊天而决定晚上一起去酒吧，或者因为之前的某次争执而在下一次见面时显得冷淡。这种基于记忆和关系链产生的行为变化，是它最核心的亮点，让你感觉这个小镇是活的，有自己的时间流。</p><p>但是，这种新鲜感褪去得也很快。首先是交互的乏力感。作为玩家，我能与这些AI角色对话，但对话内容往往流于表面，很难进行有深度的、能实质性改变他们目标或关系的交流。更多的时候，我感觉我是在试图引导对话，而不是在进行有意义的角色扮演。avilizition给我的感觉是，它是一座通往未来游戏理念的桥梁设计图，但我们脚下的建筑材料还不足以把它扎实地建造起来。它足以证明了AI作为游戏世界底层逻辑的可行性，但要把它变成一款好玩的游戏，还有很长的路要走。</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>经过这些体验，我认为目前AI在游戏中的应用，整体上仍然处于“锦上添花”的阶段。无论是提供陪伴的灵宝、战犬，还是能自由对话的NPC，它们确实带来了新鲜感和更好的体验，像是给原有的蛋糕裱上了更精美的花。但如果我们把花拿走，蛋糕本身并没有改变。它们更多是体验的优化与内容的补充。</p><p>然而，从《星之低语》、《EVE》这类纯粹的AI交互应用，尤其是像avilizition这样以AI为世界基石的尝试中，我们能看到一种截然不同的可能性。它们不再满足于做蛋糕上的点缀，而是试图用AI这种新材料，从头烤制一块全新的、我们从未尝过的点心。虽然目前这些可能还有些生涩，形态也不稳定，但方向已经指明。</p><p>所以，我的看法是：未来，AI完全有可能成为构建游戏里不可替代的基石。这条路很长，但起点已经在我们脚下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AI-x-game体验报告——是不可替代还是锦上添花？&quot;&gt;&lt;a href=&quot;#AI-x-game体验报告——是不可替代还是锦上添花？&quot; class=&quot;headerlink&quot; title=&quot;AI x game体验报告——是不可替代还是锦上添花？&quot;&gt;&lt;/a&gt;AI x </summary>
      
    
    
    
    <category term="游戏" scheme="https://yifei-huang-cos.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>刚体运动的python解法</title>
    <link href="https://yifei-huang-cos.github.io/posts/48befe4f/"/>
    <id>https://yifei-huang-cos.github.io/posts/48befe4f/</id>
    <published>2026-01-26T08:53:00.000Z</published>
    <updated>2026-01-27T00:40:45.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自由转动杆与铰链固定杆倾倒时间对比研究"><a href="#自由转动杆与铰链固定杆倾倒时间对比研究" class="headerlink" title="自由转动杆与铰链固定杆倾倒时间对比研究"></a><strong>自由转动杆与铰链固定杆倾倒时间对比研究</strong></h1><h2 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h2><p>​某p大友人中午问了我一个问题</p><p>​<img src="/../images/%E5%88%9A%E4%BD%93%E5%8A%A8%E5%8A%9B.png"></p><hr><p>曾经自诩“高中物理领域神棍”的我也是体会了一把修为尽失的感觉…….可恶，还是，做不到吗。。。</p><p>才怪！现在我有了新的武器，解析不了我就暴力数值解嘻嘻</p><h2 id="二、物理模型"><a href="#二、物理模型" class="headerlink" title="二、物理模型"></a>二、物理模型</h2><h3 id="2-1-自由杆（光滑地面）"><a href="#2-1-自由杆（光滑地面）" class="headerlink" title="2.1 自由杆（光滑地面）"></a>2.1 自由杆（光滑地面）</h3><ul><li><strong>约束条件</strong>：底端无水平约束，质心水平方向动量守恒</li><li><strong>运动特点</strong>：质心同时有平动和转动</li><li><strong>能量方程</strong>：$E &#x3D; \frac{1}{2}mv_c^2 + \frac{1}{2}I_c\omega^2 + mg\frac{L}{2}\cos\theta$</li></ul><h3 id="2-2-铰链杆（固定底端）"><a href="#2-2-铰链杆（固定底端）" class="headerlink" title="2.2 铰链杆（固定底端）"></a>2.2 铰链杆（固定底端）</h3><ul><li><strong>约束条件</strong>：底端位置固定，绕该点纯转动</li><li><strong>运动特点</strong>：质心作圆弧运动</li><li><strong>能量方程</strong>：$E &#x3D; \frac{1}{2}I_o\omega^2 + mg\frac{L}{2}\cos\theta$</li></ul><hr><h2 id="三、动力学方程推导"><a href="#三、动力学方程推导" class="headerlink" title="三、动力学方程推导"></a>三、动力学方程推导</h2><h3 id="3-1-自由杆的倾倒时间"><a href="#3-1-自由杆的倾倒时间" class="headerlink" title="3.1 自由杆的倾倒时间"></a>3.1 自由杆的倾倒时间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自由杆的角速度公式推导</span></span><br><span class="line">ω² = (4g/L) * (cosθ₀ - cosθ)</span><br></pre></td></tr></table></figure><h3 id="3-2-铰链杆的倾倒时间"><a href="#3-2-铰链杆的倾倒时间" class="headerlink" title="3.2 铰链杆的倾倒时间"></a>3.2 铰链杆的倾倒时间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 铰链杆的角速度公式推导</span></span><br><span class="line">ω² = (3g/L) * (cosθ₀ - cosθ)</span><br></pre></td></tr></table></figure><hr><h2 id="四、数值计算方法"><a href="#四、数值计算方法" class="headerlink" title="四、数值计算方法"></a>四、数值计算方法</h2><h3 id="4-1-时间积分公式"><a href="#4-1-时间积分公式" class="headerlink" title="4.1 时间积分公式"></a>4.1 时间积分公式</h3><p>倾倒时间通过对角速度倒数积分得到：<br>$$ t &#x3D; \int_{\theta_0}^{\pi&#x2F;2} \frac{1}{\omega(\theta)} d\theta $$</p><h3 id="4-2-数值实现代码"><a href="#4-2-数值实现代码" class="headerlink" title="4.2 数值实现代码"></a>4.2 数值实现代码</h3><h4 id="自由杆计算代码"><a href="#自由杆计算代码" class="headerlink" title="自由杆计算代码"></a>自由杆计算代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">g = <span class="number">9.81</span></span><br><span class="line">L = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入杆长 L (米): &quot;</span>))</span><br><span class="line">theta0_deg = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入初始倾斜角度 (0–90°, 相对竖直): &quot;</span>))</span><br><span class="line"></span><br><span class="line">theta0 = np.deg2rad(theta0_deg)</span><br><span class="line">theta_end = np.pi / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">integrand</span>(<span class="params">theta</span>):</span><br><span class="line">    omega = np.sqrt((<span class="number">4</span> * g / L) * (np.cos(theta0) - np.cos(theta)))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / omega</span><br><span class="line"></span><br><span class="line">thetas = np.linspace(theta0 + <span class="number">1e-6</span>, theta_end, <span class="number">200000</span>)</span><br><span class="line">t = np.trapezoid(integrand(thetas), thetas)</span><br></pre></td></tr></table></figure><h4 id="铰链杆计算代码"><a href="#铰链杆计算代码" class="headerlink" title="铰链杆计算代码"></a>铰链杆计算代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">g = <span class="number">9.81</span></span><br><span class="line">L = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入杆长 L (米): &quot;</span>))</span><br><span class="line">theta0_deg = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入初始倾斜角度 (0–90°, 相对竖直): &quot;</span>))</span><br><span class="line"></span><br><span class="line">theta0 = np.deg2rad(theta0_deg)</span><br><span class="line">theta_end = np.pi / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">integrand</span>(<span class="params">theta</span>):</span><br><span class="line">    omega = np.sqrt((<span class="number">3</span> * g / L) * (np.cos(theta0) - np.cos(theta)))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / omega</span><br><span class="line"></span><br><span class="line">thetas = np.linspace(theta0 + <span class="number">1e-6</span>, theta_end, <span class="number">200000</span>)</span><br><span class="line">t = np.trapezoid(integrand(thetas), thetas)</span><br></pre></td></tr></table></figure><hr><h2 id="五、模拟结果分析"><a href="#五、模拟结果分析" class="headerlink" title="五、模拟结果分析"></a>五、模拟结果分析</h2><h4 id="5-1-不同初始角度对比（默认杆长1m）"><a href="#5-1-不同初始角度对比（默认杆长1m）" class="headerlink" title="5.1 不同初始角度对比（默认杆长1m）"></a>5.1 不同初始角度对比（默认杆长1m）</h4><table><thead><tr><th>初始角度</th><th>自由杆时间(s)</th><th>铰链杆时间(s)</th><th>时间比(自由&#x2F;铰链)</th></tr></thead><tbody><tr><td>1°</td><td>1.1837</td><td>1.3668</td><td>想算的自己算</td></tr><tr><td>10°</td><td>0.6648</td><td>0.7676</td><td></td></tr><tr><td>30°</td><td>0.4163</td><td>0.4807</td><td>(—&gt; __  —&gt;)</td></tr><tr><td>45°</td><td>0.3201</td><td>0.3697</td><td></td></tr><tr><td>60°</td><td>0.2431</td><td>0.2807</td><td></td></tr><tr><td>80°</td><td>0.1338</td><td>0.1545</td><td></td></tr></tbody></table><h3 id="5-2-不同杆长对比（默认倾斜30°）"><a href="#5-2-不同杆长对比（默认倾斜30°）" class="headerlink" title="5.2 不同杆长对比（默认倾斜30°）"></a>5.2 不同杆长对比（默认倾斜30°）</h3><table><thead><tr><th>杆长(m)</th><th>自由杆时间(s)</th><th>铰链杆时间(s)</th><th>时间比</th></tr></thead><tbody><tr><td>0.5</td><td>0.2944</td><td>0.3399</td><td></td></tr><tr><td>1.0</td><td>0.4163</td><td>0.4807</td><td></td></tr><tr><td>2.0</td><td>0.5888</td><td>0.6799</td><td></td></tr><tr><td>5.0</td><td>0.9309</td><td>1.0750</td><td></td></tr></tbody></table><hr><h2 id="六、结论"><a href="#六、结论" class="headerlink" title="六、结论"></a>六、结论</h2><p>自由杆下落更快！</p><p>但原因是什么呢</p><p>有没有能给我推导过程的QAQ</p><p>在线等~</p><hr><h2 id="附录：论AI目前为什么不能取代人类"><a href="#附录：论AI目前为什么不能取代人类" class="headerlink" title="附录：论AI目前为什么不能取代人类"></a>附录：论AI目前为什么不能取代人类</h2><p>请看vcr</p><p>1.《有固定点，小角度？那就是简谐运动！》————来自亲爱的deepseek</p><p><img src="/../images/deepseek%E4%BD%A0%E5%9C%A8%E5%B9%B2%E5%98%9B.jpg"></p><p>2.《什么是物理，我听不懂，倾斜的杆子就是不会掉下来，牛顿说啥我不管》 </p><p>————GPT5 plus大人！\0&#x2F;</p><p><img src="/../images/gpt%E5%A4%A7%E4%BA%BA%E6%98%AF%E4%BD%95%E6%84%8F%E4%B8%BA.jpg"></p><hr><p>建议加入ai笑话大全~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自由转动杆与铰链固定杆倾倒时间对比研究&quot;&gt;&lt;a href=&quot;#自由转动杆与铰链固定杆倾倒时间对比研究&quot; class=&quot;headerlink&quot; title=&quot;自由转动杆与铰链固定杆倾倒时间对比研究&quot;&gt;&lt;/a&gt;&lt;strong&gt;自由转动杆与铰链固定杆倾倒时间对比研究&lt;/</summary>
      
    
    
    
    <category term="编程" scheme="https://yifei-huang-cos.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>python网络编程--TCP篇</title>
    <link href="https://yifei-huang-cos.github.io/posts/8d64c14e/"/>
    <id>https://yifei-huang-cos.github.io/posts/8d64c14e/</id>
    <published>2026-01-26T02:00:19.000Z</published>
    <updated>2026-01-26T02:57:14.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP网络编程初步"><a href="#TCP网络编程初步" class="headerlink" title="TCP网络编程初步"></a>TCP网络编程初步</h1><p>在学习并发编程之前，先熟悉一个客户端与一个服务端</p><h2 id="TCP协议核心机制"><a href="#TCP协议核心机制" class="headerlink" title="TCP协议核心机制"></a>TCP协议核心机制</h2><p>TCP（传输控制协议）通过三次握手建立连接，通过四次挥手终止连接，确保数据传输的可靠性。</p><h2 id="服务端实现代码"><a href="#服务端实现代码" class="headerlink" title="服务端实现代码"></a>服务端实现代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 服务端的socket              IPV4           TCP</span></span><br><span class="line"><span class="comment"># 这个只负责接受客户端的连接请求</span></span><br><span class="line"></span><br><span class="line">server_socket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">8000</span>))</span><br><span class="line"><span class="comment"># 允许最大的等待个数</span></span><br><span class="line">server_socket.listen(<span class="number">128</span>)</span><br><span class="line"><span class="comment"># 接受客户端的连接</span></span><br><span class="line">socket2, client_addr = server_socket.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = socket2.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;来自客户端IP：<span class="subst">&#123;client_addr[<span class="number">0</span>]&#125;</span>,端口号<span class="subst">&#123;client_addr[<span class="number">1</span>]&#125;</span>:<span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 给客户端发送聊天信息</span></span><br><span class="line">    send_msg = <span class="built_in">input</span>(<span class="string">&#x27;server&gt;&gt;&#x27;</span>)</span><br><span class="line">    socket2.send(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">socket2.close()</span><br><span class="line">server_socket.close()</span><br></pre></td></tr></table></figure><h2 id="客户端实现代码"><a href="#客户端实现代码" class="headerlink" title="客户端实现代码"></a>客户端实现代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server_addr = (<span class="string">&#x27;192.168.100.199&#x27;</span>, <span class="number">8000</span>)</span><br><span class="line">client_socket.connect(server_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    send_msg = <span class="built_in">input</span>(<span class="string">&#x27;client&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> send_msg == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        client_socket.send(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    client_socket.send(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    msg = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;来自服务端IP：<span class="subst">&#123;server_addr[<span class="number">0</span>]&#125;</span>,端口号<span class="subst">&#123;server_addr[<span class="number">1</span>]&#125;</span>:<span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure><h2 id="TCP三次握手详解"><a href="#TCP三次握手详解" class="headerlink" title="TCP三次握手详解"></a>TCP三次握手详解</h2><p>三次握手是TCP建立连接的过程，确保双方都有发送和接收能力。</p><h3 id="第一次握手：SYN"><a href="#第一次握手：SYN" class="headerlink" title="第一次握手：SYN"></a>第一次握手：SYN</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 → SYN=1, seq=x → 服务端</span><br></pre></td></tr></table></figure><p>客户端发送SYN包，seq为随机数x，进入SYN_SENT状态。</p><h3 id="第二次握手：SYN-ACK"><a href="#第二次握手：SYN-ACK" class="headerlink" title="第二次握手：SYN+ACK"></a>第二次握手：SYN+ACK</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 ← SYN=1, ACK=1, seq=y, ack=x+1 ← 服务端</span><br></pre></td></tr></table></figure><p>服务端收到SYN，发送SYN+ACK包：</p><ul><li>seq为随机数y</li><li>ack为x+1（确认收到客户端的x）<br>服务端进入SYN_RCVD状态。</li></ul><h3 id="第三次握手：ACK"><a href="#第三次握手：ACK" class="headerlink" title="第三次握手：ACK"></a>第三次握手：ACK</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 → ACK=1, seq=x+1, ack=y+1 → 服务端</span><br></pre></td></tr></table></figure><p>客户端发送ACK包：</p><ul><li>seq为x+1</li><li>ack为y+1（确认收到服务端的y）<br>双方进入ESTABLISHED状态，连接建立。</li></ul><h3 id="代码中的三次握手"><a href="#代码中的三次握手" class="headerlink" title="代码中的三次握手"></a>代码中的三次握手</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端发起连接（第一次握手）</span></span><br><span class="line">client_socket.connect(server_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端接受连接（完成三次握手）</span></span><br><span class="line">socket2, client_addr = server_socket.accept()</span><br></pre></td></tr></table></figure><h2 id="TCP四次挥手详解"><a href="#TCP四次挥手详解" class="headerlink" title="TCP四次挥手详解"></a>TCP四次挥手详解</h2><p>四次挥手是TCP断开连接的过程，确保双方数据都传输完毕。</p><h3 id="第一次挥手：FIN"><a href="#第一次挥手：FIN" class="headerlink" title="第一次挥手：FIN"></a>第一次挥手：FIN</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 → FIN=1, seq=u → 服务端</span><br></pre></td></tr></table></figure><p>客户端发送FIN包，seq为u，进入FIN_WAIT_1状态。</p><h3 id="第二次挥手：ACK"><a href="#第二次挥手：ACK" class="headerlink" title="第二次挥手：ACK"></a>第二次挥手：ACK</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 ← ACK=1, seq=v, ack=u+1 ← 服务端</span><br></pre></td></tr></table></figure><p>服务端发送ACK包：</p><ul><li>ack为u+1（确认收到客户端的FIN）<br>服务端进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态。</li></ul><h3 id="第三次挥手：FIN"><a href="#第三次挥手：FIN" class="headerlink" title="第三次挥手：FIN"></a>第三次挥手：FIN</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 ← FIN=1, ACK=1, seq=w, ack=u+1 ← 服务端</span><br></pre></td></tr></table></figure><p>服务端发送FIN+ACK包，进入LAST_ACK状态。</p><h3 id="第四次挥手：ACK"><a href="#第四次挥手：ACK" class="headerlink" title="第四次挥手：ACK"></a>第四次挥手：ACK</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 → ACK=1, seq=u+1, ack=w+1 → 服务端</span><br></pre></td></tr></table></figure><p>客户端发送ACK包，进入TIME_WAIT状态（等待2MSL），服务端关闭连接。</p><h3 id="代码中的四次挥手"><a href="#代码中的四次挥手" class="headerlink" title="代码中的四次挥手"></a>代码中的四次挥手</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端发送quit（发起第一次挥手）</span></span><br><span class="line">client_socket.send(<span class="string">&#x27;quit&#x27;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端收到quit（第二次挥手）</span></span><br><span class="line">msg = socket2.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭套接字（完成挥手过程）</span></span><br><span class="line">socket2.close()</span><br><span class="line">server_socket.close()</span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure><h2 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h2><h3 id="建立连接状态"><a href="#建立连接状态" class="headerlink" title="建立连接状态"></a>建立连接状态</h3><ol><li>CLOSED：初始状态</li><li>SYN_SENT：客户端发送SYN后</li><li>LISTEN：服务端调用listen()后</li><li>SYN_RCVD：服务端收到SYN后</li><li>ESTABLISHED：连接建立完成</li></ol><h3 id="断开连接状态"><a href="#断开连接状态" class="headerlink" title="断开连接状态"></a>断开连接状态</h3><ol><li>FIN_WAIT_1：客户端第一次挥手</li><li>CLOSE_WAIT：服务端第一次收到FIN</li><li>FIN_WAIT_2：客户端收到ACK</li><li>LAST_ACK：服务端发送FIN</li><li>TIME_WAIT：客户端最后等待</li><li>CLOSED：连接完全关闭</li></ol><h2 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h2><h3 id="防止旧的重复连接初始化"><a href="#防止旧的重复连接初始化" class="headerlink" title="防止旧的重复连接初始化"></a>防止旧的重复连接初始化</h3><ul><li>避免网络延迟导致的旧连接干扰新连接</li><li>确保双方都知道对方准备好了</li></ul><h3 id="同步序列号"><a href="#同步序列号" class="headerlink" title="同步序列号"></a>同步序列号</h3><ul><li>交换初始序列号（ISN）</li><li>确保数据按序传输</li></ul><h3 id="确认双方能力"><a href="#确认双方能力" class="headerlink" title="确认双方能力"></a>确认双方能力</h3><ul><li>确认双方都有发送和接收能力</li><li>协商窗口大小等参数</li></ul><h2 id="为什么需要四次挥手？"><a href="#为什么需要四次挥手？" class="headerlink" title="为什么需要四次挥手？"></a>为什么需要四次挥手？</h2><h3 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h3><ul><li>TCP是全双工的，可以单向关闭</li><li>服务端可能还有数据要发送</li></ul><h3 id="确保数据完整性"><a href="#确保数据完整性" class="headerlink" title="确保数据完整性"></a>确保数据完整性</h3><ul><li>等待所有数据都传输完毕</li><li>确保没有数据丢失</li></ul><h3 id="可靠终止"><a href="#可靠终止" class="headerlink" title="可靠终止"></a>可靠终止</h3><ul><li>双方都知道连接要关闭了</li><li>防止数据包在网络中”迷路”</li></ul><h2 id="TIME-WAIT状态的作用"><a href="#TIME-WAIT状态的作用" class="headerlink" title="TIME_WAIT状态的作用"></a>TIME_WAIT状态的作用</h2><h3 id="等待2MSL的原因"><a href="#等待2MSL的原因" class="headerlink" title="等待2MSL的原因"></a>等待2MSL的原因</h3><ol><li><strong>确保最后一个ACK到达</strong>：如果服务端没收到ACK会重发FIN</li><li><strong>让旧连接的数据包消失</strong>：防止影响新连接</li><li><strong>MSL（Maximum Segment Lifetime）</strong>：报文最大生存时间</li></ol><h2 id="实际编程中的影响"><a href="#实际编程中的影响" class="headerlink" title="实际编程中的影响"></a>实际编程中的影响</h2><h3 id="连接建立失败"><a href="#连接建立失败" class="headerlink" title="连接建立失败"></a>连接建立失败</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    client_socket.connect(server_addr)</span><br><span class="line"><span class="keyword">except</span> ConnectionRefusedError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;连接被拒绝：服务端未启动或端口错误&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="端口复用问题"><a href="#端口复用问题" class="headerlink" title="端口复用问题"></a>端口复用问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 避免Address already in use错误</span></span><br><span class="line">server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 半关闭：关闭发送，仍可接收</span></span><br><span class="line">client_socket.shutdown(socket.SHUT_WR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待对方关闭</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>三次握手建立可靠连接，四次挥手优雅终止连接，这是TCP协议的核心机制。理解这些过程对于调试网络问题和编写稳定的网络程序非常重要。</p><hr><p><em>在代码中，connect()触发三次握手，close()触发四次挥手，这些细节都由操作系统自动处理。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP网络编程初步&quot;&gt;&lt;a href=&quot;#TCP网络编程初步&quot; class=&quot;headerlink&quot; title=&quot;TCP网络编程初步&quot;&gt;&lt;/a&gt;TCP网络编程初步&lt;/h1&gt;&lt;p&gt;在学习并发编程之前，先熟悉一个客户端与一个服务端&lt;/p&gt;
&lt;h2 id=&quot;TCP协议</summary>
      
    
    
    
    <category term="编程" scheme="https://yifei-huang-cos.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>UDP的简易实现</title>
    <link href="https://yifei-huang-cos.github.io/posts/35e240ca/"/>
    <id>https://yifei-huang-cos.github.io/posts/35e240ca/</id>
    <published>2026-01-23T01:00:06.000Z</published>
    <updated>2026-01-26T02:57:14.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PYTHON网络编程——UDP篇"><a href="#PYTHON网络编程——UDP篇" class="headerlink" title="PYTHON网络编程——UDP篇"></a>PYTHON网络编程——UDP篇</h1><h2 id="一、UDP简介"><a href="#一、UDP简介" class="headerlink" title="一、UDP简介"></a>一、UDP简介</h2><h3 id="什么是UDP？"><a href="#什么是UDP？" class="headerlink" title="什么是UDP？"></a>什么是UDP？</h3><p>UDP（用户数据报协议）是一种无连接的传输层协议，具有以下特点：</p><ul><li>无需建立连接</li><li>不可靠传输（可能丢包）</li><li>传输速度快</li><li>适合实时性要求高的场景</li></ul><h3 id="基本流程对比"><a href="#基本流程对比" class="headerlink" title="基本流程对比"></a>基本流程对比</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP编程流程：创建socket → 绑定 → 监听 → 接受连接 → 收发数据 → 关闭</span><br><span class="line">UDP编程流程：创建socket → 绑定（服务端）→ 直接收发数据 → 关闭</span><br></pre></td></tr></table></figure><h2 id="二、服务端代码详解"><a href="#二、服务端代码详解" class="headerlink" title="二、服务端代码详解"></a>二、服务端代码详解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建了一个UDP的socket对象</span></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># socket.AF_INET: 使用IPv4地址族</span></span><br><span class="line"><span class="comment"># socket.SOCK_DGRAM: 使用UDP协议（数据报套接字）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前一个是我的ipv4地址，如果用127.0.0.1则是在本地</span></span><br><span class="line"><span class="comment"># 如果是空字符，服务端绑定到所有的ip地址</span></span><br><span class="line">server_socket.bind((<span class="string">&#x27;192.168.100.199&#x27;</span>, <span class="number">6666</span>))</span><br><span class="line"><span class="comment"># bind()方法将套接字绑定到指定地址和端口</span></span><br><span class="line"><span class="comment"># &#x27;192.168.100.199&#x27;: 绑定到特定局域网IP</span></span><br><span class="line"><span class="comment"># 其他选择：</span></span><br><span class="line"><span class="comment">#   &#x27;127.0.0.1&#x27;: 本地回环，只能本机访问</span></span><br><span class="line"><span class="comment">#   &#x27;0.0.0.0&#x27;: 绑定所有网络接口</span></span><br><span class="line"><span class="comment">#   &#x27;&#x27;: 同&#x27;0.0.0.0&#x27;</span></span><br><span class="line"><span class="comment"># 6666: 端口号，范围0-65535（0-1023为系统保留）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># msg是收到的数据，addr是源地址和端口号</span></span><br><span class="line">    msg, addr = server_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># recvfrom()是阻塞方法，会一直等待直到收到数据</span></span><br><span class="line">    <span class="comment"># 1024: 缓冲区大小，单位字节</span></span><br><span class="line">    <span class="comment"># msg: 接收到的字节数据</span></span><br><span class="line">    <span class="comment"># addr: 元组 (客户端IP, 客户端端口)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> msg.decode(<span class="string">&#x27;utf8&#x27;</span>) == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 如果客户端发送&#x27;quit&#x27;，则退出循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;来自IP：<span class="subst">&#123;addr[<span class="number">0</span>]&#125;</span>,端口号：<span class="subst">&#123;addr[<span class="number">1</span>]&#125;</span>的消息：<span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 显示消息来源和内容</span></span><br><span class="line"></span><br><span class="line">    send_msg = <span class="built_in">input</span>(<span class="string">&#x27;服务端&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 等待用户输入回复内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不能发送字符串，应该是字节数据</span></span><br><span class="line">    server_socket.sendto(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>), addr)</span><br><span class="line">    <span class="comment"># sendto()发送数据到指定地址</span></span><br><span class="line">    <span class="comment"># encode(&#x27;utf8&#x27;): 将字符串转为字节数据</span></span><br><span class="line">    <span class="comment"># addr: 目标地址（这里发回给原客户端）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># close</span></span><br><span class="line">server_socket.close()</span><br><span class="line"><span class="comment"># 关闭套接字，释放资源</span></span><br></pre></td></tr></table></figure><h2 id="三、客户端代码详解"><a href="#三、客户端代码详解" class="headerlink" title="三、客户端代码详解"></a>三、客户端代码详解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建了一个UDP的socket对象</span></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端socket不用bind</span></span><br><span class="line"><span class="comment"># 客户端通常由系统自动分配端口号</span></span><br><span class="line"><span class="comment"># 如果需要绑定特定端口，也可以使用bind()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># send msg</span></span><br><span class="line">    send_msg = <span class="built_in">input</span>(<span class="string">&#x27;客户端&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> send_msg == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 输入&#x27;quit&#x27;退出</span></span><br><span class="line">    </span><br><span class="line">    client_socket.sendto(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>), (<span class="string">&#x27;192.168.100.199&#x27;</span>, <span class="number">6666</span>))</span><br><span class="line">    <span class="comment"># 发送数据到服务器</span></span><br><span class="line">    <span class="comment"># (&#x27;192.168.100.199&#x27;, 6666): 服务器地址和端口</span></span><br><span class="line">    <span class="comment"># 必须与服务器绑定的地址一致</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># receive msg</span></span><br><span class="line">    msg, addr = client_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 等待服务器回复</span></span><br><span class="line">    <span class="comment"># 注意：这里会阻塞，直到收到服务器响应</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;来自服务端IP：<span class="subst">&#123;addr[<span class="number">0</span>]&#125;</span>,端口号：<span class="subst">&#123;addr[<span class="number">1</span>]&#125;</span>的消息：<span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 显示服务器回复</span></span><br><span class="line"></span><br><span class="line">client_socket.close()</span><br><span class="line"><span class="comment"># 关闭客户端套接字</span></span><br></pre></td></tr></table></figure><h2 id="四、关键知识点"><a href="#四、关键知识点" class="headerlink" title="四、关键知识点"></a>四、关键知识点</h2><h3 id="1-UDP套接字创建"><a href="#1-UDP套接字创建" class="headerlink" title="1. UDP套接字创建"></a>1. UDP套接字创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br></pre></td></tr></table></figure><ul><li><code>AF_INET</code>: IPv4地址族</li><li><code>SOCK_DGRAM</code>: UDP数据报类型</li></ul><h3 id="2-地址绑定"><a href="#2-地址绑定" class="headerlink" title="2. 地址绑定"></a>2. 地址绑定</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端必须绑定，客户端可选</span></span><br><span class="line">server_socket.bind((IP地址, 端口号))</span><br></pre></td></tr></table></figure><h3 id="3-数据收发"><a href="#3-数据收发" class="headerlink" title="3. 数据收发"></a>3. 数据收发</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接收数据（返回数据和来源地址）</span></span><br><span class="line">data, addr = socket.recvfrom(缓冲区大小)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送数据到指定地址</span></span><br><span class="line">socket.sendto(字节数据, (目标IP, 目标端口))</span><br></pre></td></tr></table></figure><h3 id="4-编码转换"><a href="#4-编码转换" class="headerlink" title="4. 编码转换"></a>4. 编码转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送：字符串 → 字节</span></span><br><span class="line">send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收：字节 → 字符串</span></span><br><span class="line">msg.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h2><ol><li><p><strong>UDP是无连接的</strong></p><ul><li>每次发送都要指定目标地址</li><li>不保证数据顺序和可靠性</li></ul></li><li><p><strong>地址和端口</strong></p><ul><li>服务端需要固定端口</li><li>客户端端口通常由系统分配</li></ul></li><li><p><strong>数据大小</strong></p><ul><li>UDP数据包不宜过大（通常&lt;1500字节）</li><li>避免IP分片，提高传输效率</li></ul></li><li><p><strong>阻塞问题</strong></p><ul><li><code>recvfrom()</code>是阻塞调用</li><li>程序会等待直到收到数据</li></ul></li><li><p><strong>多客户端处理</strong></p><ul><li>UDP服务端可以同时处理多个客户端</li><li>通过addr区分不同客户端</li></ul></li></ol><h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><h3 id="Q1-为什么客户端不需要bind？"><a href="#Q1-为什么客户端不需要bind？" class="headerlink" title="Q1: 为什么客户端不需要bind？"></a>Q1: 为什么客户端不需要bind？</h3><p>A: 客户端第一次调用sendto()时，系统会自动分配一个可用端口。</p><h3 id="Q2-如果服务器没启动，客户端会怎样？"><a href="#Q2-如果服务器没启动，客户端会怎样？" class="headerlink" title="Q2: 如果服务器没启动，客户端会怎样？"></a>Q2: 如果服务器没启动，客户端会怎样？</h3><p>A: 客户端发送的数据会丢失，recvfrom()会一直等待（阻塞）。</p><h3 id="Q3-如何测试本机通信？"><a href="#Q3-如何测试本机通信？" class="headerlink" title="Q3: 如何测试本机通信？"></a>Q3: 如何测试本机通信？</h3><p>A: 服务端绑定<code>127.0.0.1</code>，客户端连接<code>127.0.0.1</code>。</p><h3 id="Q4-如何让其他电脑连接？"><a href="#Q4-如何让其他电脑连接？" class="headerlink" title="Q4: 如何让其他电脑连接？"></a>Q4: 如何让其他电脑连接？</h3><p>A: </p><ol><li>服务端绑定<code>0.0.0.0</code>或局域网IP</li><li>关闭防火墙或开放对应端口</li><li>客户端使用服务器实际IP地址</li></ol><h2 id="七、完整的UDP还需要"><a href="#七、完整的UDP还需要" class="headerlink" title="七、完整的UDP还需要"></a>七、完整的UDP还需要</h2><ol><li><strong>异常处理</strong>：添加try-except处理网络错误</li><li><strong>超时设置</strong>：使用settimeout()避免永久阻塞</li><li><strong>多线程</strong>：同时处理多个客户端请求</li><li><strong>数据验证</strong>：添加简单的协议头验证数据完整性</li></ol><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>​      UDP编程的核心模式：</p><ul><li>服务端：创建→绑定→循环收发→关闭</li><li>客户端：创建→循环收发→关闭</li></ul><p>这种简单的请求-响应模式是UDP编程的基础，理解了这种模式后，可以在此基础上构建更复杂的UDP应用。</p><hr><p><em>注：实际使用时，请确保服务端和客户端的IP地址和端口号配置正确，防火墙已开放相应端口。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PYTHON网络编程——UDP篇&quot;&gt;&lt;a href=&quot;#PYTHON网络编程——UDP篇&quot; class=&quot;headerlink&quot; title=&quot;PYTHON网络编程——UDP篇&quot;&gt;&lt;/a&gt;PYTHON网络编程——UDP篇&lt;/h1&gt;&lt;h2 id=&quot;一、UDP简介&quot;&gt;</summary>
      
    
    
    
    <category term="编程" scheme="https://yifei-huang-cos.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>如何用hexo搭建个人博客</title>
    <link href="https://yifei-huang-cos.github.io/posts/cd1cb590/"/>
    <id>https://yifei-huang-cos.github.io/posts/cd1cb590/</id>
    <published>2026-01-21T03:12:12.000Z</published>
    <updated>2026-01-26T02:57:14.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-博客搭建与配置指南"><a href="#Hexo-博客搭建与配置指南" class="headerlink" title="Hexo 博客搭建与配置指南"></a>Hexo 博客搭建与配置指南</h1><h2 id="📖-简介"><a href="#📖-简介" class="headerlink" title="📖 简介"></a>📖 简介</h2><p>Hexo 是一个快速、简洁且高效的静态博客框架。它使用 Markdown解析文章，在几秒内即可生成静态网页。本指南将帮助您快速搭建并配置一个 Hexo 博客。</p><h2 id="🚀-快速开始"><a href="#🚀-快速开始" class="headerlink" title="🚀 快速开始"></a>🚀 快速开始</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p><strong>安装 Node.js</strong></p><ul><li>版本要求：Node.js 14.0 或以上版本</li><li>下载地址：<a href="https://nodejs.org/">Node.js 官网</a></li></ul></li><li><p><strong>安装 Git</strong></p><ul><li>下载地址：<a href="https://git-scm.com/">Git 官网</a></li></ul></li></ol><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>打开终端（命令提示符）并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init my-blog</span><br><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"><span class="comment"># 生成：</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 预览： （浏览器访问 `http://localhost:4000` 查看效果）</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="comment"># 部署：</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="⚙️-基本配置"><a href="#⚙️-基本配置" class="headerlink" title="⚙️ 基本配置"></a>⚙️ 基本配置</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>博客的主要配置文件为 <code>_config.yml</code>，位于博客根目录下。</p><h3 id="常用配置项"><a href="#常用配置项" class="headerlink" title="常用配置项"></a>常用配置项</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网站信息</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">我的博客</span>                    <span class="comment"># 网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span>                       <span class="comment"># 网站副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span>                    <span class="comment"># 网站描述</span></span><br><span class="line"><span class="attr">keywords:</span>                         <span class="comment"># 网站关键词</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">作者名</span>                     <span class="comment"># 作者名称</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>                   <span class="comment"># 语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span>                      <span class="comment"># 时区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL 设置</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com</span>          <span class="comment"># 网站地址</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span>                           <span class="comment"># 网站根目录</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>  <span class="comment"># 文章永久链接格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目录设置</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span>                <span class="comment"># 资源文件夹</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span>                <span class="comment"># 静态文件生成目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写作设置</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span>          <span class="comment"># 新文章文件名格式</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span>              <span class="comment"># 默认布局</span></span><br></pre></td></tr></table></figure><h2 id="🎨-主题安装与配置"><a href="#🎨-主题安装与配置" class="headerlink" title="🎨 主题安装与配置"></a>🎨 主题安装与配置</h2><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>以我所使用的stellar 主题为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/stellar-theme/hexo-theme-syellar themes/stellar</span><br></pre></td></tr></table></figure><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>修改 <code>_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">stellar</span></span><br></pre></td></tr></table></figure><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>主题有自己的配置文件 <code>themes/stellar/_config.yml</code>，可进行个性化设置。</p><h2 id="📝-写作与发布"><a href="#📝-写作与发布" class="headerlink" title="📝 写作与发布"></a>📝 写作与发布</h2><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure><p>文章文件位于 <code>source/_posts/文章标题.md</code></p><h3 id="文章-Front-matter"><a href="#文章-Front-matter" class="headerlink" title="文章 Front-matter"></a>文章 Front-matter</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 2024-05-20 10:00:00</span><br><span class="line">tags: [标签1, 标签2]</span><br><span class="line"><span class="section">categories: 分类名</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><code>hexo new [layout] &lt;title&gt;</code> - 新建文章</li><li><code>hexo clean</code> - 清除缓存</li><li><code>hexo generate</code> 或 <code>hexo g</code> - 生成静态文件</li><li><code>hexo server</code> 或 <code>hexo s</code> - 启动本地服务器</li><li><code>hexo deploy</code> 或 <code>hexo d</code> - 部署到远程仓库</li></ul><h2 id="🌐-部署到-GitHub-Pages"><a href="#🌐-部署到-GitHub-Pages" class="headerlink" title="🌐 部署到 GitHub Pages"></a>🌐 部署到 GitHub Pages</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>创建 GitHub 仓库，命名为 <code>用户名.github.io</code></li><li>安装部署插件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="配置部署"><a href="#配置部署" class="headerlink" title="配置部署"></a>配置部署</h3><p>修改 <code>_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><h3 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h2 id="🔧-常用插件"><a href="#🔧-常用插件" class="headerlink" title="🔧 常用插件"></a>🔧 常用插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSS 订阅</span></span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点地图</span></span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章搜索</span></span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章字数统计</span></span><br><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><h2 id="💡-实用技巧"><a href="#💡-实用技巧" class="headerlink" title="💡 实用技巧"></a>💡 实用技巧</h2><h3 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><h3 id="草稿功能"><a href="#草稿功能" class="headerlink" title="草稿功能"></a>草稿功能</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft <span class="string">&quot;草稿标题&quot;</span></span><br><span class="line">hexo publish <span class="string">&quot;草稿标题&quot;</span></span><br></pre></td></tr></table></figure><h3 id="图片引用"><a href="#图片引用" class="headerlink" title="图片引用"></a>图片引用</h3><ol><li>将图片放入 <code>source/images/</code> 目录</li><li>在文章中引用：</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片描述</span>](<span class="link">/images/图片文件名.jpg</span>)</span><br></pre></td></tr></table></figure><h2 id="🛠️-故障排除"><a href="#🛠️-故障排除" class="headerlink" title="🛠️ 故障排除"></a>🛠️ 故障排除</h2><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li><p><strong>部署失败</strong></p><ul><li>检查 Git 配置</li><li>确认仓库地址正确</li><li>检查网络连接</li></ul></li><li><p><strong>页面无法加载</strong></p><ul><li>运行 <code>hexo clean</code></li><li>重新生成和启动服务器</li></ul></li><li><p><strong>主题不生效</strong></p><ul><li>确认主题文件夹名称正确</li><li>检查 <code>_config.yml</code> 中 theme 配置</li></ul></li></ol><h2 id="📚-学习资源"><a href="#📚-学习资源" class="headerlink" title="📚 学习资源"></a>📚 学习资源</h2><ul><li><a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a></li><li><a href="https://github.com/hexojs/hexo">Hexo GitHub</a></li><li><a href="https://theme-next.js.org/">Next 主题文档</a></li></ul><hr><blockquote><p><strong>提示</strong>：配置时建议备份原配置文件，每次只修改少量配置并测试效果。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo-博客搭建与配置指南&quot;&gt;&lt;a href=&quot;#Hexo-博客搭建与配置指南&quot; class=&quot;headerlink&quot; title=&quot;Hexo 博客搭建与配置指南&quot;&gt;&lt;/a&gt;Hexo 博客搭建与配置指南&lt;/h1&gt;&lt;h2 id=&quot;📖-简介&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
</feed>
