<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黄逸飞的个人博客</title>
  
  
  <link href="https://yifei-huang-cos.github.io/atom.xml" rel="self"/>
  
  <link href="https://yifei-huang-cos.github.io/"/>
  <updated>2026-01-28T03:09:23.205Z</updated>
  <id>https://yifei-huang-cos.github.io/</id>
  
  <author>
    <name>黄逸飞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>杀戮尖塔设计拆解————数值篇</title>
    <link href="https://yifei-huang-cos.github.io/posts/eff9c8a5/"/>
    <id>https://yifei-huang-cos.github.io/posts/eff9c8a5/</id>
    <published>2026-01-28T02:00:00.000Z</published>
    <updated>2026-01-28T03:09:23.205Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《杀戮尖塔》数值设计深度拆解"><a href="#《杀戮尖塔》数值设计深度拆解" class="headerlink" title="《杀戮尖塔》数值设计深度拆解"></a>《杀戮尖塔》数值设计深度拆解</h1><p>​在卡牌与Roguelike融合的游戏品类中，《杀戮尖塔》的成功离不开其精妙且恰到好处的数值设计。作为一款策略类，以决策为核心乐趣的游戏，它不依靠华丽的特效或复杂的剧情，而是通过能量、卡牌、遗物、难度等多维度的数值平衡，构建了“战斗-奖励-提升”的数值循环与“费用-收益”匹配的价值曲线，最终形成既充满随机性又具备可控策略空间的体验闭环。</p><p>​我累计500余小时的攀登历程中，深刻感受到每一处数值细节都暗藏策划巧思，下文将结合参考文章的权威数值体系，从核心资源价值、卡牌数值架构、遗物联动逻辑、难度平衡设计四个核心维度，拆解其数值设计的精髓。</p><h2 id="一、核心资源数值（能量）：作为抉择基石"><a href="#一、核心资源数值（能量）：作为抉择基石" class="headerlink" title="一、核心资源数值（能量）：作为抉择基石"></a>一、核心资源数值（能量）：作为抉择基石</h2><p>​《杀戮尖塔》的战斗数值体系中，每回合的能量是贯穿始终的核心约束变量，其数值设定直接决定了策略决策的深度，且存在明确的价值量化标准。游戏初始默认单回合能量上限为3点（部分职遗物可提升），能量存在固定价值曲线：0点能量基础价值为3，之后每增加1点能量额外提供2点价值，这一量化标准构成了卡牌设计的核心基准，而非简单的“3点约束”。这一数值体系实则构建了“攻击-防御-能量-运转”的四维策略平衡，迫使玩家在每回合进行精准的资源分配与机会成本权衡。</p><h5 id="1-1-从设计意图来看："><a href="#1-1-从设计意图来看：" class="headerlink" title="1.1 从设计意图来看："></a>1.1 从设计意图来看：</h5><p>​初始3点能量的数值设定是价值曲线与策略深度的最优解：若能量过多，玩家可同时触发多个高价值连携效果，策略抉择的价值会大幅降低；若能量过少，则无法支撑基础连携的触发，破坏卡组运转流畅度。3点能量恰好让玩家每回合需在基础输入+单一乘区或者多乘区组合但基础输入弱化等策略中抉择。</p><p>​例如面对一层精英敌人乐嘉（额这是外号，具体名字不记得了QAQ）即将到来的高额攻击，玩家需在1费防御（5格挡，价值匹配）+2费攻击（打击1费打6）与2费防御（初始防御1费5格挡）+1费运转（抽牌调整手牌）之间权衡，而这种抉择直接关联生命值资源的消耗与留存，正是数值驱动策略乐趣的核心来源。</p><p>​值得注意的是，即使是0费卡牌也存在隐性成本，其占用的抽牌位会导致错过其他关键卡牌，这一机会成本同样被纳入能量价值体系的考量范畴。</p><h5 id="1-2-能量数值的弹性设计进一步丰富了策略维度："><a href="#1-2-能量数值的弹性设计进一步丰富了策略维度：" class="headerlink" title="1.2 能量数值的弹性设计进一步丰富了策略维度："></a>1.2 能量数值的弹性设计进一步丰富了策略维度：</h5><p>​游戏通过融合之锤（boss遗物）孙子兵法（普通遗物）等遗物提供能量加成，例如孙子兵法的设定是：如果不使用攻击卡下回合+1能量，本质是通过策略选择换取能量价值的提升（额外获得2点基础价值）；而许多boss遗物通过支付某些特定代价（例如锤子：火堆无法升级牌；绿帽：无法获得金币）换取每回合稳定多一费。这种代价支付加稳定收益的数值设计，既保证了体系的稳定性，又为流派构建提供了多样化可能。</p><h2 id="二、卡牌数值体系（费效比）：精准定位与价值平衡"><a href="#二、卡牌数值体系（费效比）：精准定位与价值平衡" class="headerlink" title="二、卡牌数值体系（费效比）：精准定位与价值平衡"></a>二、卡牌数值体系（费效比）：精准定位与价值平衡</h2><p>​卡牌是玩家实现策略意图的核心载体，《杀戮尖塔》的卡牌数值设计遵循：卡组定位、费效比、联动组件三大原则，核心逻辑是以能量价值为基准，构建‘基础输入-乘区放大-导出转化’的强度公式，确保不同类型、不同费用的卡牌在性价比上保持平衡，同时尽可能避免策略单一化，掩盖其他玩法的问题。单张卡牌效果普遍简洁，仅提供基础输入或单一乘区，需通过组合形成强大连携，这既降低了玩家记忆成本，又提升了策略深度。</p><h6 id="2-1-插一句设计缺陷："><a href="#2-1-插一句设计缺陷：" class="headerlink" title="2.1 插一句设计缺陷："></a>2.1 插一句设计缺陷：</h6><p>​（上一段所说的避免策略单一化只在前两个职业，即战士和猎人上完成的较为完美，而我们鸡煲，呃呃，懂得都懂，问就是还在启动，在启动。观者的设计则是严重不平衡，暴怒带来的双倍伤害让其很多职业卡的费效比不尽人意，红蓝无限的玩法带来的收益又过于超模，掩盖了观者的神格预见点穴等体系。虽说这几个体系本来也有数值不足的问题。只能说观者的出现，对玩家来说可能是玩起来比较容易爽的角色，但从数值设计的角度看，无疑是失败的）</p><h5 id="2-2在攻击卡牌设计中："><a href="#2-2在攻击卡牌设计中：" class="headerlink" title="2.2在攻击卡牌设计中："></a>2.2在攻击卡牌设计中：</h5><p>​数值严格匹配能量价值曲线，且通过“基础输入+乘区”的组合形成差异化定位。</p><p>​例如1费的打击基础伤害为6点（价值2，匹配1费能量价值5中的基础部分），2费的重击伤害为14点且附带3倍力量加成（价值5+2，2费能量价值7完全匹配），而非简单的倍数关系；0费的愤怒可造成6点伤害并在弃牌堆放入一张自身，收益为2+1（额外留存卡牌资源），精准匹配0费能量3点的基础价值。</p><p>​不同卡牌的乘区特性适配不同流派：战士的重击依赖力量乘区实现爆发输出，静默猎手的0费小刀则通过多次攻击乘区触发精准，袖箭等被动效果，成为小刀流的核心输入组件。这种设计让低费卡并非弱卡，而是适配高频连击流派，高费卡则需放弃当回合其他资源，形成明确的机会成本权衡。</p><h5 id="2-3-防御卡牌的数值设计同样遵循价值曲线，且聚焦临时防护。"><a href="#2-3-防御卡牌的数值设计同样遵循价值曲线，且聚焦临时防护。" class="headerlink" title="2.3 防御卡牌的数值设计同样遵循价值曲线，且聚焦临时防护。"></a>2.3 防御卡牌的数值设计同样遵循价值曲线，且聚焦临时防护。</h5><p>​游戏将格挡设定为临时性防御资源，没有特殊卡牌和遗物的情况下防御不会保留，1点格挡等价于1点生命值。</p><p>​例如1费的初始卡防御提供5点格挡（价值匹配1费能量），2费的稀有卡岿然不动提供30点格挡，但是是消耗卡，不能够反复利用。玩家可根据敌方伤害数值选择合适的防御卡牌：面对小额持续伤害，优先使用低费防御卡节省能量；面对大额单次伤害，则需投入高费防御卡或组合多张防御卡。</p><p>​更关键的是，防御维度可通过特定卡牌转化为攻击强度，例如战士的肚皮（全身撞击，未升级是1费，升级后变成0费）可造成当前格挡值的攻击伤害，将防御资源转化为输出输入，这一设计打破了维度壁垒，让“高防御+高输出”的防战流派成为可能。而能力卡壁垒可以保留格挡值的设定，更是强化了防御乘区的效果，让格挡资源可跨回合累积，催生格挡转伤害的防御流派。</p><h5 id="2-4-卡牌升级的数值提升也严格匹配价值均衡原则。"><a href="#2-4-卡牌升级的数值提升也严格匹配价值均衡原则。" class="headerlink" title="2.4 卡牌升级的数值提升也严格匹配价值均衡原则。"></a>2.4 卡牌升级的数值提升也严格匹配价值均衡原则。</h5><p>​例如打击升级后伤害从6提升至9（提升幅度50%），防御升级后格挡从5提升至8（提升幅度60%），升级后的价值仍与能量费用精准匹配，既让升级后的卡牌具备明显优势，又不会让未升级卡牌完全失效。这一设计确保玩家在升级卡牌与回复生命的火堆处选择中产生策略博弈——是提升长期战力以减少后续生命值消耗，还是保证当前生存以规避即时风险？这种博弈让每一次火堆选择都成为影响数值循环的关键决策。</p><h2 id="三、遗物数值联动：打破基础规则的策略裂变引擎"><a href="#三、遗物数值联动：打破基础规则的策略裂变引擎" class="headerlink" title="三、遗物数值联动：打破基础规则的策略裂变引擎"></a>三、遗物数值联动：打破基础规则的策略裂变引擎</h2><p>​遗物系统是《杀戮尖塔》数值设计的点睛之笔，其核心价值在于通过“数值加成+机制改变”的组合，优化卡组的体系，催生多样化的流派构建。遗物的数值设计并非简单的数值堆砌，而是精准匹配卡牌的连携逻辑，同时服务于“战斗-奖励-提升”的数值循环（因为遗物通常由精英怪掉落，而打精英怪可能面临生存危险，你说是吧鸡煲TvT（还在启动，在启动，启动，启…）），与卡牌体系形成约束和强化的联动闭环——没有合适的卡牌组合，遗物的数值优势无法发挥；缺少遗物的数值加持，卡牌组合也难以形成质变。</p><h5 id="3-1普通遗物：补充短板和优化体验为主"><a href="#3-1普通遗物：补充短板和优化体验为主" class="headerlink" title="3.1普通遗物：补充短板和优化体验为主"></a>3.1普通遗物：补充短板和优化体验为主</h5><p>​战士的初始遗物“燃烧之血”效果是战斗后回血6点，解决了前期回血资源稀缺的问题，让玩家可更激进地挑战战斗；普通遗物背包的效果是第一轮多抽2张牌，提升关键牌上手率，降低第一轮的鬼抽概率；还有商店遗物工具箱，棱镜，前者可以每场战斗3选1一张无色牌，就冲着能选到神话和打钱手这也是必买遗物，而棱镜则打破职业卡限制，让选择里多出其他职业的职业卡，可能会选出梦寐以求的配合（鸡煲：我要学猛虎下山！）。这些数值设计虽看似微小，但能显著优化特定职业的前期体验，引导玩家向职业核心流派靠拢。</p><h5 id="3-2罕见遗物与Boss遗物则通过数值质变和机制突破催生全新策略，同时兼顾对单一策略的抑制"><a href="#3-2罕见遗物与Boss遗物则通过数值质变和机制突破催生全新策略，同时兼顾对单一策略的抑制" class="headerlink" title="3.2罕见遗物与Boss遗物则通过数值质变和机制突破催生全新策略，同时兼顾对单一策略的抑制"></a>3.2罕见遗物与Boss遗物则通过数值质变和机制突破催生全新策略，同时兼顾对单一策略的抑制</h5><p>​例如钢笔尖设定“每第十张攻击造成双倍伤害，将“低费复用输出的运转转化为攻击乘区，引导玩家调整高费攻击卡排序；蛇眼作为boss遗物，效果是每回合多抽2张，但所有卡牌的费用会从0到3费随机，解决了过牌问题，也让玩家多抓高费卡少带低费卡；而针对飞身踢无限等可能导致策略退化的玩法，游戏通过数值限制进行平衡——飞身踢基础伤害仅5点（低于初始打击的6点），且需目标有易伤效果才能打出，提升了连携成本；同时Boss“时间吞噬者”设定玩家每打出12张牌后强制结束回合，从机制上限制低数值无限的强度（比如亮剑【0费打3抽1】妙计【0费防2抽1】相互抽的低数值无限），确保各流派的平衡。</p><h2 id="四、难度梯度数值：动态平衡的“学习型”挑战曲线"><a href="#四、难度梯度数值：动态平衡的“学习型”挑战曲线" class="headerlink" title="四、难度梯度数值：动态平衡的“学习型”挑战曲线"></a>四、难度梯度数值：动态平衡的“学习型”挑战曲线</h2><p>​《杀戮尖塔》的进阶等级系统是其数值难度设计的核心，最高20级的进阶梯度并非简单提升敌人血量与伤害，而是通过“精准数值微调+规则约束增加”的方式，扰动核心数值循环，构建平滑且富有深度的学习型挑战曲线。其设计逻辑与玩家策略成长相匹配，低进阶等级调整普通敌人数值，引导玩家熟悉卡牌与遗物的基础连携；高进阶等级则通过规则约束强化数值压力，迫使玩家优化卡组构建策略。</p><h5 id="4-1进阶难度的数值设计"><a href="#4-1进阶难度的数值设计" class="headerlink" title="4.1进阶难度的数值设计"></a>4.1进阶难度的数值设计</h5><p>​遵循蝴蝶效应原则，通过微小的数值调整引发策略连锁反应。例如进阶17后，二层普通敌人三鸟的坠机条件从受击3次变为受击4次，看似仅增加1次受击需求，却直接提升了对运转维度与攻击频率的要求（经典是观者的发泄，不敲三段伤害，敲了4段伤害，在低进阶一个发泄就可以把三鸟肘下来，在高进阶则刚需升级）——低费高频攻击卡组需多花费1回合才能击落，可能导致暴露在敌方多轮攻击下，增加生命值消耗。</p><p>​而进阶20中，普通敌人壳爹＋蘑菇（开幕21和他的易伤药，已经畏惧了 …）第一回合伤害从18点提升至21点并附加脆弱Debuff），这一调整直接放大了防御维度的价值缺口，迫使玩家必须在前期就构建足够的防御体系，否则极易血量崩盘。这种差一点就通关的数值设计，既不会让玩家产生挫败感，又能推动玩家深化对数值体系的理解，优化策略决策以适配更严苛的数值循环。</p><h5 id="4-2高进阶等级的规则约束"><a href="#4-2高进阶等级的规则约束" class="headerlink" title="4.2高进阶等级的规则约束"></a>4.2高进阶等级的规则约束</h5><p>​进阶10后，玩家初始生命上限减少，这一数值调整直接提升了前期生命值资源的稀缺性，让血量管理成为核心决策点，同时放大了燃烧血、羽毛、梨子、华夫饼等回血与生命上限提升类遗物的价值（当然丢人枕头除外）；进阶15后“商店卡牌价格提升”，则扰动了经济数值循环，迫使玩家更谨慎地分配金币资源，优先选择移除低价值初始卡牌（指打击）而非盲目购买新卡。、</p><p>​这些设计形成了难度约束与策略适配的动态平衡，确保玩家在提升技巧的同时，始终能获得匹配的挑战体验。</p><h2 id="结语：数值驱动的策略乐趣闭环"><a href="#结语：数值驱动的策略乐趣闭环" class="headerlink" title="结语：数值驱动的策略乐趣闭环"></a>结语：数值驱动的策略乐趣闭环</h2><p>​《杀戮尖塔》的数值设计之所以精妙，在于其构建了一个“价值基准-连携放大-循环闭环-难度适配”的完整体系：以能量价值曲线为基础基准，通过卡牌的“基础输入-乘区-导出”架构实现策略落地，借助遗物优化或打破基础规则以丰富流派，再通过难度调整扰动数值循环，推动玩家深化策略理解。</p><p>​整个体系的核心是生命值等价原则，所有资源最终都可转化为生命值的留存能力，而每一处数值细节都服务于策略决策的核心乐趣——让玩家在随机生成的尖塔中，通过解读数值关系、组合连携模块、适配数值循环，不断探索全新的构筑可能性。这种以数值为骨架，以策略为血肉的设计思路，不仅避免了策略退化，保证了多流派的平衡共存，更成就了《杀戮尖塔》的经典地位，为后续卡牌Roguelike游戏的数值设计提供了可借鉴的核心框架。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;《杀戮尖塔》数值设计深度拆解&quot;&gt;&lt;a href=&quot;#《杀戮尖塔》数值设计深度拆解&quot; class=&quot;headerlink&quot; title=&quot;《杀戮尖塔》数值设计深度拆解&quot;&gt;&lt;/a&gt;《杀戮尖塔》数值设计深度拆解&lt;/h1&gt;&lt;p&gt;​		在卡牌与Roguelike融合的游戏品</summary>
      
    
    
    
    <category term="游戏" scheme="https://yifei-huang-cos.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>AI x game 深度体验报告</title>
    <link href="https://yifei-huang-cos.github.io/posts/2c281e1a/"/>
    <id>https://yifei-huang-cos.github.io/posts/2c281e1a/</id>
    <published>2026-01-27T03:28:30.000Z</published>
    <updated>2026-01-27T03:52:18.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AI-x-game体验报告——是不可替代还是锦上添花？"><a href="#AI-x-game体验报告——是不可替代还是锦上添花？" class="headerlink" title="AI x game体验报告——是不可替代还是锦上添花？"></a>AI x game体验报告——是不可替代还是锦上添花？</h1><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>AI技术近年来发展迅猛，其迭代进程与应用成果已深深融入社会生活各领域，给大众带来了直观且深刻的感知。在此背景下，将AI技术与游戏产业相结合的创作理念逐渐成为热点，各类融合AI元素的新兴游戏产品如同雨后春笋般涌现。</p><p>不过，虽然很多游戏都使用AI，但他们的设计理念却不尽相同。有些是利用AI增添新的模块，像是在游戏里增加了接入大模型的可交互的NPC，增加UGC中的AI创作辅助；有些是基于AI构建新的玩法，比如构建一个全部由AI agent构成的社区，观察或参与他们的行为，在这个游戏里，AI是构建整个玩法的底层逻辑；或者更加简单通用一点，只是利用AI进行美术建模和文本的辅助创作……这些游戏到底怎么样，好不好玩，对AI的使用又究竟到了哪一步？我将在其中选择几种具有代表性的进行体验。</p><h1 id="二、游玩体验"><a href="#二、游玩体验" class="headerlink" title="二、游玩体验"></a>二、游玩体验</h1><h2 id="1-AI-陪伴类：情绪价值的提供者"><a href="#1-AI-陪伴类：情绪价值的提供者" class="headerlink" title="1. AI-陪伴类：情绪价值的提供者"></a>1. AI-陪伴类：情绪价值的提供者</h2><p>现代社会中，快节奏的学习与工作节奏使得部分群体面临人际交往困境，或因社交适应障碍，或因缺乏有效倾诉对象，其情绪宣泄需求难以得到充分满足。在此背景下，在游戏场景中植入AI陪伴功能的设计理念应运而生，为解决此类群体的情绪需求提供了新的载体。</p><h3 id="1-1-王者荣耀的灵宝系统-x2F-和平精英AI战犬玩法"><a href="#1-1-王者荣耀的灵宝系统-x2F-和平精英AI战犬玩法" class="headerlink" title="1.1 王者荣耀的灵宝系统&#x2F;和平精英AI战犬玩法"></a>1.1 王者荣耀的灵宝系统&#x2F;和平精英AI战犬玩法</h3><p>2024年2月，王者荣耀上线了灵宝系统；25年11月，和平推出了AI战犬模式。直到今日，灵宝系统也一直在优化与迭代升级，就我个人的体验来说，我还是非常喜欢这个几个小家伙的。为什么这么说呢，我认为这种局内陪伴满足了以下几个优点：</p><h4 id="1-1-1-游戏操作正反馈，提供情绪价值"><a href="#1-1-1-游戏操作正反馈，提供情绪价值" class="headerlink" title="1.1.1 游戏操作正反馈，提供情绪价值"></a>1.1.1 游戏操作正反馈，提供情绪价值</h4><p>尤其在自己单排的时候，4个队友全部闭麦很常见。无论在你打出精彩操作拿到完美击杀还是在大逆风时刻出其不意抢下大龙，队友不一定会夸你，都在闭麦干自己的事。这无可厚非，但没有人为你欢呼 难免会失落。但有灵宝就不一样，他夸奖人来比谁都快<del>比如我玩兰陵王喜欢开局反（tou）对面红buff，每每打完红之后听灵宝来一句：“拿下对面红buff，对面打野恐怕要气疯了吧</del>” 欸嘿，心情就会非常舒坦。</p><h4 id="1-1-2-局内提供帮助，利好休闲玩家"><a href="#1-1-2-局内提供帮助，利好休闲玩家" class="headerlink" title="1.1.2 局内提供帮助，利好休闲玩家"></a>1.1.2 局内提供帮助，利好休闲玩家</h4><p>王者荣耀与和平精英作为国民级手游，拥有庞大的玩家群体，这进一步导致了休闲玩家的比例占绝大多数。相比于硬核玩家，他们的游戏技术或意识显得会比较低。那如何更好的照顾到这类玩家的游戏体验呢？局内陪伴的另一个作用便显现出来了。这里那和平的战犬举例，给出对应的语音指令，战犬便会帮忙收集物资，牵制敌人，或者救助队友，很好的避免了轻度玩家进入游戏后的手忙脚乱。并且他的功能性设计，也不会对游戏平衡性造成很大的破坏。对我这个新手来说，算是帮大忙了</p><h4 id="1-1-3-活跃游戏气氛，调节玩家情绪"><a href="#1-1-3-活跃游戏气氛，调节玩家情绪" class="headerlink" title="1.1.3 活跃游戏气氛，调节玩家情绪"></a>1.1.3 活跃游戏气氛，调节玩家情绪</h4><p>在现代社会中，比完整的游戏时间更难得的是有个和你一起打游戏的朋友，不一定两个人都有时间。所以很多时候我都是单排自己玩，难免会感到寂寞，此时局内陪伴的作用就来了，时不时来两句插科打诨，也可博君一笑。</p><h3 id="1-2-星之低语-x2F-EVE（后者目前只有二测演示视频）"><a href="#1-2-星之低语-x2F-EVE（后者目前只有二测演示视频）" class="headerlink" title="1.2 星之低语&#x2F;EVE（后者目前只有二测演示视频）"></a>1.2 星之低语&#x2F;EVE（后者目前只有二测演示视频）</h3><h4 id="1-2-1-whispered-from-the-star"><a href="#1-2-1-whispered-from-the-star" class="headerlink" title="1.2.1 whispered from the star"></a>1.2.1 whispered from the star</h4><p>该产品是由蔡浩宇主导开发的AI对话类游戏，核心玩法围绕玩家与游戏内漂泊太空的女性角色展开全程对话交互，通过AI的引导与玩家的决策推进剧情。我体验了两个小时，怎么说呢，个人觉得这更像是一款实验品，验证人机交互逻辑和语音识别的先行者，而不是一个完整的游戏。从目前的技术力来看，星之低语的交互建模语音生成乃至情感叙事无疑都走在同类型赛道的前列。但是问题在于，游戏性的缺失导致这不像一个游戏，更像是一次英语口语练习（笑）。其体验的瓶颈也显而易见：后期的交互易陷入重复，缺乏真正的情感弧线与剧情张力。当然啦，它的技术力很强也是无可反驳的。我目前更倾向于认为这是一款公开的试验田，为以后的模型收集数据和反馈，期待他们的下一款游戏。</p><h4 id="1-2-2-EVE"><a href="#1-2-2-EVE" class="headerlink" title="1.2.2 EVE"></a>1.2.2 EVE</h4><p>相比于上面一款，这个游戏的理念更加贴近于传统AI陪伴的概念。该产品以构建3D虚拟伴侣为核心，规划实现对话交互、语音通话、生活服务提醒（如点奶茶、购药等）等功能。由于该产品计划于今年三月公测，且优先面向女性向用户群体，我的体验仅基于测试玩家发布的演示视频进行分析。</p><p>从行业发展视角来看，《EVE》的产品形态本身并非我们的关注核心，其背后的设计思路更具行业参考价值。该产品精准命中了AI陪伴领域的核心潜在需求——为用户提供符合个性化想象的、以用户为中心的虚拟伴侣。无论《EVE》正式上线后的市场表现如何，其开创的产品方向必然会引发行业内其他游戏工作室的跟进。社会调查数据显示，大龄单身青年群体规模持续扩大，此类群体的情感需求并未因单身状态而消失，对情感替代载体的需求日益凸显。而具备高真实度交互能力的AI虚拟伴侣，恰好能够满足这一需求。未来，该赛道有望涌现更多高技术力产品，但如何实现产品差异化竞争，将成为我们需要深入思考的核心问题。</p><h2 id="2-AI-NPC：最多的可能性，但被技术力约束"><a href="#2-AI-NPC：最多的可能性，但被技术力约束" class="headerlink" title="2. AI NPC：最多的可能性，但被技术力约束"></a>2. AI NPC：最多的可能性，但被技术力约束</h2><p>曾经，NPC所说的话总是由文案策划构思好，虽然这对于游戏的推进来说是最快捷的方式，但看多了不免感到乏味。随着LLM的兴起，大家不约而同的想到那个可能性————让大模型控制NPC的交流行为甚至剧情。</p><h3 id="2-1-逆水寒-x2F-燕云十六声"><a href="#2-1-逆水寒-x2F-燕云十六声" class="headerlink" title="2.1 逆水寒&#x2F;燕云十六声"></a>2.1 逆水寒&#x2F;燕云十六声</h3><p>在我印象里，逆水寒最早大规模宣传自己的AI npc，当时我也是因为这个宣传下载体验了一番汴京的风土人情。当时也涌现了很多与AI对话的“焚诀”，和ai npc斗智斗勇也成了每天上线不得不品的一环。乐趣确实有，也能通过文字交流得到npc的物品，在当时给我感觉还是比较新奇有趣的。</p><p>比较可惜的是，这些玩法没有更进一步，你和npc的对话对游戏主体的影响微乎其微，也基本在主线剧情中得不到体现。在这两款游戏里，AI不是一个不可代替的玩法，只是一个外接的模块，可以说删了这个功能换成传统的npc对话形式也不会对游戏产生多大影响。只能说这是受限于目前的技术力，还无法做到AI影响的多剧情分支走向（也可能是不方便管理？）</p><h3 id="2-2-AI-bot，觉悟人机"><a href="#2-2-AI-bot，觉悟人机" class="headerlink" title="2.2 AI bot，觉悟人机"></a>2.2 AI bot，觉悟人机</h3><p>这就比较的传统并且成熟了，在游戏对局内补充人机有利于减少玩家匹配时间，控制对局强度，也有利于新手玩家熟悉游戏，由于在大部分游戏里已经有了较为成熟的应用，本文不再赘述</p><h2 id="3-AI作为游戏基石：未来将至？"><a href="#3-AI作为游戏基石：未来将至？" class="headerlink" title="3. AI作为游戏基石：未来将至？"></a>3. AI作为游戏基石：未来将至？</h2><p>以上是在传统的游戏中增添AI的元素，那么我们有没有可能以AI为底层逻辑创建一个游戏呢？很多影视文学作品都给出过设想，例如头号玩家，失控玩家以及前几年较火的元宇宙概念，他们都给我们提供了一种可能性。我也很高兴的看到有很多游戏在向这方面发展，例如斯坦福小镇，avilizition以及喵吉托的几款游戏demo（例如喵呜岛）。</p><h3 id="3-1-avilizition的体验"><a href="#3-1-avilizition的体验" class="headerlink" title="3.1 avilizition的体验"></a>3.1 avilizition的体验</h3><p>这个项目更准确地应该称为一个模拟平台。它的核心理念非常吸引人（也是我所展望追求的）：每个智能体都有独立的记忆、人际关系和日程，所有的决策都具有蝴蝶效应，npc并能根据与环境和彼此的互动来动态决策。</p><p>我的体验过程充满了新奇与困惑。一开始，我就像进入了一个上帝视角的观察者，看着这些像素小人在小镇里活动，他们会上班、购物、聊天、举办活动。最让我感到惊讶的是，他们之间的互动确实能产生一些预设脚本之外的故事。比如，我看到两个角色因为在咖啡馆的一次聊天而决定晚上一起去酒吧，或者因为之前的某次争执而在下一次见面时显得冷淡。这种基于记忆和关系链产生的行为变化，是它最核心的亮点，让你感觉这个小镇是活的，有自己的时间流。</p><p>但是，这种新鲜感褪去得也很快。首先是交互的乏力感。作为玩家，我能与这些AI角色对话，但对话内容往往流于表面，很难进行有深度的、能实质性改变他们目标或关系的交流。更多的时候，我感觉我是在试图引导对话，而不是在进行有意义的角色扮演。avilizition给我的感觉是，它是一座通往未来游戏理念的桥梁设计图，但我们脚下的建筑材料还不足以把它扎实地建造起来。它足以证明了AI作为游戏世界底层逻辑的可行性，但要把它变成一款好玩的游戏，还有很长的路要走。</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>经过这些体验，我认为目前AI在游戏中的应用，整体上仍然处于“锦上添花”的阶段。无论是提供陪伴的灵宝、战犬，还是能自由对话的NPC，它们确实带来了新鲜感和更好的体验，像是给原有的蛋糕裱上了更精美的花。但如果我们把花拿走，蛋糕本身并没有改变。它们更多是体验的优化与内容的补充。</p><p>然而，从《星之低语》、《EVE》这类纯粹的AI交互应用，尤其是像avilizition这样以AI为世界基石的尝试中，我们能看到一种截然不同的可能性。它们不再满足于做蛋糕上的点缀，而是试图用AI这种新材料，从头烤制一块全新的、我们从未尝过的点心。虽然目前这些可能还有些生涩，形态也不稳定，但方向已经指明。</p><p>所以，我的看法是：未来，AI完全有可能成为构建游戏里不可替代的基石。这条路很长，但起点已经在我们脚下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AI-x-game体验报告——是不可替代还是锦上添花？&quot;&gt;&lt;a href=&quot;#AI-x-game体验报告——是不可替代还是锦上添花？&quot; class=&quot;headerlink&quot; title=&quot;AI x game体验报告——是不可替代还是锦上添花？&quot;&gt;&lt;/a&gt;AI x </summary>
      
    
    
    
    <category term="游戏" scheme="https://yifei-huang-cos.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>刚体运动的python解法</title>
    <link href="https://yifei-huang-cos.github.io/posts/48befe4f/"/>
    <id>https://yifei-huang-cos.github.io/posts/48befe4f/</id>
    <published>2026-01-26T08:53:00.000Z</published>
    <updated>2026-01-27T00:40:45.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自由转动杆与铰链固定杆倾倒时间对比研究"><a href="#自由转动杆与铰链固定杆倾倒时间对比研究" class="headerlink" title="自由转动杆与铰链固定杆倾倒时间对比研究"></a><strong>自由转动杆与铰链固定杆倾倒时间对比研究</strong></h1><h2 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h2><p>​某p大友人中午问了我一个问题</p><p>​<img src="/../images/%E5%88%9A%E4%BD%93%E5%8A%A8%E5%8A%9B.png"></p><hr><p>曾经自诩“高中物理领域神棍”的我也是体会了一把修为尽失的感觉…….可恶，还是，做不到吗。。。</p><p>才怪！现在我有了新的武器，解析不了我就暴力数值解嘻嘻</p><h2 id="二、物理模型"><a href="#二、物理模型" class="headerlink" title="二、物理模型"></a>二、物理模型</h2><h3 id="2-1-自由杆（光滑地面）"><a href="#2-1-自由杆（光滑地面）" class="headerlink" title="2.1 自由杆（光滑地面）"></a>2.1 自由杆（光滑地面）</h3><ul><li><strong>约束条件</strong>：底端无水平约束，质心水平方向动量守恒</li><li><strong>运动特点</strong>：质心同时有平动和转动</li><li><strong>能量方程</strong>：$E &#x3D; \frac{1}{2}mv_c^2 + \frac{1}{2}I_c\omega^2 + mg\frac{L}{2}\cos\theta$</li></ul><h3 id="2-2-铰链杆（固定底端）"><a href="#2-2-铰链杆（固定底端）" class="headerlink" title="2.2 铰链杆（固定底端）"></a>2.2 铰链杆（固定底端）</h3><ul><li><strong>约束条件</strong>：底端位置固定，绕该点纯转动</li><li><strong>运动特点</strong>：质心作圆弧运动</li><li><strong>能量方程</strong>：$E &#x3D; \frac{1}{2}I_o\omega^2 + mg\frac{L}{2}\cos\theta$</li></ul><hr><h2 id="三、动力学方程推导"><a href="#三、动力学方程推导" class="headerlink" title="三、动力学方程推导"></a>三、动力学方程推导</h2><h3 id="3-1-自由杆的倾倒时间"><a href="#3-1-自由杆的倾倒时间" class="headerlink" title="3.1 自由杆的倾倒时间"></a>3.1 自由杆的倾倒时间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自由杆的角速度公式推导</span></span><br><span class="line">ω² = (4g/L) * (cosθ₀ - cosθ)</span><br></pre></td></tr></table></figure><h3 id="3-2-铰链杆的倾倒时间"><a href="#3-2-铰链杆的倾倒时间" class="headerlink" title="3.2 铰链杆的倾倒时间"></a>3.2 铰链杆的倾倒时间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 铰链杆的角速度公式推导</span></span><br><span class="line">ω² = (3g/L) * (cosθ₀ - cosθ)</span><br></pre></td></tr></table></figure><hr><h2 id="四、数值计算方法"><a href="#四、数值计算方法" class="headerlink" title="四、数值计算方法"></a>四、数值计算方法</h2><h3 id="4-1-时间积分公式"><a href="#4-1-时间积分公式" class="headerlink" title="4.1 时间积分公式"></a>4.1 时间积分公式</h3><p>倾倒时间通过对角速度倒数积分得到：<br>$$ t &#x3D; \int_{\theta_0}^{\pi&#x2F;2} \frac{1}{\omega(\theta)} d\theta $$</p><h3 id="4-2-数值实现代码"><a href="#4-2-数值实现代码" class="headerlink" title="4.2 数值实现代码"></a>4.2 数值实现代码</h3><h4 id="自由杆计算代码"><a href="#自由杆计算代码" class="headerlink" title="自由杆计算代码"></a>自由杆计算代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">g = <span class="number">9.81</span></span><br><span class="line">L = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入杆长 L (米): &quot;</span>))</span><br><span class="line">theta0_deg = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入初始倾斜角度 (0–90°, 相对竖直): &quot;</span>))</span><br><span class="line"></span><br><span class="line">theta0 = np.deg2rad(theta0_deg)</span><br><span class="line">theta_end = np.pi / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">integrand</span>(<span class="params">theta</span>):</span><br><span class="line">    omega = np.sqrt((<span class="number">4</span> * g / L) * (np.cos(theta0) - np.cos(theta)))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / omega</span><br><span class="line"></span><br><span class="line">thetas = np.linspace(theta0 + <span class="number">1e-6</span>, theta_end, <span class="number">200000</span>)</span><br><span class="line">t = np.trapezoid(integrand(thetas), thetas)</span><br></pre></td></tr></table></figure><h4 id="铰链杆计算代码"><a href="#铰链杆计算代码" class="headerlink" title="铰链杆计算代码"></a>铰链杆计算代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">g = <span class="number">9.81</span></span><br><span class="line">L = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入杆长 L (米): &quot;</span>))</span><br><span class="line">theta0_deg = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入初始倾斜角度 (0–90°, 相对竖直): &quot;</span>))</span><br><span class="line"></span><br><span class="line">theta0 = np.deg2rad(theta0_deg)</span><br><span class="line">theta_end = np.pi / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">integrand</span>(<span class="params">theta</span>):</span><br><span class="line">    omega = np.sqrt((<span class="number">3</span> * g / L) * (np.cos(theta0) - np.cos(theta)))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / omega</span><br><span class="line"></span><br><span class="line">thetas = np.linspace(theta0 + <span class="number">1e-6</span>, theta_end, <span class="number">200000</span>)</span><br><span class="line">t = np.trapezoid(integrand(thetas), thetas)</span><br></pre></td></tr></table></figure><hr><h2 id="五、模拟结果分析"><a href="#五、模拟结果分析" class="headerlink" title="五、模拟结果分析"></a>五、模拟结果分析</h2><h4 id="5-1-不同初始角度对比（默认杆长1m）"><a href="#5-1-不同初始角度对比（默认杆长1m）" class="headerlink" title="5.1 不同初始角度对比（默认杆长1m）"></a>5.1 不同初始角度对比（默认杆长1m）</h4><table><thead><tr><th>初始角度</th><th>自由杆时间(s)</th><th>铰链杆时间(s)</th><th>时间比(自由&#x2F;铰链)</th></tr></thead><tbody><tr><td>1°</td><td>1.1837</td><td>1.3668</td><td>想算的自己算</td></tr><tr><td>10°</td><td>0.6648</td><td>0.7676</td><td></td></tr><tr><td>30°</td><td>0.4163</td><td>0.4807</td><td>(—&gt; __  —&gt;)</td></tr><tr><td>45°</td><td>0.3201</td><td>0.3697</td><td></td></tr><tr><td>60°</td><td>0.2431</td><td>0.2807</td><td></td></tr><tr><td>80°</td><td>0.1338</td><td>0.1545</td><td></td></tr></tbody></table><h3 id="5-2-不同杆长对比（默认倾斜30°）"><a href="#5-2-不同杆长对比（默认倾斜30°）" class="headerlink" title="5.2 不同杆长对比（默认倾斜30°）"></a>5.2 不同杆长对比（默认倾斜30°）</h3><table><thead><tr><th>杆长(m)</th><th>自由杆时间(s)</th><th>铰链杆时间(s)</th><th>时间比</th></tr></thead><tbody><tr><td>0.5</td><td>0.2944</td><td>0.3399</td><td></td></tr><tr><td>1.0</td><td>0.4163</td><td>0.4807</td><td></td></tr><tr><td>2.0</td><td>0.5888</td><td>0.6799</td><td></td></tr><tr><td>5.0</td><td>0.9309</td><td>1.0750</td><td></td></tr></tbody></table><hr><h2 id="六、结论"><a href="#六、结论" class="headerlink" title="六、结论"></a>六、结论</h2><p>自由杆下落更快！</p><p>但原因是什么呢</p><p>有没有能给我推导过程的QAQ</p><p>在线等~</p><hr><h2 id="附录：论AI目前为什么不能取代人类"><a href="#附录：论AI目前为什么不能取代人类" class="headerlink" title="附录：论AI目前为什么不能取代人类"></a>附录：论AI目前为什么不能取代人类</h2><p>请看vcr</p><p>1.《有固定点，小角度？那就是简谐运动！》————来自亲爱的deepseek</p><p><img src="/../images/deepseek%E4%BD%A0%E5%9C%A8%E5%B9%B2%E5%98%9B.jpg"></p><p>2.《什么是物理，我听不懂，倾斜的杆子就是不会掉下来，牛顿说啥我不管》 </p><p>————GPT5 plus大人！\0&#x2F;</p><p><img src="/../images/gpt%E5%A4%A7%E4%BA%BA%E6%98%AF%E4%BD%95%E6%84%8F%E4%B8%BA.jpg"></p><hr><p>建议加入ai笑话大全~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自由转动杆与铰链固定杆倾倒时间对比研究&quot;&gt;&lt;a href=&quot;#自由转动杆与铰链固定杆倾倒时间对比研究&quot; class=&quot;headerlink&quot; title=&quot;自由转动杆与铰链固定杆倾倒时间对比研究&quot;&gt;&lt;/a&gt;&lt;strong&gt;自由转动杆与铰链固定杆倾倒时间对比研究&lt;/</summary>
      
    
    
    
    <category term="编程" scheme="https://yifei-huang-cos.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>python网络编程--TCP篇</title>
    <link href="https://yifei-huang-cos.github.io/posts/8d64c14e/"/>
    <id>https://yifei-huang-cos.github.io/posts/8d64c14e/</id>
    <published>2026-01-26T02:00:19.000Z</published>
    <updated>2026-01-26T02:57:14.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP网络编程初步"><a href="#TCP网络编程初步" class="headerlink" title="TCP网络编程初步"></a>TCP网络编程初步</h1><p>在学习并发编程之前，先熟悉一个客户端与一个服务端</p><h2 id="TCP协议核心机制"><a href="#TCP协议核心机制" class="headerlink" title="TCP协议核心机制"></a>TCP协议核心机制</h2><p>TCP（传输控制协议）通过三次握手建立连接，通过四次挥手终止连接，确保数据传输的可靠性。</p><h2 id="服务端实现代码"><a href="#服务端实现代码" class="headerlink" title="服务端实现代码"></a>服务端实现代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 服务端的socket              IPV4           TCP</span></span><br><span class="line"><span class="comment"># 这个只负责接受客户端的连接请求</span></span><br><span class="line"></span><br><span class="line">server_socket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">8000</span>))</span><br><span class="line"><span class="comment"># 允许最大的等待个数</span></span><br><span class="line">server_socket.listen(<span class="number">128</span>)</span><br><span class="line"><span class="comment"># 接受客户端的连接</span></span><br><span class="line">socket2, client_addr = server_socket.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = socket2.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;来自客户端IP：<span class="subst">&#123;client_addr[<span class="number">0</span>]&#125;</span>,端口号<span class="subst">&#123;client_addr[<span class="number">1</span>]&#125;</span>:<span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 给客户端发送聊天信息</span></span><br><span class="line">    send_msg = <span class="built_in">input</span>(<span class="string">&#x27;server&gt;&gt;&#x27;</span>)</span><br><span class="line">    socket2.send(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">socket2.close()</span><br><span class="line">server_socket.close()</span><br></pre></td></tr></table></figure><h2 id="客户端实现代码"><a href="#客户端实现代码" class="headerlink" title="客户端实现代码"></a>客户端实现代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server_addr = (<span class="string">&#x27;192.168.100.199&#x27;</span>, <span class="number">8000</span>)</span><br><span class="line">client_socket.connect(server_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    send_msg = <span class="built_in">input</span>(<span class="string">&#x27;client&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> send_msg == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        client_socket.send(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    client_socket.send(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    msg = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;来自服务端IP：<span class="subst">&#123;server_addr[<span class="number">0</span>]&#125;</span>,端口号<span class="subst">&#123;server_addr[<span class="number">1</span>]&#125;</span>:<span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure><h2 id="TCP三次握手详解"><a href="#TCP三次握手详解" class="headerlink" title="TCP三次握手详解"></a>TCP三次握手详解</h2><p>三次握手是TCP建立连接的过程，确保双方都有发送和接收能力。</p><h3 id="第一次握手：SYN"><a href="#第一次握手：SYN" class="headerlink" title="第一次握手：SYN"></a>第一次握手：SYN</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 → SYN=1, seq=x → 服务端</span><br></pre></td></tr></table></figure><p>客户端发送SYN包，seq为随机数x，进入SYN_SENT状态。</p><h3 id="第二次握手：SYN-ACK"><a href="#第二次握手：SYN-ACK" class="headerlink" title="第二次握手：SYN+ACK"></a>第二次握手：SYN+ACK</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 ← SYN=1, ACK=1, seq=y, ack=x+1 ← 服务端</span><br></pre></td></tr></table></figure><p>服务端收到SYN，发送SYN+ACK包：</p><ul><li>seq为随机数y</li><li>ack为x+1（确认收到客户端的x）<br>服务端进入SYN_RCVD状态。</li></ul><h3 id="第三次握手：ACK"><a href="#第三次握手：ACK" class="headerlink" title="第三次握手：ACK"></a>第三次握手：ACK</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 → ACK=1, seq=x+1, ack=y+1 → 服务端</span><br></pre></td></tr></table></figure><p>客户端发送ACK包：</p><ul><li>seq为x+1</li><li>ack为y+1（确认收到服务端的y）<br>双方进入ESTABLISHED状态，连接建立。</li></ul><h3 id="代码中的三次握手"><a href="#代码中的三次握手" class="headerlink" title="代码中的三次握手"></a>代码中的三次握手</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端发起连接（第一次握手）</span></span><br><span class="line">client_socket.connect(server_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端接受连接（完成三次握手）</span></span><br><span class="line">socket2, client_addr = server_socket.accept()</span><br></pre></td></tr></table></figure><h2 id="TCP四次挥手详解"><a href="#TCP四次挥手详解" class="headerlink" title="TCP四次挥手详解"></a>TCP四次挥手详解</h2><p>四次挥手是TCP断开连接的过程，确保双方数据都传输完毕。</p><h3 id="第一次挥手：FIN"><a href="#第一次挥手：FIN" class="headerlink" title="第一次挥手：FIN"></a>第一次挥手：FIN</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 → FIN=1, seq=u → 服务端</span><br></pre></td></tr></table></figure><p>客户端发送FIN包，seq为u，进入FIN_WAIT_1状态。</p><h3 id="第二次挥手：ACK"><a href="#第二次挥手：ACK" class="headerlink" title="第二次挥手：ACK"></a>第二次挥手：ACK</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 ← ACK=1, seq=v, ack=u+1 ← 服务端</span><br></pre></td></tr></table></figure><p>服务端发送ACK包：</p><ul><li>ack为u+1（确认收到客户端的FIN）<br>服务端进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态。</li></ul><h3 id="第三次挥手：FIN"><a href="#第三次挥手：FIN" class="headerlink" title="第三次挥手：FIN"></a>第三次挥手：FIN</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 ← FIN=1, ACK=1, seq=w, ack=u+1 ← 服务端</span><br></pre></td></tr></table></figure><p>服务端发送FIN+ACK包，进入LAST_ACK状态。</p><h3 id="第四次挥手：ACK"><a href="#第四次挥手：ACK" class="headerlink" title="第四次挥手：ACK"></a>第四次挥手：ACK</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 → ACK=1, seq=u+1, ack=w+1 → 服务端</span><br></pre></td></tr></table></figure><p>客户端发送ACK包，进入TIME_WAIT状态（等待2MSL），服务端关闭连接。</p><h3 id="代码中的四次挥手"><a href="#代码中的四次挥手" class="headerlink" title="代码中的四次挥手"></a>代码中的四次挥手</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端发送quit（发起第一次挥手）</span></span><br><span class="line">client_socket.send(<span class="string">&#x27;quit&#x27;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端收到quit（第二次挥手）</span></span><br><span class="line">msg = socket2.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭套接字（完成挥手过程）</span></span><br><span class="line">socket2.close()</span><br><span class="line">server_socket.close()</span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure><h2 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h2><h3 id="建立连接状态"><a href="#建立连接状态" class="headerlink" title="建立连接状态"></a>建立连接状态</h3><ol><li>CLOSED：初始状态</li><li>SYN_SENT：客户端发送SYN后</li><li>LISTEN：服务端调用listen()后</li><li>SYN_RCVD：服务端收到SYN后</li><li>ESTABLISHED：连接建立完成</li></ol><h3 id="断开连接状态"><a href="#断开连接状态" class="headerlink" title="断开连接状态"></a>断开连接状态</h3><ol><li>FIN_WAIT_1：客户端第一次挥手</li><li>CLOSE_WAIT：服务端第一次收到FIN</li><li>FIN_WAIT_2：客户端收到ACK</li><li>LAST_ACK：服务端发送FIN</li><li>TIME_WAIT：客户端最后等待</li><li>CLOSED：连接完全关闭</li></ol><h2 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h2><h3 id="防止旧的重复连接初始化"><a href="#防止旧的重复连接初始化" class="headerlink" title="防止旧的重复连接初始化"></a>防止旧的重复连接初始化</h3><ul><li>避免网络延迟导致的旧连接干扰新连接</li><li>确保双方都知道对方准备好了</li></ul><h3 id="同步序列号"><a href="#同步序列号" class="headerlink" title="同步序列号"></a>同步序列号</h3><ul><li>交换初始序列号（ISN）</li><li>确保数据按序传输</li></ul><h3 id="确认双方能力"><a href="#确认双方能力" class="headerlink" title="确认双方能力"></a>确认双方能力</h3><ul><li>确认双方都有发送和接收能力</li><li>协商窗口大小等参数</li></ul><h2 id="为什么需要四次挥手？"><a href="#为什么需要四次挥手？" class="headerlink" title="为什么需要四次挥手？"></a>为什么需要四次挥手？</h2><h3 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h3><ul><li>TCP是全双工的，可以单向关闭</li><li>服务端可能还有数据要发送</li></ul><h3 id="确保数据完整性"><a href="#确保数据完整性" class="headerlink" title="确保数据完整性"></a>确保数据完整性</h3><ul><li>等待所有数据都传输完毕</li><li>确保没有数据丢失</li></ul><h3 id="可靠终止"><a href="#可靠终止" class="headerlink" title="可靠终止"></a>可靠终止</h3><ul><li>双方都知道连接要关闭了</li><li>防止数据包在网络中”迷路”</li></ul><h2 id="TIME-WAIT状态的作用"><a href="#TIME-WAIT状态的作用" class="headerlink" title="TIME_WAIT状态的作用"></a>TIME_WAIT状态的作用</h2><h3 id="等待2MSL的原因"><a href="#等待2MSL的原因" class="headerlink" title="等待2MSL的原因"></a>等待2MSL的原因</h3><ol><li><strong>确保最后一个ACK到达</strong>：如果服务端没收到ACK会重发FIN</li><li><strong>让旧连接的数据包消失</strong>：防止影响新连接</li><li><strong>MSL（Maximum Segment Lifetime）</strong>：报文最大生存时间</li></ol><h2 id="实际编程中的影响"><a href="#实际编程中的影响" class="headerlink" title="实际编程中的影响"></a>实际编程中的影响</h2><h3 id="连接建立失败"><a href="#连接建立失败" class="headerlink" title="连接建立失败"></a>连接建立失败</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    client_socket.connect(server_addr)</span><br><span class="line"><span class="keyword">except</span> ConnectionRefusedError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;连接被拒绝：服务端未启动或端口错误&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="端口复用问题"><a href="#端口复用问题" class="headerlink" title="端口复用问题"></a>端口复用问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 避免Address already in use错误</span></span><br><span class="line">server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 半关闭：关闭发送，仍可接收</span></span><br><span class="line">client_socket.shutdown(socket.SHUT_WR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待对方关闭</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>三次握手建立可靠连接，四次挥手优雅终止连接，这是TCP协议的核心机制。理解这些过程对于调试网络问题和编写稳定的网络程序非常重要。</p><hr><p><em>在代码中，connect()触发三次握手，close()触发四次挥手，这些细节都由操作系统自动处理。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP网络编程初步&quot;&gt;&lt;a href=&quot;#TCP网络编程初步&quot; class=&quot;headerlink&quot; title=&quot;TCP网络编程初步&quot;&gt;&lt;/a&gt;TCP网络编程初步&lt;/h1&gt;&lt;p&gt;在学习并发编程之前，先熟悉一个客户端与一个服务端&lt;/p&gt;
&lt;h2 id=&quot;TCP协议</summary>
      
    
    
    
    <category term="编程" scheme="https://yifei-huang-cos.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>UDP的简易实现</title>
    <link href="https://yifei-huang-cos.github.io/posts/35e240ca/"/>
    <id>https://yifei-huang-cos.github.io/posts/35e240ca/</id>
    <published>2026-01-23T01:00:06.000Z</published>
    <updated>2026-01-26T02:57:14.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PYTHON网络编程——UDP篇"><a href="#PYTHON网络编程——UDP篇" class="headerlink" title="PYTHON网络编程——UDP篇"></a>PYTHON网络编程——UDP篇</h1><h2 id="一、UDP简介"><a href="#一、UDP简介" class="headerlink" title="一、UDP简介"></a>一、UDP简介</h2><h3 id="什么是UDP？"><a href="#什么是UDP？" class="headerlink" title="什么是UDP？"></a>什么是UDP？</h3><p>UDP（用户数据报协议）是一种无连接的传输层协议，具有以下特点：</p><ul><li>无需建立连接</li><li>不可靠传输（可能丢包）</li><li>传输速度快</li><li>适合实时性要求高的场景</li></ul><h3 id="基本流程对比"><a href="#基本流程对比" class="headerlink" title="基本流程对比"></a>基本流程对比</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP编程流程：创建socket → 绑定 → 监听 → 接受连接 → 收发数据 → 关闭</span><br><span class="line">UDP编程流程：创建socket → 绑定（服务端）→ 直接收发数据 → 关闭</span><br></pre></td></tr></table></figure><h2 id="二、服务端代码详解"><a href="#二、服务端代码详解" class="headerlink" title="二、服务端代码详解"></a>二、服务端代码详解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建了一个UDP的socket对象</span></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># socket.AF_INET: 使用IPv4地址族</span></span><br><span class="line"><span class="comment"># socket.SOCK_DGRAM: 使用UDP协议（数据报套接字）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前一个是我的ipv4地址，如果用127.0.0.1则是在本地</span></span><br><span class="line"><span class="comment"># 如果是空字符，服务端绑定到所有的ip地址</span></span><br><span class="line">server_socket.bind((<span class="string">&#x27;192.168.100.199&#x27;</span>, <span class="number">6666</span>))</span><br><span class="line"><span class="comment"># bind()方法将套接字绑定到指定地址和端口</span></span><br><span class="line"><span class="comment"># &#x27;192.168.100.199&#x27;: 绑定到特定局域网IP</span></span><br><span class="line"><span class="comment"># 其他选择：</span></span><br><span class="line"><span class="comment">#   &#x27;127.0.0.1&#x27;: 本地回环，只能本机访问</span></span><br><span class="line"><span class="comment">#   &#x27;0.0.0.0&#x27;: 绑定所有网络接口</span></span><br><span class="line"><span class="comment">#   &#x27;&#x27;: 同&#x27;0.0.0.0&#x27;</span></span><br><span class="line"><span class="comment"># 6666: 端口号，范围0-65535（0-1023为系统保留）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># msg是收到的数据，addr是源地址和端口号</span></span><br><span class="line">    msg, addr = server_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># recvfrom()是阻塞方法，会一直等待直到收到数据</span></span><br><span class="line">    <span class="comment"># 1024: 缓冲区大小，单位字节</span></span><br><span class="line">    <span class="comment"># msg: 接收到的字节数据</span></span><br><span class="line">    <span class="comment"># addr: 元组 (客户端IP, 客户端端口)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> msg.decode(<span class="string">&#x27;utf8&#x27;</span>) == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 如果客户端发送&#x27;quit&#x27;，则退出循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;来自IP：<span class="subst">&#123;addr[<span class="number">0</span>]&#125;</span>,端口号：<span class="subst">&#123;addr[<span class="number">1</span>]&#125;</span>的消息：<span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 显示消息来源和内容</span></span><br><span class="line"></span><br><span class="line">    send_msg = <span class="built_in">input</span>(<span class="string">&#x27;服务端&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 等待用户输入回复内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不能发送字符串，应该是字节数据</span></span><br><span class="line">    server_socket.sendto(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>), addr)</span><br><span class="line">    <span class="comment"># sendto()发送数据到指定地址</span></span><br><span class="line">    <span class="comment"># encode(&#x27;utf8&#x27;): 将字符串转为字节数据</span></span><br><span class="line">    <span class="comment"># addr: 目标地址（这里发回给原客户端）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># close</span></span><br><span class="line">server_socket.close()</span><br><span class="line"><span class="comment"># 关闭套接字，释放资源</span></span><br></pre></td></tr></table></figure><h2 id="三、客户端代码详解"><a href="#三、客户端代码详解" class="headerlink" title="三、客户端代码详解"></a>三、客户端代码详解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建了一个UDP的socket对象</span></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端socket不用bind</span></span><br><span class="line"><span class="comment"># 客户端通常由系统自动分配端口号</span></span><br><span class="line"><span class="comment"># 如果需要绑定特定端口，也可以使用bind()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># send msg</span></span><br><span class="line">    send_msg = <span class="built_in">input</span>(<span class="string">&#x27;客户端&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> send_msg == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 输入&#x27;quit&#x27;退出</span></span><br><span class="line">    </span><br><span class="line">    client_socket.sendto(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>), (<span class="string">&#x27;192.168.100.199&#x27;</span>, <span class="number">6666</span>))</span><br><span class="line">    <span class="comment"># 发送数据到服务器</span></span><br><span class="line">    <span class="comment"># (&#x27;192.168.100.199&#x27;, 6666): 服务器地址和端口</span></span><br><span class="line">    <span class="comment"># 必须与服务器绑定的地址一致</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># receive msg</span></span><br><span class="line">    msg, addr = client_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 等待服务器回复</span></span><br><span class="line">    <span class="comment"># 注意：这里会阻塞，直到收到服务器响应</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;来自服务端IP：<span class="subst">&#123;addr[<span class="number">0</span>]&#125;</span>,端口号：<span class="subst">&#123;addr[<span class="number">1</span>]&#125;</span>的消息：<span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 显示服务器回复</span></span><br><span class="line"></span><br><span class="line">client_socket.close()</span><br><span class="line"><span class="comment"># 关闭客户端套接字</span></span><br></pre></td></tr></table></figure><h2 id="四、关键知识点"><a href="#四、关键知识点" class="headerlink" title="四、关键知识点"></a>四、关键知识点</h2><h3 id="1-UDP套接字创建"><a href="#1-UDP套接字创建" class="headerlink" title="1. UDP套接字创建"></a>1. UDP套接字创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br></pre></td></tr></table></figure><ul><li><code>AF_INET</code>: IPv4地址族</li><li><code>SOCK_DGRAM</code>: UDP数据报类型</li></ul><h3 id="2-地址绑定"><a href="#2-地址绑定" class="headerlink" title="2. 地址绑定"></a>2. 地址绑定</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端必须绑定，客户端可选</span></span><br><span class="line">server_socket.bind((IP地址, 端口号))</span><br></pre></td></tr></table></figure><h3 id="3-数据收发"><a href="#3-数据收发" class="headerlink" title="3. 数据收发"></a>3. 数据收发</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接收数据（返回数据和来源地址）</span></span><br><span class="line">data, addr = socket.recvfrom(缓冲区大小)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送数据到指定地址</span></span><br><span class="line">socket.sendto(字节数据, (目标IP, 目标端口))</span><br></pre></td></tr></table></figure><h3 id="4-编码转换"><a href="#4-编码转换" class="headerlink" title="4. 编码转换"></a>4. 编码转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送：字符串 → 字节</span></span><br><span class="line">send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收：字节 → 字符串</span></span><br><span class="line">msg.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h2><ol><li><p><strong>UDP是无连接的</strong></p><ul><li>每次发送都要指定目标地址</li><li>不保证数据顺序和可靠性</li></ul></li><li><p><strong>地址和端口</strong></p><ul><li>服务端需要固定端口</li><li>客户端端口通常由系统分配</li></ul></li><li><p><strong>数据大小</strong></p><ul><li>UDP数据包不宜过大（通常&lt;1500字节）</li><li>避免IP分片，提高传输效率</li></ul></li><li><p><strong>阻塞问题</strong></p><ul><li><code>recvfrom()</code>是阻塞调用</li><li>程序会等待直到收到数据</li></ul></li><li><p><strong>多客户端处理</strong></p><ul><li>UDP服务端可以同时处理多个客户端</li><li>通过addr区分不同客户端</li></ul></li></ol><h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><h3 id="Q1-为什么客户端不需要bind？"><a href="#Q1-为什么客户端不需要bind？" class="headerlink" title="Q1: 为什么客户端不需要bind？"></a>Q1: 为什么客户端不需要bind？</h3><p>A: 客户端第一次调用sendto()时，系统会自动分配一个可用端口。</p><h3 id="Q2-如果服务器没启动，客户端会怎样？"><a href="#Q2-如果服务器没启动，客户端会怎样？" class="headerlink" title="Q2: 如果服务器没启动，客户端会怎样？"></a>Q2: 如果服务器没启动，客户端会怎样？</h3><p>A: 客户端发送的数据会丢失，recvfrom()会一直等待（阻塞）。</p><h3 id="Q3-如何测试本机通信？"><a href="#Q3-如何测试本机通信？" class="headerlink" title="Q3: 如何测试本机通信？"></a>Q3: 如何测试本机通信？</h3><p>A: 服务端绑定<code>127.0.0.1</code>，客户端连接<code>127.0.0.1</code>。</p><h3 id="Q4-如何让其他电脑连接？"><a href="#Q4-如何让其他电脑连接？" class="headerlink" title="Q4: 如何让其他电脑连接？"></a>Q4: 如何让其他电脑连接？</h3><p>A: </p><ol><li>服务端绑定<code>0.0.0.0</code>或局域网IP</li><li>关闭防火墙或开放对应端口</li><li>客户端使用服务器实际IP地址</li></ol><h2 id="七、完整的UDP还需要"><a href="#七、完整的UDP还需要" class="headerlink" title="七、完整的UDP还需要"></a>七、完整的UDP还需要</h2><ol><li><strong>异常处理</strong>：添加try-except处理网络错误</li><li><strong>超时设置</strong>：使用settimeout()避免永久阻塞</li><li><strong>多线程</strong>：同时处理多个客户端请求</li><li><strong>数据验证</strong>：添加简单的协议头验证数据完整性</li></ol><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>​      UDP编程的核心模式：</p><ul><li>服务端：创建→绑定→循环收发→关闭</li><li>客户端：创建→循环收发→关闭</li></ul><p>这种简单的请求-响应模式是UDP编程的基础，理解了这种模式后，可以在此基础上构建更复杂的UDP应用。</p><hr><p><em>注：实际使用时，请确保服务端和客户端的IP地址和端口号配置正确，防火墙已开放相应端口。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PYTHON网络编程——UDP篇&quot;&gt;&lt;a href=&quot;#PYTHON网络编程——UDP篇&quot; class=&quot;headerlink&quot; title=&quot;PYTHON网络编程——UDP篇&quot;&gt;&lt;/a&gt;PYTHON网络编程——UDP篇&lt;/h1&gt;&lt;h2 id=&quot;一、UDP简介&quot;&gt;</summary>
      
    
    
    
    <category term="编程" scheme="https://yifei-huang-cos.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>如何用hexo搭建个人博客</title>
    <link href="https://yifei-huang-cos.github.io/posts/cd1cb590/"/>
    <id>https://yifei-huang-cos.github.io/posts/cd1cb590/</id>
    <published>2026-01-21T03:12:12.000Z</published>
    <updated>2026-01-26T02:57:14.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-博客搭建与配置指南"><a href="#Hexo-博客搭建与配置指南" class="headerlink" title="Hexo 博客搭建与配置指南"></a>Hexo 博客搭建与配置指南</h1><h2 id="📖-简介"><a href="#📖-简介" class="headerlink" title="📖 简介"></a>📖 简介</h2><p>Hexo 是一个快速、简洁且高效的静态博客框架。它使用 Markdown解析文章，在几秒内即可生成静态网页。本指南将帮助您快速搭建并配置一个 Hexo 博客。</p><h2 id="🚀-快速开始"><a href="#🚀-快速开始" class="headerlink" title="🚀 快速开始"></a>🚀 快速开始</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p><strong>安装 Node.js</strong></p><ul><li>版本要求：Node.js 14.0 或以上版本</li><li>下载地址：<a href="https://nodejs.org/">Node.js 官网</a></li></ul></li><li><p><strong>安装 Git</strong></p><ul><li>下载地址：<a href="https://git-scm.com/">Git 官网</a></li></ul></li></ol><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>打开终端（命令提示符）并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init my-blog</span><br><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"><span class="comment"># 生成：</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 预览： （浏览器访问 `http://localhost:4000` 查看效果）</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="comment"># 部署：</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="⚙️-基本配置"><a href="#⚙️-基本配置" class="headerlink" title="⚙️ 基本配置"></a>⚙️ 基本配置</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>博客的主要配置文件为 <code>_config.yml</code>，位于博客根目录下。</p><h3 id="常用配置项"><a href="#常用配置项" class="headerlink" title="常用配置项"></a>常用配置项</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网站信息</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">我的博客</span>                    <span class="comment"># 网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span>                       <span class="comment"># 网站副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span>                    <span class="comment"># 网站描述</span></span><br><span class="line"><span class="attr">keywords:</span>                         <span class="comment"># 网站关键词</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">作者名</span>                     <span class="comment"># 作者名称</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>                   <span class="comment"># 语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span>                      <span class="comment"># 时区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL 设置</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com</span>          <span class="comment"># 网站地址</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span>                           <span class="comment"># 网站根目录</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>  <span class="comment"># 文章永久链接格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目录设置</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span>                <span class="comment"># 资源文件夹</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span>                <span class="comment"># 静态文件生成目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写作设置</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span>          <span class="comment"># 新文章文件名格式</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span>              <span class="comment"># 默认布局</span></span><br></pre></td></tr></table></figure><h2 id="🎨-主题安装与配置"><a href="#🎨-主题安装与配置" class="headerlink" title="🎨 主题安装与配置"></a>🎨 主题安装与配置</h2><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>以我所使用的stellar 主题为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/stellar-theme/hexo-theme-syellar themes/stellar</span><br></pre></td></tr></table></figure><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>修改 <code>_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">stellar</span></span><br></pre></td></tr></table></figure><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>主题有自己的配置文件 <code>themes/stellar/_config.yml</code>，可进行个性化设置。</p><h2 id="📝-写作与发布"><a href="#📝-写作与发布" class="headerlink" title="📝 写作与发布"></a>📝 写作与发布</h2><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure><p>文章文件位于 <code>source/_posts/文章标题.md</code></p><h3 id="文章-Front-matter"><a href="#文章-Front-matter" class="headerlink" title="文章 Front-matter"></a>文章 Front-matter</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 2024-05-20 10:00:00</span><br><span class="line">tags: [标签1, 标签2]</span><br><span class="line"><span class="section">categories: 分类名</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><code>hexo new [layout] &lt;title&gt;</code> - 新建文章</li><li><code>hexo clean</code> - 清除缓存</li><li><code>hexo generate</code> 或 <code>hexo g</code> - 生成静态文件</li><li><code>hexo server</code> 或 <code>hexo s</code> - 启动本地服务器</li><li><code>hexo deploy</code> 或 <code>hexo d</code> - 部署到远程仓库</li></ul><h2 id="🌐-部署到-GitHub-Pages"><a href="#🌐-部署到-GitHub-Pages" class="headerlink" title="🌐 部署到 GitHub Pages"></a>🌐 部署到 GitHub Pages</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>创建 GitHub 仓库，命名为 <code>用户名.github.io</code></li><li>安装部署插件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="配置部署"><a href="#配置部署" class="headerlink" title="配置部署"></a>配置部署</h3><p>修改 <code>_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><h3 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h2 id="🔧-常用插件"><a href="#🔧-常用插件" class="headerlink" title="🔧 常用插件"></a>🔧 常用插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSS 订阅</span></span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点地图</span></span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章搜索</span></span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章字数统计</span></span><br><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><h2 id="💡-实用技巧"><a href="#💡-实用技巧" class="headerlink" title="💡 实用技巧"></a>💡 实用技巧</h2><h3 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><h3 id="草稿功能"><a href="#草稿功能" class="headerlink" title="草稿功能"></a>草稿功能</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft <span class="string">&quot;草稿标题&quot;</span></span><br><span class="line">hexo publish <span class="string">&quot;草稿标题&quot;</span></span><br></pre></td></tr></table></figure><h3 id="图片引用"><a href="#图片引用" class="headerlink" title="图片引用"></a>图片引用</h3><ol><li>将图片放入 <code>source/images/</code> 目录</li><li>在文章中引用：</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片描述</span>](<span class="link">/images/图片文件名.jpg</span>)</span><br></pre></td></tr></table></figure><h2 id="🛠️-故障排除"><a href="#🛠️-故障排除" class="headerlink" title="🛠️ 故障排除"></a>🛠️ 故障排除</h2><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li><p><strong>部署失败</strong></p><ul><li>检查 Git 配置</li><li>确认仓库地址正确</li><li>检查网络连接</li></ul></li><li><p><strong>页面无法加载</strong></p><ul><li>运行 <code>hexo clean</code></li><li>重新生成和启动服务器</li></ul></li><li><p><strong>主题不生效</strong></p><ul><li>确认主题文件夹名称正确</li><li>检查 <code>_config.yml</code> 中 theme 配置</li></ul></li></ol><h2 id="📚-学习资源"><a href="#📚-学习资源" class="headerlink" title="📚 学习资源"></a>📚 学习资源</h2><ul><li><a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a></li><li><a href="https://github.com/hexojs/hexo">Hexo GitHub</a></li><li><a href="https://theme-next.js.org/">Next 主题文档</a></li></ul><hr><blockquote><p><strong>提示</strong>：配置时建议备份原配置文件，每次只修改少量配置并测试效果。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo-博客搭建与配置指南&quot;&gt;&lt;a href=&quot;#Hexo-博客搭建与配置指南&quot; class=&quot;headerlink&quot; title=&quot;Hexo 博客搭建与配置指南&quot;&gt;&lt;/a&gt;Hexo 博客搭建与配置指南&lt;/h1&gt;&lt;h2 id=&quot;📖-简介&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
</feed>
