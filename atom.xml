<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黄逸飞的个人博客</title>
  
  
  <link href="https://yifei-huang-cos.github.io/atom.xml" rel="self"/>
  
  <link href="https://yifei-huang-cos.github.io/"/>
  <updated>2026-01-29T02:41:02.412Z</updated>
  <id>https://yifei-huang-cos.github.io/</id>
  
  <author>
    <name>黄逸飞</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>杀戮尖塔设计拆解——内容篇</title>
    <link href="https://yifei-huang-cos.github.io/posts/98ac3117/"/>
    <id>https://yifei-huang-cos.github.io/posts/98ac3117/</id>
    <published>2026-01-28T08:00:00.000Z</published>
    <updated>2026-01-29T02:41:02.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《杀戮尖塔》设计内容深度拆解"><a href="#《杀戮尖塔》设计内容深度拆解" class="headerlink" title="《杀戮尖塔》设计内容深度拆解"></a>《杀戮尖塔》设计内容深度拆解</h1><h6 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h6><p>《杀戮尖塔》以其精妙的规则融合，定义了Roguelike卡牌。其成功远非简单的玩法叠加。本文将以 “内容拆解 → 平衡性分析 → 设计哲学提炼” 的三步框架，由表及里地剖析其设计精髓，揭示这款游戏如何将简单的规则编织成近乎无限的可能，并提供持久的策略乐趣。</p><h2 id="第一步：内容拆解——游戏的建筑逻辑"><a href="#第一步：内容拆解——游戏的建筑逻辑" class="headerlink" title="第一步：内容拆解——游戏的建筑逻辑"></a>第一步：内容拆解——游戏的建筑逻辑</h2><p>任何深度分析都始于对构成要素的系统性理解。</p><h3 id="1-核心驱动循环"><a href="#1-核心驱动循环" class="headerlink" title="1. 核心驱动循环"></a>1. 核心驱动循环</h3><p>每一局游戏都由一个简洁有力的引擎驱动，其核心循环如下图所示，它构成了单局游戏最基本的行为骨架：</p><pre class="mermaid">flowchart TD    A[战斗<br>消耗生命，检验牌组] --> B[获取奖励<br>三选一卡牌/金币/遗物]    B --> C{地图路径决策<br>风险评估与资源规划}    C -->|选择路线| A</pre><p>这个循环持续进行，玩家的每一次选择都在动态塑造着独一无二的牌组与资源状况。</p><p>生命值在此循环中扮演着双重角色：它既是需要保障的生存需求，也是可以谨慎花费以换取更高奖励的货币。</p><p>（特定事件可以用血量换取收益——遗物或者卡牌）</p><h3 id="2-核心构建维度"><a href="#2-核心构建维度" class="headerlink" title="2. 核心构建维度"></a>2. 核心构建维度</h3><p>玩家力量的成长围绕三个可累积的系统展开：</p><ul><li><p><strong>卡牌</strong>：主动的操作单元，分为</p><ul><li>攻击牌：直接伤害；</li><li>技能牌：格挡、施加状态等；</li><li>能力牌：整场持续的被动效果；</li></ul></li><li><p><strong>遗物</strong>：提供从数值加成到机制颠覆的各类效果，是构筑产生质变的关键。</p><ul><li>数值加成：金刚杵加1力量，光滑的石头加1敏捷。这类遗物提供简单粗暴的加数值；</li><li>机制改变：冰淇淋让回合结束后能量不清空，金字塔让回合结束时的手牌不丢弃。这类遗物改变构筑思路和出牌逻辑；</li><li>局外成长：古钱币直接给300块，烟斗让火堆额外多了删牌事件。这些遗物让玩家在战斗之外改变构筑提升战力；</li></ul></li><li><p><strong>药水</strong>：一次性的战术储备，用于应急或弥补构筑短板。</p><ul><li>提供抽牌，回血，格挡，换牌等效果；</li><li>小怪概率掉落，商店稳定购买，事件可能获取；</li><li>通过减少药水栏位限制高进阶玩家；</li></ul></li></ul><h3 id="3-核心博弈资源"><a href="#3-核心博弈资源" class="headerlink" title="3. 核心博弈资源"></a>3. 核心博弈资源</h3><p>除了牌组，玩家还需持续管理两种抽象资源：</p><ul><li><strong>生命值</strong>：如上所述，是驱动核心循环的关键资源，对血量的判断是否足以打精英怪换取遗物；</li><li><strong>金币</strong>：集中于商店系统的经济资源。用于购买关键卡牌、遗物，以及萌新可能忽视的删卡；</li></ul><h3 id="4-庞大的内容池"><a href="#4-庞大的内容池" class="headerlink" title="4. 庞大的内容池"></a>4. 庞大的内容池</h3><p>游戏提供了丰富的交互可能性，确保每次冒险的独特性，每个职业拥有完全独立的卡池与核心机制，玩法迥异。</p><ul><li><h4 id="四大职业："><a href="#四大职业：" class="headerlink" title="四大职业："></a>四大职业：</h4><ul><li><h6 id="战士：我认为，战士的最核心机制是消耗："><a href="#战士：我认为，战士的最核心机制是消耗：" class="headerlink" title="战士：我认为，战士的最核心机制是消耗："></a>战士：我认为，战士的最核心机制是消耗：</h6><ul><li>通过点烧（坚毅+，燃烧契约）和大烧（重振精神，恶魔之焰）完成对局内卡组的精简，进一步打出小循环或无限循环。</li><li>常见cambo有剑耸无限（有日晷真无限，带放血伪无限），亮剑妙计，撑振肚皮，进化无谋契约…</li><li>除此之外，战士还有以壁垒巩固为核心的防战体系和以力量组件为核心的力量战体系（偏门的有强依赖单卡和火堆的灼热战体系）</li></ul></li><li><h6 id="猎人：猎人核心是运转，通过摸弃完成过牌回费和零费输出："><a href="#猎人：猎人核心是运转，通过摸弃完成过牌回费和零费输出：" class="headerlink" title="猎人：猎人核心是运转，通过摸弃完成过牌回费和零费输出："></a>猎人：猎人核心是运转，通过摸弃完成过牌回费和零费输出：</h6><ul><li>弃牌体系对猎人来说是最成熟的体系，组件也最常见，例如最强白卡过牌杂技1费抽4弃1，因为对猎人来说，弃牌往往带来的是正面收益（本能反应被弃后抽牌，战术大师被弃后回费）强大的运转能力使得猎人几乎适配所有0费输出，尤其是金卡华丽收场，0费AOE高伤害，即使打出需要严苛的条件，也值得猎人为此特化构筑</li><li>猎人第二分支是毒猎，由于高进阶慢启动吃战损、怕人工等缺点，在没有关键卡催化剂的情况下，往往作为过渡的选择</li><li>小刀猎：萌新最爱玩的流派之一，但是最好祈祷不要遇到小刀猎最严厉的父亲哦（会遇到时间吞噬者！）</li></ul></li><li><h6 id="故障机器人（球-x2F-重编程）："><a href="#故障机器人（球-x2F-重编程）：" class="headerlink" title="故障机器人（球&#x2F;重编程）："></a>故障机器人（球&#x2F;重编程）：</h6><p>​由于本人的机器人水平并不高，遂邀请友人对其评价，由于内容较长，放至附录1。</p></li><li><h6 id="观者：观者核心是姿态转换："><a href="#观者：观者核心是姿态转换：" class="headerlink" title="观者：观者核心是姿态转换："></a>观者：观者核心是姿态转换：</h6><ul><li>愤怒：双倍伤害，但受伤也双倍，观者的最核心机制没有之一。所有观者的输出卡设计时候都要考虑到双倍伤害这一条件。哪怕是初始的打击+1费打9，到观者手上就是一费18，产生质变。在前两层里，愤怒加两个打击足以秒杀许多小怪了。愤怒的机制让观者有了速杀的能力。</li><li>平静：退出平静姿态时候回两费。如果说单看愤怒机制，还可以说是风险与机遇并存——高伤害的同时防御压力也翻倍，无法斩杀的怪物就要考虑防守。但是如果加上平静则完全不同，观者完全可以进入暴怒输出打完后在进入平静，不仅不用承受双倍防御压力，还能为下一轮的输出积攒费用。1费平静卡的存在导致观者完全可以在红蓝之间切换的费用不会损失，只要抽牌量足够，观者就能把所有的牌打出去。我相信很多小伙伴打出的第一个无限就是猛虎下山加暴怒不惧妖邪（鸡煲：我要学猛虎下山！）然后释怀的笑</li><li>神格：存在感很低的体系，被红蓝遮掩了锋芒，其本身底子不错，有过牌有保留有0费卡，但是组件过于绑定，拿一张意味着就要拿一个体系，观者又是一个对卡组大小很敏感的职业，导致实战很多人不愿意拿第一张神格卡（完全是累赘），进而不碰整个神格体系。就像我在数值篇分析的那样，观者的卡牌数值结构就是存在明显的问题，无用卡占比比其余三个职业加起来都多，这是设计里比较可惜的点。</li><li>预见：最意义不明的体系，设计的像一个半成品，不予评价</li></ul></li></ul></li><li><h4 id="渐进式挑战："><a href="#渐进式挑战：" class="headerlink" title="渐进式挑战："></a>渐进式挑战：</h4><p>​三层逐级攀升的冒险，每层结尾设有机制独特的强力首领，对牌组的完成度提出硬性考验。</p><ul><li><p><strong>一层</strong>：发育为主，高难挑战较少，提前准备对策卡即可。如精英小红要求卡组的攻击牌浓度，精英三柱要求卡组中有对群特攻或者快速的点杀能力。总体来说危险程度不大，以引导玩家合理选卡为主。</p></li><li><p><strong>二层</strong>：危险度高，考验卡组抗压能力。高进阶的二层是玩家失败最多的层数。一方面是二层小怪的高攻击欲望带来的血线压力，且常会给玩家加debuff；另一方面玩家卡组大多数在二层尚未成型，如果一层boss遗物掉落的不好的话在二层刚进门遇到双小偷或者3鸟都会比较吃力。且二层精英怪三奴隶和小手攻击欲望很高每回合都有高额攻击，会往卡组里塞伤口，较为克制吃启动和运转的卡组。在二层，玩家得精细把控血量和发育的平衡，既不能横死道中，也不可火堆全睡亏了发育。</p></li><li><p><strong>三层</strong>：卡组成型的检验，引导玩家补强或找到短板。有趣的是，虽然三层小怪的强度高于二层，但玩家压力缺普遍低于二层，三层的实际压力是塔顶的双重boss（进阶20才有）。能过二层，说明玩家卡组已经初步成型，在三层的的主要目的变成了寻找关键key牌补强，或者敲牌删牌发育。而三层boss才是三层的灵魂：</p><ul><li>1.觉醒者：特殊机制：2条命，玩家每开一个能力牌觉醒者加两点力量。克制能力多的职业。（在启动了！）</li><li>2.时间吞噬者（老头）：特殊机制：玩家每出12牌强制结束回合。特别克制以来运转的体系和低质量无限</li><li>3.八体和甜甜圈：特殊机制：高成长，塞眩晕，还有三层人工不好上debuff。</li></ul></li><li><p><strong>最终boss</strong>：心脏。最难的boss。特殊机制如下：</p><ul><li>1.律动：每出1张牌受到伤害，伤害量随回合数逐渐递增。这个机制强制要求卡组必须有起防能力，不能打没有防御的无限：例如双剑柄日晷，必须搭配起防卡或者遗物。</li><li>2.坚不可摧：每受到200点伤害后，将免疫一切伤害。杜绝了一切速杀的可能，再强大的攻杀卡组，也得至少四回合，变相提高了对卡组中防御浓度的需求。</li><li>3.第一回合塞状态牌和挂debuff。作为集大成者，心脏第一回合不会攻击，而是转为向你的抽牌堆里加入五张状态牌，并且给你挂易伤（受到伤害增加），虚弱（造成伤害减少），脆弱（获得格挡减少）等debuff。这对卡组的请状态牌能力提出高要求，并且也干扰很多脆弱的无限和循环手段。</li><li>4.高成长：心脏每三回合进行一次强化，提高力量并重置自身负面状态。基本八到九回合之后，心脏的攻击九很难用一般起防手段防御住了。这个机制要求玩家的卡组有在上述负面条件影响下依旧能快速解决战斗的能力。</li></ul></li></ul></li><li><h4 id="随机事件："><a href="#随机事件：" class="headerlink" title="随机事件："></a>随机事件：</h4><ul><li>提供高风险高回报的特殊抉择，持续增加游戏进程的变数。部分事件具有一锤定音的效果，例如二层的灵体事件可以解决绝大多数卡组的启动压力，三层的敲全部牌事件是缺敲位猎人的救命稻草（即使代价是无法回复血量）。由于诸多随机事件的设计，给杀戮尖塔的路线选择带来更加丰富的可能性，也提供了未知的乐趣和博弈性。</li></ul></li></ul><h2 id="第二步：平衡性分析——精密的调控艺术"><a href="#第二步：平衡性分析——精密的调控艺术" class="headerlink" title="第二步：平衡性分析——精密的调控艺术"></a>第二步：平衡性分析——精密的调控艺术</h2><p>真正让这些模块焕发生机的，是使其相互咬合、充满权衡的精妙平衡设计。下图概括了游戏在几个关键维度上如何设置平衡点：</p><pre class="mermaid">flowchart LR    subgraph A [风险与回报的量化]        direction LR        A1[生命值] -- 作为决策货币 --> A2[计算精英战收益<br>评估事件代价]    end    subgraph B [资源与污染的博弈]        direction LR        B1[添加新卡牌] -- 可能 --> B2[稀释牌库浓度]        B2 -- 提升 --> B3[删除基础牌的战略价值]    end    subgraph C [遗物的催化效应]        direction LR        C1[特定遗物] -- 与卡牌协同 --> C2[引发质变<br>如：蛇眼+高费攻击]        C2 -- 引导 --> C3[整局游戏构筑方向]    end    A --> D[终极目标：<br>在动态约束中规划最优解]    B --> D    C --> D</pre><h3 id="1-风险与回报的量化体系"><a href="#1-风险与回报的量化体系" class="headerlink" title="1. 风险与回报的量化体系"></a>1. 风险与回报的量化体系</h3><p>游戏将绝大多数决策转化为可评估的风险与回报。</p><ul><li><strong>生命值的隐形标价</strong>：一场普通战斗的预期损耗、一个事件选项的潜在代价、挑战精英所需的“入场费”，都经过了精确计算。精英战斗虽然危险，但其掉落的核心遗物价值被设定为“通常值得且经常必要”，尤其是在高层进阶中，回避精英往往意味着后期强度不足。</li><li><strong>路线选择的数学博弈</strong>：地图设计保证了高收益节点（精英、商店）往往伴随更高的战斗密度或路径成本。玩家需要根据实时状态（血量、金币、牌组关键需求）进行动态规划，计算最优的数学期望。</li></ul><h3 id="2-卡牌强度与“卡组污染”的对抗"><a href="#2-卡牌强度与“卡组污染”的对抗" class="headerlink" title="2. 卡牌强度与“卡组污染”的对抗"></a>2. 卡牌强度与“卡组污染”的对抗</h3><p>单卡强度必须置于牌组整体循环效率的全局中考量。</p><ul><li><strong>稀释惩罚</strong>：盲目添加低质量或不合流的卡牌，会显著降低抽到核心组件的概率。这迫使玩家在“拿牌解决当下问题”与“保持牌组精简专注”之间持续权衡。</li><li><strong>删除机制的战略价值</strong>：因此，商店中的“删牌”服务成为核心战略环节。移除初始的打击防御以提升卡组中关键牌的浓度，是构筑从粗糙走向精炼的关键一步，这赋予了经济资源（金币）深远的战略意义。</li></ul><h3 id="3-职业核心机制的数值边界"><a href="#3-职业核心机制的数值边界" class="headerlink" title="3. 职业核心机制的数值边界"></a>3. 职业核心机制的数值边界</h3><p>​具体分析见上文杀戮尖塔的数值分析篇，这里仅作简单介绍。</p><ul><li>战士的格挡与力量：格挡值每回合清空，使得壁垒这类保留格挡的卡牌价值凸显。力量成长虽线性，但与多段攻击配合能产生指数级伤害，其潜力被严格限制在高费用或稀有卡中。</li><li>猎手的弃牌运转：其核心在于通过大量抽牌、弃牌触发效果（如“本能反应”、“杂技”）和0费卡牌来实现每回合的高额操作量。平衡的关键在于，减少卡组内非关键牌的浓度（初始的打击防御，仅用于过渡的攻击卡），和需要配合的资源卡（战术大师，弃置此牌获得能量）。</li><li>故障机器人的集中：作为提升所有充能球效率的全局乘数，获取集中力的手段（如“碎片整理”、“偏差认知”）</li><li>观者的姿态切换：“愤怒”姿态下造成与承受伤害均翻倍，这一简洁设计创造了极高的操作风险与爆发潜力，迫使玩家精确规划姿态切换的节奏，实现高效的攻防循环。</li></ul><h3 id="4-遗物的催化剂效应"><a href="#4-遗物的催化剂效应" class="headerlink" title="4. 遗物的催化剂效应"></a>4. 遗物的催化剂效应</h3><p>遗物设计的高明之处在于，它们常常是能促使卡组产生化学反的催化剂。</p><ul><li>协同引爆点：如死灵之书（每回合第一张二费及以上攻击牌打出两次）与高费攻击牌的配合，能将单次爆发伤害倍增。这类遗物与特定卡牌结合后，便能引发构筑的质变。</li><li>构筑导向性：早期获得一个核心遗物（如“异蛇之眼”：每回合多抽二，你卡牌的能力消耗将会随机改变），往往会直接定义整局游戏的构筑方向（多抓高费牌，少抓0费）。这种因势利导的动态规划，正是游戏策略深度的核心体现。</li></ul><h2 id="第三步：设计哲学提炼——成功的底层逻辑"><a href="#第三步：设计哲学提炼——成功的底层逻辑" class="headerlink" title="第三步：设计哲学提炼——成功的底层逻辑"></a><strong>第三步：设计哲学提炼——成功的底层逻辑</strong></h2><p>在具体的平衡性之上，是支撑整个游戏体验的、更为普适的设计理念。这些理念之间的支撑关系，构成了游戏稳固的设计三角：</p><pre class="mermaid">graph TD    subgraph 表层体验        D[动态构建的乐趣<br>“现在我能走哪条路？”]    end    subgraph 底层支柱        A[“限制”创造深度<br>能量/手牌/生命值] --> D        B[信息透明下的风险计算<br>将运气转化为策略] --> D        C[可控的随机性<br>用选择引导随机结果] --> D    end    D --> E[核心体验：<br>在约束中感受掌控感与成长的权力]</pre><h3 id="1-限制是深度策略的源泉"><a href="#1-限制是深度策略的源泉" class="headerlink" title="1. 限制是深度策略的源泉"></a>1. 限制是深度策略的源泉</h3><p>游戏中最引人入胜的决策，几乎都源于与各种限制的对抗。</p><ul><li><p>能量限制（每回合3点）：要求权衡每张卡牌的费用与效果。</p></li><li><p>手牌与抽牌限制：需要管理牌序并构建过牌引擎。</p></li><li><p>药水槽位限制：让每个药水选择都意义重大。</p></li><li><p>生命值限制：将生存压力转化为贯穿全局的决策维度。</p><p>正是这些限制的存在，使得那些能够突破限制的效果（获得额外能量、额外抽牌、复制卡牌、无视消耗等）成为玩家构建的终极追求，创造了强烈的成长感与构筑成就感。</p></li></ul><h3 id="2-信息透明下的风险计算"><a href="#2-信息透明下的风险计算" class="headerlink" title="2. 信息透明下的风险计算"></a>2. 信息透明下的风险计算</h3><p>游戏摒弃了战斗中的隐藏骰子，并清晰预告敌人的下回合行动。这巧妙地将运气问题转化为了风险计算问题。<br>玩家思考的不再是会不会出暴击？，而是以我当前的血量和牌库，接下这招后存活并反制的概率有多大？决策基于已知信息与概率估算，成功带来的成就感源于精妙的规划与计算，而非单纯的随机恩赐。</p><h3 id="3-动态适应，而非静态搭配"><a href="#3-动态适应，而非静态搭配" class="headerlink" title="3. 动态适应，而非静态搭配"></a>3. 动态适应，而非静态搭配</h3><p>与预先组好固定套牌的传统卡牌游戏不同，《杀戮尖塔》的核心乐趣在于<strong>根据已获得的资源，即时规划最优的胜利路径</strong>。每一局，玩家都在回答一个动态问题：“基于我当前的卡牌和遗物，我最有可能通往胜利的构筑方向是什么？”<br>这就要求设计必须提供大量中等强度、具备多种协同潜力的卡牌与遗物，确保无论随机获得何种奖励，玩家总能找到一个有发展潜力的方向，而非依赖少数几个固定的通关公式。</p><h3 id="4-可控的随机与正向的雪球效应"><a href="#4-可控的随机与正向的雪球效应" class="headerlink" title="4. 可控的随机与正向的雪球效应"></a>4. 可控的随机与正向的雪球效应</h3><p>游戏的随机性被高度结构化的“玩家选择”所包裹与引导。</p><ul><li><p>三选一奖励：允许玩家在随机选项中挑选最符合当前策略的拼图。</p></li><li><p>地图路线选择：允许玩家根据自己的状态主动趋利避害。</p></li><li><p>商店购买：允许玩家用通用资源（金币）精确填补短板。</p><p>这种设计让玩家感觉自己是在不断将随机性引导向利于自己的方向。一旦关键协同形成，构筑开始正向循环（产生雪球效应），玩家能清晰感受到自己对局面的控制力从弱到强的增长过程。这种不断增强的掌控感，是游戏提供持久正反馈和成瘾性的关键。</p></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h2><p>通过对《杀戮尖塔》“内容-平衡-设计”三层结构的剖析，我们可以看到，其伟大之处在于构建了一个规则简洁但交互深奥的决策模拟器。<br>它以限制创造张力，以透明保障公平，以动态构建鼓励智慧适应，再以可控的随机性提供无穷的探索空间。它将所有游戏元素编织进一张精密的网中，让每一次抽牌、每一次路线选择都充满意义。<br>最终，它提供了一种纯粹而迷人的策略乐趣：在规则与随机的双重约束下，运用智慧，从无到有地构建出一个能够克服万难、独特而强大的系统。这或许就是《杀戮尖塔》能够超越类型，成为设计典范的根本原因。</p><hr><h2 id="附录1"><a href="#附录1" class="headerlink" title="附录1"></a>附录1</h2><h6 id="特别鸣谢："><a href="#特别鸣谢：" class="headerlink" title="特别鸣谢："></a>特别鸣谢：</h6><p><strong>Songhan Cai先生对故障机器人理论提出的大力支持。他是出色鸡煲高手（），让我们看看他对故障机器人的理解</strong>：</p><blockquote><p>​故障机器人是杀戮尖塔中的最强的角色<strong>（括号均为黄逸飞插话：并非）</strong>，它拥有其他职业难以望其项背的数值和令所有怪物闻风丧胆的机制（<strong>数值在哪？</strong>）。</p><p>​机器人的大部分体系围绕充能球来展开，四种充能球各司其职，在各个端口为机器人构建了全面并且强大（<strong>？</strong>）的体系支架。</p><p>​1.电球是机器人最容易获取的球，他每回合能提供基础稳定的伤害，产球成本低使得能更好在循环中把其他球推出去，在电动力学的加持下还能转变为高贵的aoe，更为可贵的是电球随机选择目标攻击，这让机器人这个职业天生比其他人多了很多很多随机数，能在无数次sl中找到唯一获胜的世界线。</p><p>​2.黑球有着更高的爆发伤害，其蓄力机制能很好和循环递归，双放这种牌配合，利用好瞄准生命值最低目标的机制，找到合适的时机选择推出去还是攒球。</p><p>​3.等离子白球的获取成本更高，但是其收益十分之恐怖，大多数boss遗物每回合加一费都要让你付出高昂的代价，而这仅仅需要我们鸡煲挂一个白球，同时白球的激发能让机器人马上获得两费，简直是无与伦比的爆发能力。</p><p>​4.而最强最强最强的则是冰球，其提供的护甲看似很少，但是在集中，循环和更多球位的多重杠杆之下，冰球会为机器人筑起固若金汤的防御端，而且是每回合自动的。有了集中冰甚至攻击端能仅仅凭一个沙漏就能腐乳时间吞噬者，你只需要每回合按e，然后拿起手机刷十分钟视频。</p><p>​现在通过球和集中来分析机器人的攻击和防御端，电球黑球提供伤害，冰球提供防御，那么怎么让他们的数值达到合格水平以应对怪物呢。第一个想到的就是生成更多的球，把原来的球推出去以获得更多数值，这点通过打出电击，冷头，漆黑等优质产球牌就可以做到。第二是通过增加球位，或者通过循环来提升我们每回合球的挂机收益。最重要的第三点，则是提升我们的集中，集中能够同时提升球的被动收益和推球的收益，作为一个独立的乘区增幅机器人的战斗力，能提供集中的牌和遗物都是受机器人所喜爱（<strong>尽孝</strong>）。无论在局外抓卡还是局内操作，牢记这三点的均衡对机器人来说都是基本且必要的。</p><p>​接下来说一下物理攻防，球的数值不受力量，敏捷，易伤，虚弱等等多重常见状态影响，导致其思路有所不同，和某些遗物的配合也较差。但这不意味鸡煲不需要传统攻防牌，在卡组没有成型前，我们需要适当抓取一些物理攻防过渡牌，如眼部，光束射线，自动护盾，这是职业特性和怪物环境双重决定的（严父小红），有些牌同时兼顾物理和产球，如球闪，冰川，愁云，这让他们前中后期都有不俗的发挥。</p><p>​而物理机则是机器人一种完全不同的思路，以重编程为绝对核心，用掉集中这个对于机器人来说能废掉一半牌的代价换取配合比起其他职业少的多的力敏，是比灼热战和点穴观更垃圾的存在，所以绝大时候机器人还是以物理为辅助，充能球为核心。<strong>（在这里我插一嘴，其他职业的棱镜玩法中，重编程是一张非常强力的卡牌，可惜跟了机器人）</strong></p><p>​来到运转端，机器人在运转方面的优劣势都十分明显，他不像战士能烧干所有牌打小循环，不能学猎人娴熟通过猴戏弃牌打出复杂操作，更不是某个凭借着崩坏的数值就无法无天洁癖抓牌嗯凑唐氏红蓝无限的最弱角色（<strong>别逗你观姐笑了</strong>）能碰瓷的。大部分鸡煲都是均卡思路，好牌多抓，通过打出能力牌逐步建立优势，但是打能力牌也需要抽牌位和费用且收益延迟，故而启动稍稍慢那么一点点也就是鸡煲稍有瑕疵的小缺点了（<strong>偏差认知了，偏差认知，偏差认，偏差，偏…<strong>）。而优点是，在费用方面鸡煲手握着最多的优质加费，如四职业唯一白卡费用牌内核，简单粗暴的双倍能量，一边烧牌一边赚费的回收。过牌方面，无论是没数值的快检还是有数值的编冲，都在一个可用的中庸水平，能够定向检索和复用的全息搜寻万物也都是十分适配均卡体系的。但缺少一锤定音的过牌核心如黑拥猛虎一直是鸡煲的一个痛点，定位相似的散热片并不是那么好用（</strong>我要学猛虎下山！</strong>）。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;《杀戮尖塔》设计内容深度拆解&quot;&gt;&lt;a href=&quot;#《杀戮尖塔》设计内容深度拆解&quot; class=&quot;headerlink&quot; title=&quot;《杀戮尖塔》设计内容深度拆解&quot;&gt;&lt;/a&gt;《杀戮尖塔》设计内容深度拆解&lt;/h1&gt;&lt;h6 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写</summary>
      
    
    
    
    <category term="游戏" scheme="https://yifei-huang-cos.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>杀戮尖塔设计拆解————数值篇</title>
    <link href="https://yifei-huang-cos.github.io/posts/eff9c8a5/"/>
    <id>https://yifei-huang-cos.github.io/posts/eff9c8a5/</id>
    <published>2026-01-28T02:00:00.000Z</published>
    <updated>2026-01-28T03:17:56.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《杀戮尖塔》数值设计深度拆解"><a href="#《杀戮尖塔》数值设计深度拆解" class="headerlink" title="《杀戮尖塔》数值设计深度拆解"></a>《杀戮尖塔》数值设计深度拆解</h1><p>​在卡牌与Roguelike融合的游戏品类中，《杀戮尖塔》的成功离不开其精妙且恰到好处的数值设计。作为一款策略类，以决策为核心乐趣的游戏，它不依靠华丽的特效或复杂的剧情，而是通过能量、卡牌、遗物、难度等多维度的数值平衡，构建了“战斗-奖励-提升”的数值循环与“费用-收益”匹配的价值曲线，最终形成既充满随机性又具备可控策略空间的体验闭环。</p><p>​我累计500余小时的攀登历程中，深刻感受到每一处数值细节都暗藏策划巧思，下文将结合参考文章的权威数值体系，从核心资源价值、卡牌数值架构、遗物联动逻辑、难度平衡设计四个核心维度，拆解其数值设计的精髓。</p><hr><h2 id="⚡-一、核心资源数值（能量）：作为抉择基石"><a href="#⚡-一、核心资源数值（能量）：作为抉择基石" class="headerlink" title="⚡ 一、核心资源数值（能量）：作为抉择基石"></a>⚡ 一、核心资源数值（能量）：作为抉择基石</h2><p>​《杀戮尖塔》的战斗数值体系中，每回合的能量是贯穿始终的核心约束变量，其数值设定直接决定了策略决策的深度，且存在明确的价值量化标准。游戏初始默认单回合能量上限为3点（部分职遗物可提升），能量存在固定价值曲线：0点能量基础价值为3，之后每增加1点能量额外提供2点价值，这一量化标准构成了卡牌设计的核心基准，而非简单的“3点约束”。这一数值体系实则构建了“攻击-防御-能量-运转”的四维策略平衡，迫使玩家在每回合进行精准的资源分配与机会成本权衡。</p><h4 id="🔹-1-1-从设计意图来看"><a href="#🔹-1-1-从设计意图来看" class="headerlink" title="🔹 1.1 从设计意图来看"></a>🔹 1.1 从设计意图来看</h4><p>​初始3点能量的数值设定是价值曲线与策略深度的最优解：若能量过多，玩家可同时触发多个高价值连携效果，策略抉择的价值会大幅降低；若能量过少，则无法支撑基础连携的触发，破坏卡组运转流畅度。3点能量恰好让玩家每回合需在基础输入+单一乘区或者多乘区组合但基础输入弱化等策略中抉择。</p><p>​面对一层精英敌人乐嘉（额这是外号，具体名字不记得了QAQ）即将到来的高额攻击，玩家需在1费防御（5格挡，价值匹配）+2费攻击（打击1费打6）与2费防御（初始防御1费5格挡）+1费运转（抽牌调整手牌）之间权衡，而这种抉择直接关联生命值资源的消耗与留存，正是数值驱动策略乐趣的核心来源。</p><p>​值得注意的是，即使是0费卡牌也存在隐性成本，其占用的抽牌位会导致错过其他关键卡牌，这一机会成本同样被纳入能量价值体系的考量范畴。</p><h4 id="🔹-1-2-能量数值的弹性设计进一步丰富了策略维度"><a href="#🔹-1-2-能量数值的弹性设计进一步丰富了策略维度" class="headerlink" title="🔹 1.2 能量数值的弹性设计进一步丰富了策略维度"></a>🔹 1.2 能量数值的弹性设计进一步丰富了策略维度</h4><p>​游戏通过融合之锤（boss遗物）孙子兵法（普通遗物）等遗物提供能量加成，例如孙子兵法的设定是：如果不使用攻击卡下回合+1能量，本质是通过策略选择换取能量价值的提升（额外获得2点基础价值）；而许多boss遗物通过支付某些特定代价（例如锤子：火堆无法升级牌；绿帽：无法获得金币）换取每回合稳定多一费。这种代价支付加稳定收益的数值设计，既保证了体系的稳定性，又为流派构建提供了多样化可能。</p><hr><h2 id="🃏-二、卡牌数值体系（费效比）：精准定位与价值平衡"><a href="#🃏-二、卡牌数值体系（费效比）：精准定位与价值平衡" class="headerlink" title="🃏 二、卡牌数值体系（费效比）：精准定位与价值平衡"></a>🃏 二、卡牌数值体系（费效比）：精准定位与价值平衡</h2><p>​卡牌是玩家实现策略意图的核心载体，《杀戮尖塔》的卡牌数值设计遵循：卡组定位、费效比、联动组件三大原则，核心逻辑是以能量价值为基准，构建‘基础输入-乘区放大-导出转化’的强度公式，确保不同类型、不同费用的卡牌在性价比上保持平衡，同时尽可能避免策略单一化，掩盖其他玩法的问题。单张卡牌效果普遍简洁，仅提供基础输入或单一乘区，需通过组合形成强大连携，这既降低了玩家记忆成本，又提升了策略深度。</p><h4 id="⚠️-2-1-插一句设计缺陷"><a href="#⚠️-2-1-插一句设计缺陷" class="headerlink" title="⚠️ 2.1 插一句设计缺陷"></a>⚠️ 2.1 插一句设计缺陷</h4><p>​（上一段所说的避免策略单一化只在前两个职业，即战士和猎人上完成的较为完美，而我们鸡煲，呃呃，懂得都懂，问就是还在启动，在启动。观者的设计则是严重不平衡，暴怒带来的双倍伤害让其很多职业卡的费效比不尽人意，红蓝无限的玩法带来的收益又过于超模，掩盖了观者的神格预见点穴等体系。虽说这几个体系本来也有数值不足的问题。只能说观者的出现，对玩家来说可能是玩起来比较容易爽的角色，但从数值设计的角度看，无疑是失败的）</p><h4 id="🔹-2-2-在攻击卡牌设计中"><a href="#🔹-2-2-在攻击卡牌设计中" class="headerlink" title="🔹 2.2 在攻击卡牌设计中"></a>🔹 2.2 在攻击卡牌设计中</h4><p>​数值严格匹配能量价值曲线，且通过“基础输入+乘区”的组合形成差异化定位。</p><p>​1费的打击基础伤害为6点（价值2，匹配1费能量价值5中的基础部分），2费的重击伤害为14点且附带3倍力量加成（价值5+2，2费能量价值7完全匹配），而非简单的倍数关系；0费的愤怒可造成6点伤害并在弃牌堆放入一张自身，收益为2+1（额外留存卡牌资源），精准匹配0费能量3点的基础价值。</p><p>​不同卡牌的乘区特性适配不同流派：战士的重击依赖力量乘区实现爆发输出，静默猎手的0费小刀则通过多次攻击乘区触发精准，袖箭等被动效果，成为小刀流的核心输入组件。这种设计让低费卡并非弱卡，而是适配高频连击流派，高费卡则需放弃当回合其他资源，形成明确的机会成本权衡。</p><h4 id="🔹-2-3-防御卡牌的数值设计同样遵循价值曲线，且聚焦临时防护"><a href="#🔹-2-3-防御卡牌的数值设计同样遵循价值曲线，且聚焦临时防护" class="headerlink" title="🔹 2.3 防御卡牌的数值设计同样遵循价值曲线，且聚焦临时防护"></a>🔹 2.3 防御卡牌的数值设计同样遵循价值曲线，且聚焦临时防护</h4><p>​游戏将格挡设定为临时性防御资源，没有特殊卡牌和遗物的情况下防御不会保留，1点格挡等价于1点生命值。</p><p>​1费的初始卡防御提供5点格挡（价值匹配1费能量），2费的稀有卡岿然不动提供30点格挡，但是是消耗卡，不能够反复利用。玩家可根据敌方伤害数值选择合适的防御卡牌：面对小额持续伤害，优先使用低费防御卡节省能量；面对大额单次伤害，则需投入高费防御卡或组合多张防御卡。</p><p>​更关键的是，防御维度可通过特定卡牌转化为攻击强度，例如战士的肚皮（全身撞击，未升级是1费，升级后变成0费）可造成当前格挡值的攻击伤害，将防御资源转化为输出输入，这一设计打破了维度壁垒，让“高防御+高输出”的防战流派成为可能。而能力卡壁垒可以保留格挡值的设定，更是强化了防御乘区的效果，让格挡资源可跨回合累积，催生格挡转伤害的防御流派。</p><h4 id="🔹-2-4-卡牌升级的数值提升也严格匹配价值均衡原则"><a href="#🔹-2-4-卡牌升级的数值提升也严格匹配价值均衡原则" class="headerlink" title="🔹 2.4 卡牌升级的数值提升也严格匹配价值均衡原则"></a>🔹 2.4 卡牌升级的数值提升也严格匹配价值均衡原则</h4><p>​打击升级后伤害从6提升至9（提升幅度50%），防御升级后格挡从5提升至8（提升幅度60%），升级后的价值仍与能量费用精准匹配，既让升级后的卡牌具备明显优势，又不会让未升级卡牌完全失效。这一设计确保玩家在升级卡牌与回复生命的火堆处选择中产生策略博弈——是提升长期战力以减少后续生命值消耗，还是保证当前生存以规避即时风险？这种博弈让每一次火堆选择都成为影响数值循环的关键决策。</p><hr><h2 id="🧩-三、遗物数值联动：打破基础规则的策略裂变引擎"><a href="#🧩-三、遗物数值联动：打破基础规则的策略裂变引擎" class="headerlink" title="🧩 三、遗物数值联动：打破基础规则的策略裂变引擎"></a>🧩 三、遗物数值联动：打破基础规则的策略裂变引擎</h2><p>​遗物系统是《杀戮尖塔》数值设计的点睛之笔，其核心价值在于通过“数值加成+机制改变”的组合，优化卡组的体系，催生多样化的流派构建。遗物的数值设计并非简单的数值堆砌，而是精准匹配卡牌的连携逻辑，同时服务于“战斗-奖励-提升”的数值循环（因为遗物通常由精英怪掉落，而打精英怪可能面临生存危险，你说是吧鸡煲TvT（还在启动，在启动，启动，启…）），与卡牌体系形成约束和强化的联动闭环——没有合适的卡牌组合，遗物的数值优势无法发挥；缺少遗物的数值加持，卡牌组合也难以形成质变。</p><h4 id="🔹-3-1-普通遗物：补充短板和优化体验为主"><a href="#🔹-3-1-普通遗物：补充短板和优化体验为主" class="headerlink" title="🔹 3.1 普通遗物：补充短板和优化体验为主"></a>🔹 3.1 普通遗物：补充短板和优化体验为主</h4><p>​战士的初始遗物“燃烧之血”效果是战斗后回血6点，解决了前期回血资源稀缺的问题，让玩家可更激进地挑战战斗；普通遗物背包的效果是第一轮多抽2张牌，提升关键牌上手率，降低第一轮的鬼抽概率；还有商店遗物工具箱，棱镜，前者可以每场战斗3选1一张无色牌，就冲着能选到神话和打钱手这也是必买遗物，而棱镜则打破职业卡限制，让选择里多出其他职业的职业卡，可能会选出梦寐以求的配合（鸡煲：我要学猛虎下山！）。这些数值设计虽看似微小，但能显著优化特定职业的前期体验，引导玩家向职业核心流派靠拢。</p><h4 id="🔹-3-2-罕见遗物与Boss遗物则通过数值质变和机制突破催生全新策略，同时兼顾对单一策略的抑制"><a href="#🔹-3-2-罕见遗物与Boss遗物则通过数值质变和机制突破催生全新策略，同时兼顾对单一策略的抑制" class="headerlink" title="🔹 3.2 罕见遗物与Boss遗物则通过数值质变和机制突破催生全新策略，同时兼顾对单一策略的抑制"></a>🔹 3.2 罕见遗物与Boss遗物则通过数值质变和机制突破催生全新策略，同时兼顾对单一策略的抑制</h4><p>​钢笔尖设定“每第十张攻击造成双倍伤害，将“低费复用输出的运转转化为攻击乘区，引导玩家调整高费攻击卡排序；蛇眼作为boss遗物，效果是每回合多抽2张，但所有卡牌的费用会从0到3费随机，解决了过牌问题，也让玩家多抓高费卡少带低费卡。</p><p>​而针对飞身踢无限等可能导致策略退化的玩法，游戏通过数值限制进行平衡——飞身踢基础伤害仅5点（低于初始打击的6点），且需目标有易伤效果才能打出，提升了连携成本；同时Boss“时间吞噬者”设定玩家每打出12张牌后强制结束回合，从机制上限制低数值无限的强度（比如亮剑【0费打3抽1】妙计【0费防2抽1】相互抽的低数值无限），确保各流派的平衡。</p><hr><h2 id="📊-四、难度梯度数值：动态平衡的“学习型”挑战曲线"><a href="#📊-四、难度梯度数值：动态平衡的“学习型”挑战曲线" class="headerlink" title="📊 四、难度梯度数值：动态平衡的“学习型”挑战曲线"></a>📊 四、难度梯度数值：动态平衡的“学习型”挑战曲线</h2><p>​《杀戮尖塔》的进阶等级系统是其数值难度设计的核心，最高20级的进阶梯度并非简单提升敌人血量与伤害，而是通过“精准数值微调+规则约束增加”的方式，扰动核心数值循环，构建平滑且富有深度的学习型挑战曲线。其设计逻辑与玩家策略成长相匹配，低进阶等级调整普通敌人数值，引导玩家熟悉卡牌与遗物的基础连携；高进阶等级则通过规则约束强化数值压力，迫使玩家优化卡组构建策略。</p><h4 id="🔹-4-1-进阶难度的数值设计"><a href="#🔹-4-1-进阶难度的数值设计" class="headerlink" title="🔹 4.1 进阶难度的数值设计"></a>🔹 4.1 进阶难度的数值设计</h4><p>​遵循蝴蝶效应原则，通过微小的数值调整引发策略连锁反应。例如进阶17后，二层普通敌人三鸟的坠机条件从受击3次变为受击4次，看似仅增加1次受击需求，却直接提升了对运转维度与攻击频率的要求（经典是观者的发泄，不敲三段伤害，敲了4段伤害，在低进阶一个发泄就可以把三鸟肘下来，在高进阶则刚需升级）——低费高频攻击卡组需多花费1回合才能击落，可能导致暴露在敌方多轮攻击下，增加生命值消耗。</p><p>​而进阶20中，普通敌人壳爹＋蘑菇（开幕21和他的易伤药，已经畏惧了 …）第一回合伤害从18点提升至21点并附加脆弱Debuff），这一调整直接放大了防御维度的价值缺口，迫使玩家必须在前期就构建足够的防御体系，否则极易血量崩盘。这种差一点就通关的数值设计，既不会让玩家产生挫败感，又能推动玩家深化对数值体系的理解，优化策略决策以适配更严苛的数值循环。</p><h4 id="🔹-4-2-高进阶等级的规则约束"><a href="#🔹-4-2-高进阶等级的规则约束" class="headerlink" title="🔹 4.2 高进阶等级的规则约束"></a>🔹 4.2 高进阶等级的规则约束</h4><p>​进阶10后，玩家初始生命上限减少，这一数值调整直接提升了前期生命值资源的稀缺性，让血量管理成为核心决策点，同时放大了燃烧血、羽毛、梨子、华夫饼等回血与生命上限提升类遗物的价值（当然丢人枕头除外）；进阶15后“商店卡牌价格提升”，则扰动了经济数值循环，迫使玩家更谨慎地分配金币资源，优先选择移除低价值初始卡牌（指打击）而非盲目购买新卡。</p><p>这些设计形成了难度约束与策略适配的动态平衡，确保玩家在提升技巧的同时，始终能获得匹配的挑战体验。</p><hr><h2 id="🎯-结语：数值驱动的策略乐趣闭环"><a href="#🎯-结语：数值驱动的策略乐趣闭环" class="headerlink" title="🎯 结语：数值驱动的策略乐趣闭环"></a>🎯 结语：数值驱动的策略乐趣闭环</h2><p>​《杀戮尖塔》的数值设计之所以精妙，在于其构建了一个“价值基准-连携放大-循环闭环-难度适配”的完整体系：以能量价值曲线为基础基准，通过卡牌的“基础输入-乘区-导出”架构实现策略落地，借助遗物优化或打破基础规则以丰富流派，再通过难度调整扰动数值循环，推动玩家深化策略理解。</p><p>​整个体系的核心是生命值等价原则，所有资源最终都可转化为生命值的留存能力，而每一处数值细节都服务于策略决策的核心乐趣——让玩家在随机生成的尖塔中，通过解读数值关系、组合连携模块、适配数值循环，不断探索全新的构筑可能性。这种以数值为骨架，以策略为血肉的设计思路，不仅避免了策略退化，保证了多流派的平衡共存，更成就了《杀戮尖塔》的经典地位，为后续卡牌Roguelike游戏的数值设计提供了可借鉴的核心框架。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;《杀戮尖塔》数值设计深度拆解&quot;&gt;&lt;a href=&quot;#《杀戮尖塔》数值设计深度拆解&quot; class=&quot;headerlink&quot; title=&quot;《杀戮尖塔》数值设计深度拆解&quot;&gt;&lt;/a&gt;《杀戮尖塔》数值设计深度拆解&lt;/h1&gt;&lt;p&gt;​		在卡牌与Roguelike融合的游戏品</summary>
      
    
    
    
    <category term="游戏" scheme="https://yifei-huang-cos.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>AI x game 深度体验报告</title>
    <link href="https://yifei-huang-cos.github.io/posts/2c281e1a/"/>
    <id>https://yifei-huang-cos.github.io/posts/2c281e1a/</id>
    <published>2026-01-27T03:28:30.000Z</published>
    <updated>2026-01-27T03:52:18.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AI-x-game体验报告——是不可替代还是锦上添花？"><a href="#AI-x-game体验报告——是不可替代还是锦上添花？" class="headerlink" title="AI x game体验报告——是不可替代还是锦上添花？"></a>AI x game体验报告——是不可替代还是锦上添花？</h1><h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>AI技术近年来发展迅猛，其迭代进程与应用成果已深深融入社会生活各领域，给大众带来了直观且深刻的感知。在此背景下，将AI技术与游戏产业相结合的创作理念逐渐成为热点，各类融合AI元素的新兴游戏产品如同雨后春笋般涌现。</p><p>不过，虽然很多游戏都使用AI，但他们的设计理念却不尽相同。有些是利用AI增添新的模块，像是在游戏里增加了接入大模型的可交互的NPC，增加UGC中的AI创作辅助；有些是基于AI构建新的玩法，比如构建一个全部由AI agent构成的社区，观察或参与他们的行为，在这个游戏里，AI是构建整个玩法的底层逻辑；或者更加简单通用一点，只是利用AI进行美术建模和文本的辅助创作……这些游戏到底怎么样，好不好玩，对AI的使用又究竟到了哪一步？我将在其中选择几种具有代表性的进行体验。</p><h1 id="二、游玩体验"><a href="#二、游玩体验" class="headerlink" title="二、游玩体验"></a>二、游玩体验</h1><h2 id="1-AI-陪伴类：情绪价值的提供者"><a href="#1-AI-陪伴类：情绪价值的提供者" class="headerlink" title="1. AI-陪伴类：情绪价值的提供者"></a>1. AI-陪伴类：情绪价值的提供者</h2><p>现代社会中，快节奏的学习与工作节奏使得部分群体面临人际交往困境，或因社交适应障碍，或因缺乏有效倾诉对象，其情绪宣泄需求难以得到充分满足。在此背景下，在游戏场景中植入AI陪伴功能的设计理念应运而生，为解决此类群体的情绪需求提供了新的载体。</p><h3 id="1-1-王者荣耀的灵宝系统-x2F-和平精英AI战犬玩法"><a href="#1-1-王者荣耀的灵宝系统-x2F-和平精英AI战犬玩法" class="headerlink" title="1.1 王者荣耀的灵宝系统&#x2F;和平精英AI战犬玩法"></a>1.1 王者荣耀的灵宝系统&#x2F;和平精英AI战犬玩法</h3><p>2024年2月，王者荣耀上线了灵宝系统；25年11月，和平推出了AI战犬模式。直到今日，灵宝系统也一直在优化与迭代升级，就我个人的体验来说，我还是非常喜欢这个几个小家伙的。为什么这么说呢，我认为这种局内陪伴满足了以下几个优点：</p><h4 id="1-1-1-游戏操作正反馈，提供情绪价值"><a href="#1-1-1-游戏操作正反馈，提供情绪价值" class="headerlink" title="1.1.1 游戏操作正反馈，提供情绪价值"></a>1.1.1 游戏操作正反馈，提供情绪价值</h4><p>尤其在自己单排的时候，4个队友全部闭麦很常见。无论在你打出精彩操作拿到完美击杀还是在大逆风时刻出其不意抢下大龙，队友不一定会夸你，都在闭麦干自己的事。这无可厚非，但没有人为你欢呼 难免会失落。但有灵宝就不一样，他夸奖人来比谁都快<del>比如我玩兰陵王喜欢开局反（tou）对面红buff，每每打完红之后听灵宝来一句：“拿下对面红buff，对面打野恐怕要气疯了吧</del>” 欸嘿，心情就会非常舒坦。</p><h4 id="1-1-2-局内提供帮助，利好休闲玩家"><a href="#1-1-2-局内提供帮助，利好休闲玩家" class="headerlink" title="1.1.2 局内提供帮助，利好休闲玩家"></a>1.1.2 局内提供帮助，利好休闲玩家</h4><p>王者荣耀与和平精英作为国民级手游，拥有庞大的玩家群体，这进一步导致了休闲玩家的比例占绝大多数。相比于硬核玩家，他们的游戏技术或意识显得会比较低。那如何更好的照顾到这类玩家的游戏体验呢？局内陪伴的另一个作用便显现出来了。这里那和平的战犬举例，给出对应的语音指令，战犬便会帮忙收集物资，牵制敌人，或者救助队友，很好的避免了轻度玩家进入游戏后的手忙脚乱。并且他的功能性设计，也不会对游戏平衡性造成很大的破坏。对我这个新手来说，算是帮大忙了</p><h4 id="1-1-3-活跃游戏气氛，调节玩家情绪"><a href="#1-1-3-活跃游戏气氛，调节玩家情绪" class="headerlink" title="1.1.3 活跃游戏气氛，调节玩家情绪"></a>1.1.3 活跃游戏气氛，调节玩家情绪</h4><p>在现代社会中，比完整的游戏时间更难得的是有个和你一起打游戏的朋友，不一定两个人都有时间。所以很多时候我都是单排自己玩，难免会感到寂寞，此时局内陪伴的作用就来了，时不时来两句插科打诨，也可博君一笑。</p><h3 id="1-2-星之低语-x2F-EVE（后者目前只有二测演示视频）"><a href="#1-2-星之低语-x2F-EVE（后者目前只有二测演示视频）" class="headerlink" title="1.2 星之低语&#x2F;EVE（后者目前只有二测演示视频）"></a>1.2 星之低语&#x2F;EVE（后者目前只有二测演示视频）</h3><h4 id="1-2-1-whispered-from-the-star"><a href="#1-2-1-whispered-from-the-star" class="headerlink" title="1.2.1 whispered from the star"></a>1.2.1 whispered from the star</h4><p>该产品是由蔡浩宇主导开发的AI对话类游戏，核心玩法围绕玩家与游戏内漂泊太空的女性角色展开全程对话交互，通过AI的引导与玩家的决策推进剧情。我体验了两个小时，怎么说呢，个人觉得这更像是一款实验品，验证人机交互逻辑和语音识别的先行者，而不是一个完整的游戏。从目前的技术力来看，星之低语的交互建模语音生成乃至情感叙事无疑都走在同类型赛道的前列。但是问题在于，游戏性的缺失导致这不像一个游戏，更像是一次英语口语练习（笑）。其体验的瓶颈也显而易见：后期的交互易陷入重复，缺乏真正的情感弧线与剧情张力。当然啦，它的技术力很强也是无可反驳的。我目前更倾向于认为这是一款公开的试验田，为以后的模型收集数据和反馈，期待他们的下一款游戏。</p><h4 id="1-2-2-EVE"><a href="#1-2-2-EVE" class="headerlink" title="1.2.2 EVE"></a>1.2.2 EVE</h4><p>相比于上面一款，这个游戏的理念更加贴近于传统AI陪伴的概念。该产品以构建3D虚拟伴侣为核心，规划实现对话交互、语音通话、生活服务提醒（如点奶茶、购药等）等功能。由于该产品计划于今年三月公测，且优先面向女性向用户群体，我的体验仅基于测试玩家发布的演示视频进行分析。</p><p>从行业发展视角来看，《EVE》的产品形态本身并非我们的关注核心，其背后的设计思路更具行业参考价值。该产品精准命中了AI陪伴领域的核心潜在需求——为用户提供符合个性化想象的、以用户为中心的虚拟伴侣。无论《EVE》正式上线后的市场表现如何，其开创的产品方向必然会引发行业内其他游戏工作室的跟进。社会调查数据显示，大龄单身青年群体规模持续扩大，此类群体的情感需求并未因单身状态而消失，对情感替代载体的需求日益凸显。而具备高真实度交互能力的AI虚拟伴侣，恰好能够满足这一需求。未来，该赛道有望涌现更多高技术力产品，但如何实现产品差异化竞争，将成为我们需要深入思考的核心问题。</p><h2 id="2-AI-NPC：最多的可能性，但被技术力约束"><a href="#2-AI-NPC：最多的可能性，但被技术力约束" class="headerlink" title="2. AI NPC：最多的可能性，但被技术力约束"></a>2. AI NPC：最多的可能性，但被技术力约束</h2><p>曾经，NPC所说的话总是由文案策划构思好，虽然这对于游戏的推进来说是最快捷的方式，但看多了不免感到乏味。随着LLM的兴起，大家不约而同的想到那个可能性————让大模型控制NPC的交流行为甚至剧情。</p><h3 id="2-1-逆水寒-x2F-燕云十六声"><a href="#2-1-逆水寒-x2F-燕云十六声" class="headerlink" title="2.1 逆水寒&#x2F;燕云十六声"></a>2.1 逆水寒&#x2F;燕云十六声</h3><p>在我印象里，逆水寒最早大规模宣传自己的AI npc，当时我也是因为这个宣传下载体验了一番汴京的风土人情。当时也涌现了很多与AI对话的“焚诀”，和ai npc斗智斗勇也成了每天上线不得不品的一环。乐趣确实有，也能通过文字交流得到npc的物品，在当时给我感觉还是比较新奇有趣的。</p><p>比较可惜的是，这些玩法没有更进一步，你和npc的对话对游戏主体的影响微乎其微，也基本在主线剧情中得不到体现。在这两款游戏里，AI不是一个不可代替的玩法，只是一个外接的模块，可以说删了这个功能换成传统的npc对话形式也不会对游戏产生多大影响。只能说这是受限于目前的技术力，还无法做到AI影响的多剧情分支走向（也可能是不方便管理？）</p><h3 id="2-2-AI-bot，觉悟人机"><a href="#2-2-AI-bot，觉悟人机" class="headerlink" title="2.2 AI bot，觉悟人机"></a>2.2 AI bot，觉悟人机</h3><p>这就比较的传统并且成熟了，在游戏对局内补充人机有利于减少玩家匹配时间，控制对局强度，也有利于新手玩家熟悉游戏，由于在大部分游戏里已经有了较为成熟的应用，本文不再赘述</p><h2 id="3-AI作为游戏基石：未来将至？"><a href="#3-AI作为游戏基石：未来将至？" class="headerlink" title="3. AI作为游戏基石：未来将至？"></a>3. AI作为游戏基石：未来将至？</h2><p>以上是在传统的游戏中增添AI的元素，那么我们有没有可能以AI为底层逻辑创建一个游戏呢？很多影视文学作品都给出过设想，例如头号玩家，失控玩家以及前几年较火的元宇宙概念，他们都给我们提供了一种可能性。我也很高兴的看到有很多游戏在向这方面发展，例如斯坦福小镇，avilizition以及喵吉托的几款游戏demo（例如喵呜岛）。</p><h3 id="3-1-avilizition的体验"><a href="#3-1-avilizition的体验" class="headerlink" title="3.1 avilizition的体验"></a>3.1 avilizition的体验</h3><p>这个项目更准确地应该称为一个模拟平台。它的核心理念非常吸引人（也是我所展望追求的）：每个智能体都有独立的记忆、人际关系和日程，所有的决策都具有蝴蝶效应，npc并能根据与环境和彼此的互动来动态决策。</p><p>我的体验过程充满了新奇与困惑。一开始，我就像进入了一个上帝视角的观察者，看着这些像素小人在小镇里活动，他们会上班、购物、聊天、举办活动。最让我感到惊讶的是，他们之间的互动确实能产生一些预设脚本之外的故事。比如，我看到两个角色因为在咖啡馆的一次聊天而决定晚上一起去酒吧，或者因为之前的某次争执而在下一次见面时显得冷淡。这种基于记忆和关系链产生的行为变化，是它最核心的亮点，让你感觉这个小镇是活的，有自己的时间流。</p><p>但是，这种新鲜感褪去得也很快。首先是交互的乏力感。作为玩家，我能与这些AI角色对话，但对话内容往往流于表面，很难进行有深度的、能实质性改变他们目标或关系的交流。更多的时候，我感觉我是在试图引导对话，而不是在进行有意义的角色扮演。avilizition给我的感觉是，它是一座通往未来游戏理念的桥梁设计图，但我们脚下的建筑材料还不足以把它扎实地建造起来。它足以证明了AI作为游戏世界底层逻辑的可行性，但要把它变成一款好玩的游戏，还有很长的路要走。</p><h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>经过这些体验，我认为目前AI在游戏中的应用，整体上仍然处于“锦上添花”的阶段。无论是提供陪伴的灵宝、战犬，还是能自由对话的NPC，它们确实带来了新鲜感和更好的体验，像是给原有的蛋糕裱上了更精美的花。但如果我们把花拿走，蛋糕本身并没有改变。它们更多是体验的优化与内容的补充。</p><p>然而，从《星之低语》、《EVE》这类纯粹的AI交互应用，尤其是像avilizition这样以AI为世界基石的尝试中，我们能看到一种截然不同的可能性。它们不再满足于做蛋糕上的点缀，而是试图用AI这种新材料，从头烤制一块全新的、我们从未尝过的点心。虽然目前这些可能还有些生涩，形态也不稳定，但方向已经指明。</p><p>所以，我的看法是：未来，AI完全有可能成为构建游戏里不可替代的基石。这条路很长，但起点已经在我们脚下。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AI-x-game体验报告——是不可替代还是锦上添花？&quot;&gt;&lt;a href=&quot;#AI-x-game体验报告——是不可替代还是锦上添花？&quot; class=&quot;headerlink&quot; title=&quot;AI x game体验报告——是不可替代还是锦上添花？&quot;&gt;&lt;/a&gt;AI x </summary>
      
    
    
    
    <category term="游戏" scheme="https://yifei-huang-cos.github.io/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>刚体运动的python解法</title>
    <link href="https://yifei-huang-cos.github.io/posts/48befe4f/"/>
    <id>https://yifei-huang-cos.github.io/posts/48befe4f/</id>
    <published>2026-01-26T08:53:00.000Z</published>
    <updated>2026-01-27T00:40:45.463Z</updated>
    
    <content type="html"><![CDATA[<h1 id="自由转动杆与铰链固定杆倾倒时间对比研究"><a href="#自由转动杆与铰链固定杆倾倒时间对比研究" class="headerlink" title="自由转动杆与铰链固定杆倾倒时间对比研究"></a><strong>自由转动杆与铰链固定杆倾倒时间对比研究</strong></h1><h2 id="一、问题背景"><a href="#一、问题背景" class="headerlink" title="一、问题背景"></a>一、问题背景</h2><p>​某p大友人中午问了我一个问题</p><p>​<img src="/../images/%E5%88%9A%E4%BD%93%E5%8A%A8%E5%8A%9B.png"></p><hr><p>曾经自诩“高中物理领域神棍”的我也是体会了一把修为尽失的感觉…….可恶，还是，做不到吗。。。</p><p>才怪！现在我有了新的武器，解析不了我就暴力数值解嘻嘻</p><h2 id="二、物理模型"><a href="#二、物理模型" class="headerlink" title="二、物理模型"></a>二、物理模型</h2><h3 id="2-1-自由杆（光滑地面）"><a href="#2-1-自由杆（光滑地面）" class="headerlink" title="2.1 自由杆（光滑地面）"></a>2.1 自由杆（光滑地面）</h3><ul><li><strong>约束条件</strong>：底端无水平约束，质心水平方向动量守恒</li><li><strong>运动特点</strong>：质心同时有平动和转动</li><li><strong>能量方程</strong>：$E &#x3D; \frac{1}{2}mv_c^2 + \frac{1}{2}I_c\omega^2 + mg\frac{L}{2}\cos\theta$</li></ul><h3 id="2-2-铰链杆（固定底端）"><a href="#2-2-铰链杆（固定底端）" class="headerlink" title="2.2 铰链杆（固定底端）"></a>2.2 铰链杆（固定底端）</h3><ul><li><strong>约束条件</strong>：底端位置固定，绕该点纯转动</li><li><strong>运动特点</strong>：质心作圆弧运动</li><li><strong>能量方程</strong>：$E &#x3D; \frac{1}{2}I_o\omega^2 + mg\frac{L}{2}\cos\theta$</li></ul><hr><h2 id="三、动力学方程推导"><a href="#三、动力学方程推导" class="headerlink" title="三、动力学方程推导"></a>三、动力学方程推导</h2><h3 id="3-1-自由杆的倾倒时间"><a href="#3-1-自由杆的倾倒时间" class="headerlink" title="3.1 自由杆的倾倒时间"></a>3.1 自由杆的倾倒时间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自由杆的角速度公式推导</span></span><br><span class="line">ω² = (4g/L) * (cosθ₀ - cosθ)</span><br></pre></td></tr></table></figure><h3 id="3-2-铰链杆的倾倒时间"><a href="#3-2-铰链杆的倾倒时间" class="headerlink" title="3.2 铰链杆的倾倒时间"></a>3.2 铰链杆的倾倒时间</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 铰链杆的角速度公式推导</span></span><br><span class="line">ω² = (3g/L) * (cosθ₀ - cosθ)</span><br></pre></td></tr></table></figure><hr><h2 id="四、数值计算方法"><a href="#四、数值计算方法" class="headerlink" title="四、数值计算方法"></a>四、数值计算方法</h2><h3 id="4-1-时间积分公式"><a href="#4-1-时间积分公式" class="headerlink" title="4.1 时间积分公式"></a>4.1 时间积分公式</h3><p>倾倒时间通过对角速度倒数积分得到：<br>$$ t &#x3D; \int_{\theta_0}^{\pi&#x2F;2} \frac{1}{\omega(\theta)} d\theta $$</p><h3 id="4-2-数值实现代码"><a href="#4-2-数值实现代码" class="headerlink" title="4.2 数值实现代码"></a>4.2 数值实现代码</h3><h4 id="自由杆计算代码"><a href="#自由杆计算代码" class="headerlink" title="自由杆计算代码"></a>自由杆计算代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">g = <span class="number">9.81</span></span><br><span class="line">L = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入杆长 L (米): &quot;</span>))</span><br><span class="line">theta0_deg = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入初始倾斜角度 (0–90°, 相对竖直): &quot;</span>))</span><br><span class="line"></span><br><span class="line">theta0 = np.deg2rad(theta0_deg)</span><br><span class="line">theta_end = np.pi / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">integrand</span>(<span class="params">theta</span>):</span><br><span class="line">    omega = np.sqrt((<span class="number">4</span> * g / L) * (np.cos(theta0) - np.cos(theta)))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / omega</span><br><span class="line"></span><br><span class="line">thetas = np.linspace(theta0 + <span class="number">1e-6</span>, theta_end, <span class="number">200000</span>)</span><br><span class="line">t = np.trapezoid(integrand(thetas), thetas)</span><br></pre></td></tr></table></figure><h4 id="铰链杆计算代码"><a href="#铰链杆计算代码" class="headerlink" title="铰链杆计算代码"></a>铰链杆计算代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">g = <span class="number">9.81</span></span><br><span class="line">L = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入杆长 L (米): &quot;</span>))</span><br><span class="line">theta0_deg = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入初始倾斜角度 (0–90°, 相对竖直): &quot;</span>))</span><br><span class="line"></span><br><span class="line">theta0 = np.deg2rad(theta0_deg)</span><br><span class="line">theta_end = np.pi / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">integrand</span>(<span class="params">theta</span>):</span><br><span class="line">    omega = np.sqrt((<span class="number">3</span> * g / L) * (np.cos(theta0) - np.cos(theta)))</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> / omega</span><br><span class="line"></span><br><span class="line">thetas = np.linspace(theta0 + <span class="number">1e-6</span>, theta_end, <span class="number">200000</span>)</span><br><span class="line">t = np.trapezoid(integrand(thetas), thetas)</span><br></pre></td></tr></table></figure><hr><h2 id="五、模拟结果分析"><a href="#五、模拟结果分析" class="headerlink" title="五、模拟结果分析"></a>五、模拟结果分析</h2><h4 id="5-1-不同初始角度对比（默认杆长1m）"><a href="#5-1-不同初始角度对比（默认杆长1m）" class="headerlink" title="5.1 不同初始角度对比（默认杆长1m）"></a>5.1 不同初始角度对比（默认杆长1m）</h4><table><thead><tr><th>初始角度</th><th>自由杆时间(s)</th><th>铰链杆时间(s)</th><th>时间比(自由&#x2F;铰链)</th></tr></thead><tbody><tr><td>1°</td><td>1.1837</td><td>1.3668</td><td>想算的自己算</td></tr><tr><td>10°</td><td>0.6648</td><td>0.7676</td><td></td></tr><tr><td>30°</td><td>0.4163</td><td>0.4807</td><td>(—&gt; __  —&gt;)</td></tr><tr><td>45°</td><td>0.3201</td><td>0.3697</td><td></td></tr><tr><td>60°</td><td>0.2431</td><td>0.2807</td><td></td></tr><tr><td>80°</td><td>0.1338</td><td>0.1545</td><td></td></tr></tbody></table><h3 id="5-2-不同杆长对比（默认倾斜30°）"><a href="#5-2-不同杆长对比（默认倾斜30°）" class="headerlink" title="5.2 不同杆长对比（默认倾斜30°）"></a>5.2 不同杆长对比（默认倾斜30°）</h3><table><thead><tr><th>杆长(m)</th><th>自由杆时间(s)</th><th>铰链杆时间(s)</th><th>时间比</th></tr></thead><tbody><tr><td>0.5</td><td>0.2944</td><td>0.3399</td><td></td></tr><tr><td>1.0</td><td>0.4163</td><td>0.4807</td><td></td></tr><tr><td>2.0</td><td>0.5888</td><td>0.6799</td><td></td></tr><tr><td>5.0</td><td>0.9309</td><td>1.0750</td><td></td></tr></tbody></table><hr><h2 id="六、结论"><a href="#六、结论" class="headerlink" title="六、结论"></a>六、结论</h2><p>自由杆下落更快！</p><p>但原因是什么呢</p><p>有没有能给我推导过程的QAQ</p><p>在线等~</p><hr><h2 id="附录：论AI目前为什么不能取代人类"><a href="#附录：论AI目前为什么不能取代人类" class="headerlink" title="附录：论AI目前为什么不能取代人类"></a>附录：论AI目前为什么不能取代人类</h2><p>请看vcr</p><p>1.《有固定点，小角度？那就是简谐运动！》————来自亲爱的deepseek</p><p><img src="/../images/deepseek%E4%BD%A0%E5%9C%A8%E5%B9%B2%E5%98%9B.jpg"></p><p>2.《什么是物理，我听不懂，倾斜的杆子就是不会掉下来，牛顿说啥我不管》 </p><p>————GPT5 plus大人！\0&#x2F;</p><p><img src="/../images/gpt%E5%A4%A7%E4%BA%BA%E6%98%AF%E4%BD%95%E6%84%8F%E4%B8%BA.jpg"></p><hr><p>建议加入ai笑话大全~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;自由转动杆与铰链固定杆倾倒时间对比研究&quot;&gt;&lt;a href=&quot;#自由转动杆与铰链固定杆倾倒时间对比研究&quot; class=&quot;headerlink&quot; title=&quot;自由转动杆与铰链固定杆倾倒时间对比研究&quot;&gt;&lt;/a&gt;&lt;strong&gt;自由转动杆与铰链固定杆倾倒时间对比研究&lt;/</summary>
      
    
    
    
    <category term="编程" scheme="https://yifei-huang-cos.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>python网络编程--TCP篇</title>
    <link href="https://yifei-huang-cos.github.io/posts/8d64c14e/"/>
    <id>https://yifei-huang-cos.github.io/posts/8d64c14e/</id>
    <published>2026-01-26T02:00:19.000Z</published>
    <updated>2026-01-26T02:57:14.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP网络编程初步"><a href="#TCP网络编程初步" class="headerlink" title="TCP网络编程初步"></a>TCP网络编程初步</h1><p>在学习并发编程之前，先熟悉一个客户端与一个服务端</p><h2 id="TCP协议核心机制"><a href="#TCP协议核心机制" class="headerlink" title="TCP协议核心机制"></a>TCP协议核心机制</h2><p>TCP（传输控制协议）通过三次握手建立连接，通过四次挥手终止连接，确保数据传输的可靠性。</p><h2 id="服务端实现代码"><a href="#服务端实现代码" class="headerlink" title="服务端实现代码"></a>服务端实现代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 服务端的socket              IPV4           TCP</span></span><br><span class="line"><span class="comment"># 这个只负责接受客户端的连接请求</span></span><br><span class="line"></span><br><span class="line">server_socket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">8000</span>))</span><br><span class="line"><span class="comment"># 允许最大的等待个数</span></span><br><span class="line">server_socket.listen(<span class="number">128</span>)</span><br><span class="line"><span class="comment"># 接受客户端的连接</span></span><br><span class="line">socket2, client_addr = server_socket.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = socket2.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;来自客户端IP：<span class="subst">&#123;client_addr[<span class="number">0</span>]&#125;</span>,端口号<span class="subst">&#123;client_addr[<span class="number">1</span>]&#125;</span>:<span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 给客户端发送聊天信息</span></span><br><span class="line">    send_msg = <span class="built_in">input</span>(<span class="string">&#x27;server&gt;&gt;&#x27;</span>)</span><br><span class="line">    socket2.send(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">socket2.close()</span><br><span class="line">server_socket.close()</span><br></pre></td></tr></table></figure><h2 id="客户端实现代码"><a href="#客户端实现代码" class="headerlink" title="客户端实现代码"></a>客户端实现代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server_addr = (<span class="string">&#x27;192.168.100.199&#x27;</span>, <span class="number">8000</span>)</span><br><span class="line">client_socket.connect(server_addr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    send_msg = <span class="built_in">input</span>(<span class="string">&#x27;client&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> send_msg == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        client_socket.send(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    client_socket.send(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    msg = client_socket.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;来自服务端IP：<span class="subst">&#123;server_addr[<span class="number">0</span>]&#125;</span>,端口号<span class="subst">&#123;server_addr[<span class="number">1</span>]&#125;</span>:<span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure><h2 id="TCP三次握手详解"><a href="#TCP三次握手详解" class="headerlink" title="TCP三次握手详解"></a>TCP三次握手详解</h2><p>三次握手是TCP建立连接的过程，确保双方都有发送和接收能力。</p><h3 id="第一次握手：SYN"><a href="#第一次握手：SYN" class="headerlink" title="第一次握手：SYN"></a>第一次握手：SYN</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 → SYN=1, seq=x → 服务端</span><br></pre></td></tr></table></figure><p>客户端发送SYN包，seq为随机数x，进入SYN_SENT状态。</p><h3 id="第二次握手：SYN-ACK"><a href="#第二次握手：SYN-ACK" class="headerlink" title="第二次握手：SYN+ACK"></a>第二次握手：SYN+ACK</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 ← SYN=1, ACK=1, seq=y, ack=x+1 ← 服务端</span><br></pre></td></tr></table></figure><p>服务端收到SYN，发送SYN+ACK包：</p><ul><li>seq为随机数y</li><li>ack为x+1（确认收到客户端的x）<br>服务端进入SYN_RCVD状态。</li></ul><h3 id="第三次握手：ACK"><a href="#第三次握手：ACK" class="headerlink" title="第三次握手：ACK"></a>第三次握手：ACK</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 → ACK=1, seq=x+1, ack=y+1 → 服务端</span><br></pre></td></tr></table></figure><p>客户端发送ACK包：</p><ul><li>seq为x+1</li><li>ack为y+1（确认收到服务端的y）<br>双方进入ESTABLISHED状态，连接建立。</li></ul><h3 id="代码中的三次握手"><a href="#代码中的三次握手" class="headerlink" title="代码中的三次握手"></a>代码中的三次握手</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端发起连接（第一次握手）</span></span><br><span class="line">client_socket.connect(server_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端接受连接（完成三次握手）</span></span><br><span class="line">socket2, client_addr = server_socket.accept()</span><br></pre></td></tr></table></figure><h2 id="TCP四次挥手详解"><a href="#TCP四次挥手详解" class="headerlink" title="TCP四次挥手详解"></a>TCP四次挥手详解</h2><p>四次挥手是TCP断开连接的过程，确保双方数据都传输完毕。</p><h3 id="第一次挥手：FIN"><a href="#第一次挥手：FIN" class="headerlink" title="第一次挥手：FIN"></a>第一次挥手：FIN</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 → FIN=1, seq=u → 服务端</span><br></pre></td></tr></table></figure><p>客户端发送FIN包，seq为u，进入FIN_WAIT_1状态。</p><h3 id="第二次挥手：ACK"><a href="#第二次挥手：ACK" class="headerlink" title="第二次挥手：ACK"></a>第二次挥手：ACK</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 ← ACK=1, seq=v, ack=u+1 ← 服务端</span><br></pre></td></tr></table></figure><p>服务端发送ACK包：</p><ul><li>ack为u+1（确认收到客户端的FIN）<br>服务端进入CLOSE_WAIT状态，客户端进入FIN_WAIT_2状态。</li></ul><h3 id="第三次挥手：FIN"><a href="#第三次挥手：FIN" class="headerlink" title="第三次挥手：FIN"></a>第三次挥手：FIN</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 ← FIN=1, ACK=1, seq=w, ack=u+1 ← 服务端</span><br></pre></td></tr></table></figure><p>服务端发送FIN+ACK包，进入LAST_ACK状态。</p><h3 id="第四次挥手：ACK"><a href="#第四次挥手：ACK" class="headerlink" title="第四次挥手：ACK"></a>第四次挥手：ACK</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">客户端 → ACK=1, seq=u+1, ack=w+1 → 服务端</span><br></pre></td></tr></table></figure><p>客户端发送ACK包，进入TIME_WAIT状态（等待2MSL），服务端关闭连接。</p><h3 id="代码中的四次挥手"><a href="#代码中的四次挥手" class="headerlink" title="代码中的四次挥手"></a>代码中的四次挥手</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端发送quit（发起第一次挥手）</span></span><br><span class="line">client_socket.send(<span class="string">&#x27;quit&#x27;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务端收到quit（第二次挥手）</span></span><br><span class="line">msg = socket2.recv(<span class="number">1024</span>).decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> msg == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭套接字（完成挥手过程）</span></span><br><span class="line">socket2.close()</span><br><span class="line">server_socket.close()</span><br><span class="line">client_socket.close()</span><br></pre></td></tr></table></figure><h2 id="TCP状态转换"><a href="#TCP状态转换" class="headerlink" title="TCP状态转换"></a>TCP状态转换</h2><h3 id="建立连接状态"><a href="#建立连接状态" class="headerlink" title="建立连接状态"></a>建立连接状态</h3><ol><li>CLOSED：初始状态</li><li>SYN_SENT：客户端发送SYN后</li><li>LISTEN：服务端调用listen()后</li><li>SYN_RCVD：服务端收到SYN后</li><li>ESTABLISHED：连接建立完成</li></ol><h3 id="断开连接状态"><a href="#断开连接状态" class="headerlink" title="断开连接状态"></a>断开连接状态</h3><ol><li>FIN_WAIT_1：客户端第一次挥手</li><li>CLOSE_WAIT：服务端第一次收到FIN</li><li>FIN_WAIT_2：客户端收到ACK</li><li>LAST_ACK：服务端发送FIN</li><li>TIME_WAIT：客户端最后等待</li><li>CLOSED：连接完全关闭</li></ol><h2 id="为什么需要三次握手？"><a href="#为什么需要三次握手？" class="headerlink" title="为什么需要三次握手？"></a>为什么需要三次握手？</h2><h3 id="防止旧的重复连接初始化"><a href="#防止旧的重复连接初始化" class="headerlink" title="防止旧的重复连接初始化"></a>防止旧的重复连接初始化</h3><ul><li>避免网络延迟导致的旧连接干扰新连接</li><li>确保双方都知道对方准备好了</li></ul><h3 id="同步序列号"><a href="#同步序列号" class="headerlink" title="同步序列号"></a>同步序列号</h3><ul><li>交换初始序列号（ISN）</li><li>确保数据按序传输</li></ul><h3 id="确认双方能力"><a href="#确认双方能力" class="headerlink" title="确认双方能力"></a>确认双方能力</h3><ul><li>确认双方都有发送和接收能力</li><li>协商窗口大小等参数</li></ul><h2 id="为什么需要四次挥手？"><a href="#为什么需要四次挥手？" class="headerlink" title="为什么需要四次挥手？"></a>为什么需要四次挥手？</h2><h3 id="半关闭状态"><a href="#半关闭状态" class="headerlink" title="半关闭状态"></a>半关闭状态</h3><ul><li>TCP是全双工的，可以单向关闭</li><li>服务端可能还有数据要发送</li></ul><h3 id="确保数据完整性"><a href="#确保数据完整性" class="headerlink" title="确保数据完整性"></a>确保数据完整性</h3><ul><li>等待所有数据都传输完毕</li><li>确保没有数据丢失</li></ul><h3 id="可靠终止"><a href="#可靠终止" class="headerlink" title="可靠终止"></a>可靠终止</h3><ul><li>双方都知道连接要关闭了</li><li>防止数据包在网络中”迷路”</li></ul><h2 id="TIME-WAIT状态的作用"><a href="#TIME-WAIT状态的作用" class="headerlink" title="TIME_WAIT状态的作用"></a>TIME_WAIT状态的作用</h2><h3 id="等待2MSL的原因"><a href="#等待2MSL的原因" class="headerlink" title="等待2MSL的原因"></a>等待2MSL的原因</h3><ol><li><strong>确保最后一个ACK到达</strong>：如果服务端没收到ACK会重发FIN</li><li><strong>让旧连接的数据包消失</strong>：防止影响新连接</li><li><strong>MSL（Maximum Segment Lifetime）</strong>：报文最大生存时间</li></ol><h2 id="实际编程中的影响"><a href="#实际编程中的影响" class="headerlink" title="实际编程中的影响"></a>实际编程中的影响</h2><h3 id="连接建立失败"><a href="#连接建立失败" class="headerlink" title="连接建立失败"></a>连接建立失败</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    client_socket.connect(server_addr)</span><br><span class="line"><span class="keyword">except</span> ConnectionRefusedError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;连接被拒绝：服务端未启动或端口错误&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="端口复用问题"><a href="#端口复用问题" class="headerlink" title="端口复用问题"></a>端口复用问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 避免Address already in use错误</span></span><br><span class="line">server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 半关闭：关闭发送，仍可接收</span></span><br><span class="line">client_socket.shutdown(socket.SHUT_WR)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待对方关闭</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data = client_socket.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>三次握手建立可靠连接，四次挥手优雅终止连接，这是TCP协议的核心机制。理解这些过程对于调试网络问题和编写稳定的网络程序非常重要。</p><hr><p><em>在代码中，connect()触发三次握手，close()触发四次挥手，这些细节都由操作系统自动处理。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP网络编程初步&quot;&gt;&lt;a href=&quot;#TCP网络编程初步&quot; class=&quot;headerlink&quot; title=&quot;TCP网络编程初步&quot;&gt;&lt;/a&gt;TCP网络编程初步&lt;/h1&gt;&lt;p&gt;在学习并发编程之前，先熟悉一个客户端与一个服务端&lt;/p&gt;
&lt;h2 id=&quot;TCP协议</summary>
      
    
    
    
    <category term="编程" scheme="https://yifei-huang-cos.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>UDP的简易实现</title>
    <link href="https://yifei-huang-cos.github.io/posts/35e240ca/"/>
    <id>https://yifei-huang-cos.github.io/posts/35e240ca/</id>
    <published>2026-01-23T01:00:06.000Z</published>
    <updated>2026-01-26T02:57:14.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PYTHON网络编程——UDP篇"><a href="#PYTHON网络编程——UDP篇" class="headerlink" title="PYTHON网络编程——UDP篇"></a>PYTHON网络编程——UDP篇</h1><h2 id="一、UDP简介"><a href="#一、UDP简介" class="headerlink" title="一、UDP简介"></a>一、UDP简介</h2><h3 id="什么是UDP？"><a href="#什么是UDP？" class="headerlink" title="什么是UDP？"></a>什么是UDP？</h3><p>UDP（用户数据报协议）是一种无连接的传输层协议，具有以下特点：</p><ul><li>无需建立连接</li><li>不可靠传输（可能丢包）</li><li>传输速度快</li><li>适合实时性要求高的场景</li></ul><h3 id="基本流程对比"><a href="#基本流程对比" class="headerlink" title="基本流程对比"></a>基本流程对比</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP编程流程：创建socket → 绑定 → 监听 → 接受连接 → 收发数据 → 关闭</span><br><span class="line">UDP编程流程：创建socket → 绑定（服务端）→ 直接收发数据 → 关闭</span><br></pre></td></tr></table></figure><h2 id="二、服务端代码详解"><a href="#二、服务端代码详解" class="headerlink" title="二、服务端代码详解"></a>二、服务端代码详解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建了一个UDP的socket对象</span></span><br><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># socket.AF_INET: 使用IPv4地址族</span></span><br><span class="line"><span class="comment"># socket.SOCK_DGRAM: 使用UDP协议（数据报套接字）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前一个是我的ipv4地址，如果用127.0.0.1则是在本地</span></span><br><span class="line"><span class="comment"># 如果是空字符，服务端绑定到所有的ip地址</span></span><br><span class="line">server_socket.bind((<span class="string">&#x27;192.168.100.199&#x27;</span>, <span class="number">6666</span>))</span><br><span class="line"><span class="comment"># bind()方法将套接字绑定到指定地址和端口</span></span><br><span class="line"><span class="comment"># &#x27;192.168.100.199&#x27;: 绑定到特定局域网IP</span></span><br><span class="line"><span class="comment"># 其他选择：</span></span><br><span class="line"><span class="comment">#   &#x27;127.0.0.1&#x27;: 本地回环，只能本机访问</span></span><br><span class="line"><span class="comment">#   &#x27;0.0.0.0&#x27;: 绑定所有网络接口</span></span><br><span class="line"><span class="comment">#   &#x27;&#x27;: 同&#x27;0.0.0.0&#x27;</span></span><br><span class="line"><span class="comment"># 6666: 端口号，范围0-65535（0-1023为系统保留）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># msg是收到的数据，addr是源地址和端口号</span></span><br><span class="line">    msg, addr = server_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># recvfrom()是阻塞方法，会一直等待直到收到数据</span></span><br><span class="line">    <span class="comment"># 1024: 缓冲区大小，单位字节</span></span><br><span class="line">    <span class="comment"># msg: 接收到的字节数据</span></span><br><span class="line">    <span class="comment"># addr: 元组 (客户端IP, 客户端端口)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> msg.decode(<span class="string">&#x27;utf8&#x27;</span>) == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 如果客户端发送&#x27;quit&#x27;，则退出循环</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;来自IP：<span class="subst">&#123;addr[<span class="number">0</span>]&#125;</span>,端口号：<span class="subst">&#123;addr[<span class="number">1</span>]&#125;</span>的消息：<span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 显示消息来源和内容</span></span><br><span class="line"></span><br><span class="line">    send_msg = <span class="built_in">input</span>(<span class="string">&#x27;服务端&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 等待用户输入回复内容</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不能发送字符串，应该是字节数据</span></span><br><span class="line">    server_socket.sendto(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>), addr)</span><br><span class="line">    <span class="comment"># sendto()发送数据到指定地址</span></span><br><span class="line">    <span class="comment"># encode(&#x27;utf8&#x27;): 将字符串转为字节数据</span></span><br><span class="line">    <span class="comment"># addr: 目标地址（这里发回给原客户端）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># close</span></span><br><span class="line">server_socket.close()</span><br><span class="line"><span class="comment"># 关闭套接字，释放资源</span></span><br></pre></td></tr></table></figure><h2 id="三、客户端代码详解"><a href="#三、客户端代码详解" class="headerlink" title="三、客户端代码详解"></a>三、客户端代码详解</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建了一个UDP的socket对象</span></span><br><span class="line">client_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端socket不用bind</span></span><br><span class="line"><span class="comment"># 客户端通常由系统自动分配端口号</span></span><br><span class="line"><span class="comment"># 如果需要绑定特定端口，也可以使用bind()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># send msg</span></span><br><span class="line">    send_msg = <span class="built_in">input</span>(<span class="string">&#x27;客户端&gt;&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> send_msg == <span class="string">&#x27;quit&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 输入&#x27;quit&#x27;退出</span></span><br><span class="line">    </span><br><span class="line">    client_socket.sendto(send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>), (<span class="string">&#x27;192.168.100.199&#x27;</span>, <span class="number">6666</span>))</span><br><span class="line">    <span class="comment"># 发送数据到服务器</span></span><br><span class="line">    <span class="comment"># (&#x27;192.168.100.199&#x27;, 6666): 服务器地址和端口</span></span><br><span class="line">    <span class="comment"># 必须与服务器绑定的地址一致</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># receive msg</span></span><br><span class="line">    msg, addr = client_socket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 等待服务器回复</span></span><br><span class="line">    <span class="comment"># 注意：这里会阻塞，直到收到服务器响应</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;来自服务端IP：<span class="subst">&#123;addr[<span class="number">0</span>]&#125;</span>,端口号：<span class="subst">&#123;addr[<span class="number">1</span>]&#125;</span>的消息：<span class="subst">&#123;msg&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="comment"># 显示服务器回复</span></span><br><span class="line"></span><br><span class="line">client_socket.close()</span><br><span class="line"><span class="comment"># 关闭客户端套接字</span></span><br></pre></td></tr></table></figure><h2 id="四、关键知识点"><a href="#四、关键知识点" class="headerlink" title="四、关键知识点"></a>四、关键知识点</h2><h3 id="1-UDP套接字创建"><a href="#1-UDP套接字创建" class="headerlink" title="1. UDP套接字创建"></a>1. UDP套接字创建</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br></pre></td></tr></table></figure><ul><li><code>AF_INET</code>: IPv4地址族</li><li><code>SOCK_DGRAM</code>: UDP数据报类型</li></ul><h3 id="2-地址绑定"><a href="#2-地址绑定" class="headerlink" title="2. 地址绑定"></a>2. 地址绑定</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端必须绑定，客户端可选</span></span><br><span class="line">server_socket.bind((IP地址, 端口号))</span><br></pre></td></tr></table></figure><h3 id="3-数据收发"><a href="#3-数据收发" class="headerlink" title="3. 数据收发"></a>3. 数据收发</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 接收数据（返回数据和来源地址）</span></span><br><span class="line">data, addr = socket.recvfrom(缓冲区大小)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送数据到指定地址</span></span><br><span class="line">socket.sendto(字节数据, (目标IP, 目标端口))</span><br></pre></td></tr></table></figure><h3 id="4-编码转换"><a href="#4-编码转换" class="headerlink" title="4. 编码转换"></a>4. 编码转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送：字符串 → 字节</span></span><br><span class="line">send_msg.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收：字节 → 字符串</span></span><br><span class="line">msg.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="五、注意事项"><a href="#五、注意事项" class="headerlink" title="五、注意事项"></a>五、注意事项</h2><ol><li><p><strong>UDP是无连接的</strong></p><ul><li>每次发送都要指定目标地址</li><li>不保证数据顺序和可靠性</li></ul></li><li><p><strong>地址和端口</strong></p><ul><li>服务端需要固定端口</li><li>客户端端口通常由系统分配</li></ul></li><li><p><strong>数据大小</strong></p><ul><li>UDP数据包不宜过大（通常&lt;1500字节）</li><li>避免IP分片，提高传输效率</li></ul></li><li><p><strong>阻塞问题</strong></p><ul><li><code>recvfrom()</code>是阻塞调用</li><li>程序会等待直到收到数据</li></ul></li><li><p><strong>多客户端处理</strong></p><ul><li>UDP服务端可以同时处理多个客户端</li><li>通过addr区分不同客户端</li></ul></li></ol><h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><h3 id="Q1-为什么客户端不需要bind？"><a href="#Q1-为什么客户端不需要bind？" class="headerlink" title="Q1: 为什么客户端不需要bind？"></a>Q1: 为什么客户端不需要bind？</h3><p>A: 客户端第一次调用sendto()时，系统会自动分配一个可用端口。</p><h3 id="Q2-如果服务器没启动，客户端会怎样？"><a href="#Q2-如果服务器没启动，客户端会怎样？" class="headerlink" title="Q2: 如果服务器没启动，客户端会怎样？"></a>Q2: 如果服务器没启动，客户端会怎样？</h3><p>A: 客户端发送的数据会丢失，recvfrom()会一直等待（阻塞）。</p><h3 id="Q3-如何测试本机通信？"><a href="#Q3-如何测试本机通信？" class="headerlink" title="Q3: 如何测试本机通信？"></a>Q3: 如何测试本机通信？</h3><p>A: 服务端绑定<code>127.0.0.1</code>，客户端连接<code>127.0.0.1</code>。</p><h3 id="Q4-如何让其他电脑连接？"><a href="#Q4-如何让其他电脑连接？" class="headerlink" title="Q4: 如何让其他电脑连接？"></a>Q4: 如何让其他电脑连接？</h3><p>A: </p><ol><li>服务端绑定<code>0.0.0.0</code>或局域网IP</li><li>关闭防火墙或开放对应端口</li><li>客户端使用服务器实际IP地址</li></ol><h2 id="七、完整的UDP还需要"><a href="#七、完整的UDP还需要" class="headerlink" title="七、完整的UDP还需要"></a>七、完整的UDP还需要</h2><ol><li><strong>异常处理</strong>：添加try-except处理网络错误</li><li><strong>超时设置</strong>：使用settimeout()避免永久阻塞</li><li><strong>多线程</strong>：同时处理多个客户端请求</li><li><strong>数据验证</strong>：添加简单的协议头验证数据完整性</li></ol><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>​      UDP编程的核心模式：</p><ul><li>服务端：创建→绑定→循环收发→关闭</li><li>客户端：创建→循环收发→关闭</li></ul><p>这种简单的请求-响应模式是UDP编程的基础，理解了这种模式后，可以在此基础上构建更复杂的UDP应用。</p><hr><p><em>注：实际使用时，请确保服务端和客户端的IP地址和端口号配置正确，防火墙已开放相应端口。</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PYTHON网络编程——UDP篇&quot;&gt;&lt;a href=&quot;#PYTHON网络编程——UDP篇&quot; class=&quot;headerlink&quot; title=&quot;PYTHON网络编程——UDP篇&quot;&gt;&lt;/a&gt;PYTHON网络编程——UDP篇&lt;/h1&gt;&lt;h2 id=&quot;一、UDP简介&quot;&gt;</summary>
      
    
    
    
    <category term="编程" scheme="https://yifei-huang-cos.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>如何用hexo搭建个人博客</title>
    <link href="https://yifei-huang-cos.github.io/posts/cd1cb590/"/>
    <id>https://yifei-huang-cos.github.io/posts/cd1cb590/</id>
    <published>2026-01-21T03:12:12.000Z</published>
    <updated>2026-01-26T02:57:14.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo-博客搭建与配置指南"><a href="#Hexo-博客搭建与配置指南" class="headerlink" title="Hexo 博客搭建与配置指南"></a>Hexo 博客搭建与配置指南</h1><h2 id="📖-简介"><a href="#📖-简介" class="headerlink" title="📖 简介"></a>📖 简介</h2><p>Hexo 是一个快速、简洁且高效的静态博客框架。它使用 Markdown解析文章，在几秒内即可生成静态网页。本指南将帮助您快速搭建并配置一个 Hexo 博客。</p><h2 id="🚀-快速开始"><a href="#🚀-快速开始" class="headerlink" title="🚀 快速开始"></a>🚀 快速开始</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><ol><li><p><strong>安装 Node.js</strong></p><ul><li>版本要求：Node.js 14.0 或以上版本</li><li>下载地址：<a href="https://nodejs.org/">Node.js 官网</a></li></ul></li><li><p><strong>安装 Git</strong></p><ul><li>下载地址：<a href="https://git-scm.com/">Git 官网</a></li></ul></li></ol><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>打开终端（命令提示符）并执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h3 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init my-blog</span><br><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h3 id="本地预览"><a href="#本地预览" class="headerlink" title="本地预览"></a>本地预览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line"><span class="comment"># 生成：</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 预览： （浏览器访问 `http://localhost:4000` 查看效果）</span></span><br><span class="line">hexo s</span><br><span class="line"><span class="comment"># 部署：</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h2 id="⚙️-基本配置"><a href="#⚙️-基本配置" class="headerlink" title="⚙️ 基本配置"></a>⚙️ 基本配置</h2><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>博客的主要配置文件为 <code>_config.yml</code>，位于博客根目录下。</p><h3 id="常用配置项"><a href="#常用配置项" class="headerlink" title="常用配置项"></a>常用配置项</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 网站信息</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">我的博客</span>                    <span class="comment"># 网站标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">&#x27;&#x27;</span>                       <span class="comment"># 网站副标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&#x27;&#x27;</span>                    <span class="comment"># 网站描述</span></span><br><span class="line"><span class="attr">keywords:</span>                         <span class="comment"># 网站关键词</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">作者名</span>                     <span class="comment"># 作者名称</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span>                   <span class="comment"># 语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">&#x27;&#x27;</span>                      <span class="comment"># 时区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL 设置</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://yoursite.com</span>          <span class="comment"># 网站地址</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/</span>                           <span class="comment"># 网站根目录</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span>  <span class="comment"># 文章永久链接格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目录设置</span></span><br><span class="line"><span class="attr">source_dir:</span> <span class="string">source</span>                <span class="comment"># 资源文件夹</span></span><br><span class="line"><span class="attr">public_dir:</span> <span class="string">public</span>                <span class="comment"># 静态文件生成目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写作设置</span></span><br><span class="line"><span class="attr">new_post_name:</span> <span class="string">:title.md</span>          <span class="comment"># 新文章文件名格式</span></span><br><span class="line"><span class="attr">default_layout:</span> <span class="string">post</span>              <span class="comment"># 默认布局</span></span><br></pre></td></tr></table></figure><h2 id="🎨-主题安装与配置"><a href="#🎨-主题安装与配置" class="headerlink" title="🎨 主题安装与配置"></a>🎨 主题安装与配置</h2><h3 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h3><p>以我所使用的stellar 主题为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/stellar-theme/hexo-theme-syellar themes/stellar</span><br></pre></td></tr></table></figure><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>修改 <code>_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">stellar</span></span><br></pre></td></tr></table></figure><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>主题有自己的配置文件 <code>themes/stellar/_config.yml</code>，可进行个性化设置。</p><h2 id="📝-写作与发布"><a href="#📝-写作与发布" class="headerlink" title="📝 写作与发布"></a>📝 写作与发布</h2><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;文章标题&quot;</span></span><br></pre></td></tr></table></figure><p>文章文件位于 <code>source/_posts/文章标题.md</code></p><h3 id="文章-Front-matter"><a href="#文章-Front-matter" class="headerlink" title="文章 Front-matter"></a>文章 Front-matter</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 2024-05-20 10:00:00</span><br><span class="line">tags: [标签1, 标签2]</span><br><span class="line"><span class="section">categories: 分类名</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><code>hexo new [layout] &lt;title&gt;</code> - 新建文章</li><li><code>hexo clean</code> - 清除缓存</li><li><code>hexo generate</code> 或 <code>hexo g</code> - 生成静态文件</li><li><code>hexo server</code> 或 <code>hexo s</code> - 启动本地服务器</li><li><code>hexo deploy</code> 或 <code>hexo d</code> - 部署到远程仓库</li></ul><h2 id="🌐-部署到-GitHub-Pages"><a href="#🌐-部署到-GitHub-Pages" class="headerlink" title="🌐 部署到 GitHub Pages"></a>🌐 部署到 GitHub Pages</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li>创建 GitHub 仓库，命名为 <code>用户名.github.io</code></li><li>安装部署插件：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><h3 id="配置部署"><a href="#配置部署" class="headerlink" title="配置部署"></a>配置部署</h3><p>修改 <code>_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/用户名/用户名.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><h3 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h2 id="🔧-常用插件"><a href="#🔧-常用插件" class="headerlink" title="🔧 常用插件"></a>🔧 常用插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RSS 订阅</span></span><br><span class="line">npm install hexo-generator-feed --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点地图</span></span><br><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章搜索</span></span><br><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文章字数统计</span></span><br><span class="line">npm install hexo-wordcount --save</span><br></pre></td></tr></table></figure><h2 id="💡-实用技巧"><a href="#💡-实用技巧" class="headerlink" title="💡 实用技巧"></a>💡 实用技巧</h2><h3 id="自定义页面"><a href="#自定义页面" class="headerlink" title="自定义页面"></a>自定义页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><h3 id="草稿功能"><a href="#草稿功能" class="headerlink" title="草稿功能"></a>草稿功能</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo new draft <span class="string">&quot;草稿标题&quot;</span></span><br><span class="line">hexo publish <span class="string">&quot;草稿标题&quot;</span></span><br></pre></td></tr></table></figure><h3 id="图片引用"><a href="#图片引用" class="headerlink" title="图片引用"></a>图片引用</h3><ol><li>将图片放入 <code>source/images/</code> 目录</li><li>在文章中引用：</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片描述</span>](<span class="link">/images/图片文件名.jpg</span>)</span><br></pre></td></tr></table></figure><h2 id="🛠️-故障排除"><a href="#🛠️-故障排除" class="headerlink" title="🛠️ 故障排除"></a>🛠️ 故障排除</h2><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li><p><strong>部署失败</strong></p><ul><li>检查 Git 配置</li><li>确认仓库地址正确</li><li>检查网络连接</li></ul></li><li><p><strong>页面无法加载</strong></p><ul><li>运行 <code>hexo clean</code></li><li>重新生成和启动服务器</li></ul></li><li><p><strong>主题不生效</strong></p><ul><li>确认主题文件夹名称正确</li><li>检查 <code>_config.yml</code> 中 theme 配置</li></ul></li></ol><h2 id="📚-学习资源"><a href="#📚-学习资源" class="headerlink" title="📚 学习资源"></a>📚 学习资源</h2><ul><li><a href="https://hexo.io/zh-cn/docs/">Hexo 官方文档</a></li><li><a href="https://github.com/hexojs/hexo">Hexo GitHub</a></li><li><a href="https://theme-next.js.org/">Next 主题文档</a></li></ul><hr><blockquote><p><strong>提示</strong>：配置时建议备份原配置文件，每次只修改少量配置并测试效果。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo-博客搭建与配置指南&quot;&gt;&lt;a href=&quot;#Hexo-博客搭建与配置指南&quot; class=&quot;headerlink&quot; title=&quot;Hexo 博客搭建与配置指南&quot;&gt;&lt;/a&gt;Hexo 博客搭建与配置指南&lt;/h1&gt;&lt;h2 id=&quot;📖-简介&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
</feed>
